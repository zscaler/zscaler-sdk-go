
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>zpa: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/zscaler/zscaler-sdk-go/v2/zpa/client.go (69.0%)</option>
				
				<option value="file1">github.com/zscaler/zscaler-sdk-go/v2/zpa/config.go (54.8%)</option>
				
				<option value="file2">github.com/zscaler/zscaler-sdk-go/v2/zpa/errors.go (46.2%)</option>
				
				<option value="file3">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/appconnectorcontroller/service.go (0.0%)</option>
				
				<option value="file4">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/appconnectorcontroller/zpa_app_connector_controller.go (0.0%)</option>
				
				<option value="file5">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/appconnectorgroup/service.go (16.7%)</option>
				
				<option value="file6">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/appconnectorgroup/zpa_app_connector_group.go (91.2%)</option>
				
				<option value="file7">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/applicationsegment/service.go (16.7%)</option>
				
				<option value="file8">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/applicationsegment/zpa_application_segment.go (72.9%)</option>
				
				<option value="file9">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/applicationsegmentbytype/applicationsegmentbytype.go (94.1%)</option>
				
				<option value="file10">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/applicationsegmentbytype/service.go (16.7%)</option>
				
				<option value="file11">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/applicationsegmentinspection/service.go (16.7%)</option>
				
				<option value="file12">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/applicationsegmentinspection/zpa_application_segment_inspection.go (76.6%)</option>
				
				<option value="file13">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/applicationsegmentpra/service.go (16.7%)</option>
				
				<option value="file14">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/applicationsegmentpra/zpa_application_segment_pra.go (89.1%)</option>
				
				<option value="file15">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/appservercontroller/service.go (16.7%)</option>
				
				<option value="file16">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/appservercontroller/zpa_app_server_controller.go (91.2%)</option>
				
				<option value="file17">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/bacertificate/service.go (16.7%)</option>
				
				<option value="file18">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/bacertificate/zpa_ba_certificate.go (37.9%)</option>
				
				<option value="file19">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/browseraccess/service.go (16.7%)</option>
				
				<option value="file20">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/browseraccess/zpa_browser_access.go (92.1%)</option>
				
				<option value="file21">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/clienttypes/clienttypes.go (83.3%)</option>
				
				<option value="file22">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/clienttypes/service.go (100.0%)</option>
				
				<option value="file23">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/cloudbrowserisolation/cbibannercontroller/cbibannercontroller.go (82.4%)</option>
				
				<option value="file24">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/cloudbrowserisolation/cbibannercontroller/service.go (100.0%)</option>
				
				<option value="file25">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/cloudbrowserisolation/cbicertificatecontroller/cbicertificatecontroller.go (55.9%)</option>
				
				<option value="file26">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/cloudbrowserisolation/cbicertificatecontroller/service.go (100.0%)</option>
				
				<option value="file27">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/cloudbrowserisolation/cbiprofilecontroller/cbiprofilecontroller.go (82.4%)</option>
				
				<option value="file28">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/cloudbrowserisolation/cbiprofilecontroller/service.go (100.0%)</option>
				
				<option value="file29">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/cloudbrowserisolation/cbiregions/cbiregions.go (84.6%)</option>
				
				<option value="file30">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/cloudbrowserisolation/cbiregions/service.go (100.0%)</option>
				
				<option value="file31">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/cloudbrowserisolation/cbizpaprofile/cbizpaprofile.go (55.0%)</option>
				
				<option value="file32">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/cloudbrowserisolation/cbizpaprofile/service.go (100.0%)</option>
				
				<option value="file33">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/cloudbrowserisolation/isolationprofile/isolationprofile.go (85.7%)</option>
				
				<option value="file34">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/cloudbrowserisolation/isolationprofile/service.go (100.0%)</option>
				
				<option value="file35">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/cloudconnectorgroup/service.go (0.0%)</option>
				
				<option value="file36">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/cloudconnectorgroup/zpa_cloud_connector_group.go (0.0%)</option>
				
				<option value="file37">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common/common.go (51.0%)</option>
				
				<option value="file38">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/customerversionprofile/service.go (100.0%)</option>
				
				<option value="file39">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/customerversionprofile/zpa_customer_version_profile.go (76.9%)</option>
				
				<option value="file40">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/emergencyaccess/emergencyaccess.go (84.4%)</option>
				
				<option value="file41">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/emergencyaccess/service.go (100.0%)</option>
				
				<option value="file42">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/enrollmentcert/service.go (16.7%)</option>
				
				<option value="file43">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/enrollmentcert/zpa_enrollmentcert.go (84.2%)</option>
				
				<option value="file44">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/idpcontroller/service.go (100.0%)</option>
				
				<option value="file45">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/idpcontroller/zpa_idp_controller.go (84.2%)</option>
				
				<option value="file46">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/inspectioncontrol/inspection_custom_controls/service.go (100.0%)</option>
				
				<option value="file47">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/inspectioncontrol/inspection_custom_controls/zpa_inspection_custom_controls.go (92.7%)</option>
				
				<option value="file48">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/inspectioncontrol/inspection_predefined_controls/service.go (100.0%)</option>
				
				<option value="file49">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/inspectioncontrol/inspection_predefined_controls/zpa_inspection_predefined_controls.go (70.0%)</option>
				
				<option value="file50">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/inspectioncontrol/inspection_profile/service.go (100.0%)</option>
				
				<option value="file51">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/inspectioncontrol/inspection_profile/zpa_inspection_profile.go (66.7%)</option>
				
				<option value="file52">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/lssconfigcontroller/service.go (100.0%)</option>
				
				<option value="file53">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/lssconfigcontroller/zpa_lss_client_types.go (83.3%)</option>
				
				<option value="file54">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/lssconfigcontroller/zpa_lss_config_controller.go (91.2%)</option>
				
				<option value="file55">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/lssconfigcontroller/zpa_lss_config_formats.go (83.3%)</option>
				
				<option value="file56">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/lssconfigcontroller/zpa_lss_status_codes.go (85.7%)</option>
				
				<option value="file57">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/machinegroup/service.go (16.7%)</option>
				
				<option value="file58">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/machinegroup/zpa_machine_group.go (84.2%)</option>
				
				<option value="file59">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/microtenants/microtenants.go (74.4%)</option>
				
				<option value="file60">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/microtenants/service.go (100.0%)</option>
				
				<option value="file61">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/platforms/platforms.go (83.3%)</option>
				
				<option value="file62">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/platforms/service.go (100.0%)</option>
				
				<option value="file63">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/policysetcontroller/policysetcontroller.go (44.0%)</option>
				
				<option value="file64">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/policysetcontroller/service.go (16.7%)</option>
				
				<option value="file65">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/policysetcontrollerv2/policysetcontrollerv2.go (27.8%)</option>
				
				<option value="file66">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/policysetcontrollerv2/service.go (16.7%)</option>
				
				<option value="file67">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/postureprofile/service.go (100.0%)</option>
				
				<option value="file68">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/postureprofile/zpa_posture_profile.go (82.8%)</option>
				
				<option value="file69">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/privilegedremoteaccess/praapproval/praapproval.go (70.0%)</option>
				
				<option value="file70">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/privilegedremoteaccess/praapproval/service.go (16.7%)</option>
				
				<option value="file71">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/privilegedremoteaccess/praconsole/praconsole.go (63.0%)</option>
				
				<option value="file72">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/privilegedremoteaccess/praconsole/service.go (16.7%)</option>
				
				<option value="file73">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/privilegedremoteaccess/pracredential/credential_controller.go (75.6%)</option>
				
				<option value="file74">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/privilegedremoteaccess/pracredential/service.go (16.7%)</option>
				
				<option value="file75">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/privilegedremoteaccess/praportal/praportal.go (91.2%)</option>
				
				<option value="file76">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/privilegedremoteaccess/praportal/service.go (16.7%)</option>
				
				<option value="file77">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/provisioningkey/service.go (16.7%)</option>
				
				<option value="file78">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/provisioningkey/zpa_provisioning_key.go (65.5%)</option>
				
				<option value="file79">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/samlattribute/service.go (100.0%)</option>
				
				<option value="file80">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/samlattribute/zpa_saml_attribute.go (84.2%)</option>
				
				<option value="file81">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/scimattributeheader/service.go (100.0%)</option>
				
				<option value="file82">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/scimattributeheader/zpa_scim_attribute_header.go (73.1%)</option>
				
				<option value="file83">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/scimgroup/service.go (100.0%)</option>
				
				<option value="file84">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/scimgroup/zpa_scim_group.go (84.2%)</option>
				
				<option value="file85">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/segmentgroup/service.go (16.7%)</option>
				
				<option value="file86">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/segmentgroup/zpa_segment_group.go (91.2%)</option>
				
				<option value="file87">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/servergroup/service.go (16.7%)</option>
				
				<option value="file88">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/servergroup/zpa_server_group.go (91.2%)</option>
				
				<option value="file89">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/serviceedgecontroller/service.go (0.0%)</option>
				
				<option value="file90">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/serviceedgecontroller/zpa_service_edge_controller.go (0.0%)</option>
				
				<option value="file91">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/serviceedgegroup/service.go (16.7%)</option>
				
				<option value="file92">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/serviceedgegroup/zpa_service_edge_group.go (91.2%)</option>
				
				<option value="file93">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/trustednetwork/service.go (100.0%)</option>
				
				<option value="file94">github.com/zscaler/zscaler-sdk-go/v2/zpa/services/trustednetwork/zpa_trusted_network.go (82.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package zpa

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "html"
        "io"
        "net/http"
        "net/url"
        "os"
        "reflect"
        "strings"
        "time"

        "github.com/google/go-querystring/query"
        "github.com/google/uuid"

        "github.com/zscaler/zscaler-sdk-go/v2/cache"
        "github.com/zscaler/zscaler-sdk-go/v2/logger"
        "github.com/zscaler/zscaler-sdk-go/v2/utils"
)

type Client struct {
        Config *Config
        cache  cache.Cache
}

// NewClient returns a new client for the specified apiKey.
func NewClient(config *Config) (c *Client) <span class="cov10" title="16">{
        if config == nil </span><span class="cov8" title="10">{
                config, _ = NewConfig("", "", "", "", "")
        }</span>
        <span class="cov10" title="16">cche, err := cache.NewCache(config.cacheTtl, config.cacheCleanwindow, config.cacheMaxSizeMB)
        if err != nil </span><span class="cov0" title="0">{
                cche = cache.NewNopCache()
        }</span>
        <span class="cov10" title="16">c = &amp;Client{Config: config, cache: cche}
        return</span>
}

func (client *Client) WithFreshCache() <span class="cov1" title="1">{
        client.Config.freshCache = true
}</span>

func (client *Client) NewRequestDo(method, url string, options, body, v interface{}) (*http.Response, error) <span class="cov4" title="3">{
        req, err := client.getRequest(method, url, options, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="3">key := cache.CreateCacheKey(req)
        if client.Config.cacheEnabled </span><span class="cov4" title="3">{
                if req.Method != http.MethodGet </span><span class="cov1" title="1">{
                        // this will allow to remove resource from cache when PUT/DELETE/PATCH requests are called, which modifies the resource
                        client.cache.Delete(key)
                        // to avoid resources that GET url is not the same as DELETE/PUT/PATCH url, because of different query params.
                        // example delete app segment has key url/&lt;id&gt;?forceDelete=true but GET has url/&lt;id&gt;, in this case we clean the whole cache entries with key prefix url/&lt;id&gt;
                        client.cache.ClearAllKeysWithPrefix(strings.Split(key, "?")[0])
                }</span>
                <span class="cov4" title="3">resp := client.cache.Get(key)
                inCache := resp != nil
                if client.Config.freshCache </span><span class="cov0" title="0">{
                        client.cache.Delete(key)
                        inCache = false
                        client.Config.freshCache = false
                }</span>
                <span class="cov4" title="3">if inCache </span><span class="cov0" title="0">{
                        if v != nil </span><span class="cov0" title="0">{
                                respData, err := io.ReadAll(resp.Body)
                                if err == nil </span><span class="cov0" title="0">{
                                        resp.Body = io.NopCloser(bytes.NewBuffer(respData))
                                }</span>
                                <span class="cov0" title="0">if err := decodeJSON(respData, v); err != nil </span><span class="cov0" title="0">{
                                        return resp, err
                                }</span>
                        }
                        <span class="cov0" title="0">unescapeHTML(v)
                        client.Config.Logger.Printf("[INFO] served from cache, key:%s\n", key)
                        return resp, nil</span>
                }
        }
        <span class="cov4" title="3">resp, err := client.newRequestDoCustom(method, url, options, body, v)
        if err != nil </span><span class="cov1" title="1">{
                return resp, err
        }</span>
        <span class="cov3" title="2">if client.Config.cacheEnabled &amp;&amp; resp.StatusCode &gt;= 200 &amp;&amp; resp.StatusCode &lt;= 299 &amp;&amp; req.Method == http.MethodGet &amp;&amp; v != nil &amp;&amp; reflect.TypeOf(v).Kind() != reflect.Slice </span><span class="cov1" title="1">{
                d, err := json.Marshal(v)
                if err == nil </span><span class="cov1" title="1">{
                        resp.Body = io.NopCloser(bytes.NewReader(d))
                        client.Config.Logger.Printf("[INFO] saving to cache, key:%s\n", key)
                        client.cache.Set(key, cache.CopyResponse(resp))
                }</span> else<span class="cov0" title="0"> {
                        client.Config.Logger.Printf("[ERROR] saving to cache error:%s, key:%s\n", err, key)
                }</span>
        }
        <span class="cov3" title="2">return resp, nil</span>
}

func (client *Client) authenticate() error <span class="cov6" title="5">{
        client.Config.Lock()
        defer client.Config.Unlock()
        if client.Config.AuthToken == nil || client.Config.AuthToken.AccessToken == "" || utils.IsTokenExpired(client.Config.AuthToken.AccessToken) </span><span class="cov6" title="5">{
                if client.Config.ClientID == "" || client.Config.ClientSecret == "" </span><span class="cov0" title="0">{
                        client.Config.Logger.Printf("[ERROR] No client credentials were provided. Please set %s, %s and %s environment variables.\n", ZPA_CLIENT_ID, ZPA_CLIENT_SECRET, ZPA_CUSTOMER_ID)
                        return errors.New("no client credentials were provided")
                }</span>
                <span class="cov6" title="5">client.Config.Logger.Printf("[TRACE] Getting access token for %s=%s\n", ZPA_CLIENT_ID, client.Config.ClientID)
                data := url.Values{}
                data.Set("client_id", client.Config.ClientID)
                data.Set("client_secret", client.Config.ClientSecret)
                authUrl := client.Config.BaseURL.String() + "/signin"
                if client.Config.Cloud == "DEV" </span><span class="cov0" title="0">{
                        authUrl = devAuthUrl
                }</span>
                <span class="cov6" title="5">req, err := http.NewRequest("POST", authUrl, strings.NewReader(data.Encode()))
                if err != nil </span><span class="cov0" title="0">{
                        client.Config.Logger.Printf("[ERROR] Failed to signin the user %s=%s, err: %v\n", ZPA_CLIENT_ID, client.Config.ClientID, err)
                        return fmt.Errorf("[ERROR] Failed to signin the user %s=%s, err: %v", ZPA_CLIENT_ID, client.Config.ClientID, err)
                }</span>

                <span class="cov6" title="5">req.Header.Add("Content-Type", "application/x-www-form-urlencoded")
                if client.Config.UserAgent != "" </span><span class="cov6" title="5">{
                        req.Header.Add("User-Agent", client.Config.UserAgent)
                }</span>
                <span class="cov6" title="5">resp, err := client.Config.GetHTTPClient().Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        client.Config.Logger.Printf("[ERROR] Failed to signin the user %s=%s, err: %v\n", ZPA_CLIENT_ID, client.Config.ClientID, err)
                        return fmt.Errorf("[ERROR] Failed to signin the user %s=%s, err: %v", ZPA_CLIENT_ID, client.Config.ClientID, err)
                }</span>
                <span class="cov6" title="5">defer resp.Body.Close()
                respBody, err := io.ReadAll(resp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        client.Config.Logger.Printf("[ERROR] Failed to signin the user %s=%s, err: %v\n", ZPA_CLIENT_ID, client.Config.ClientID, err)
                        return fmt.Errorf("[ERROR] Failed to signin the user %s=%s, err: %v", ZPA_CLIENT_ID, client.Config.ClientID, err)
                }</span>
                <span class="cov6" title="5">if resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                        client.Config.Logger.Printf("[ERROR] Failed to signin the user %s=%s, got http status:%dn response body:%s\n", ZPA_CLIENT_ID, client.Config.ClientID, resp.StatusCode, respBody)
                        return fmt.Errorf("[ERROR] Failed to signin the user %s=%s, got http status:%d, response body:%s", ZPA_CLIENT_ID, client.Config.ClientID, resp.StatusCode, respBody)
                }</span>
                <span class="cov6" title="5">var a AuthToken
                err = json.Unmarshal(respBody, &amp;a)
                if err != nil </span><span class="cov0" title="0">{
                        client.Config.Logger.Printf("[ERROR] Failed to signin the user %s=%s, err: %v\n", ZPA_CLIENT_ID, client.Config.ClientID, err)
                        return fmt.Errorf("[ERROR] Failed to signin the user %s=%s, err: %v", ZPA_CLIENT_ID, client.Config.ClientID, err)
                }</span>
                // we need keep auth token for future http request
                <span class="cov6" title="5">client.Config.AuthToken = &amp;a</span>
        }
        <span class="cov6" title="5">return nil</span>
}

func (client *Client) newRequestDoCustom(method, urlStr string, options, body, v interface{}) (*http.Response, error) <span class="cov4" title="3">{
        err := client.authenticate()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="3">req, err := client.newRequest(method, urlStr, options, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="3">reqID := uuid.NewString()
        start := time.Now()
        logger.LogRequest(client.Config.Logger, req, reqID, nil, true)
        resp, err := client.do(req, v, start, reqID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov3" title="2">defer resp.Body.Close()

        if resp.StatusCode == http.StatusUnauthorized || resp.StatusCode == http.StatusForbidden </span><span class="cov0" title="0">{
                err := client.authenticate()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">resp, err := client.do(req, v, start, reqID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">resp.Body.Close()
                return resp, nil</span>
        }
        <span class="cov3" title="2">return resp, err</span>
}

func getMicrotenantIDFromBody(body interface{}) string <span class="cov6" title="6">{
        if body == nil </span><span class="cov5" title="4">{
                return ""
        }</span>

        <span class="cov3" title="2">d, err := json.Marshal(body)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov3" title="2">dataMap := map[string]interface{}{}
        err = json.Unmarshal(d, &amp;dataMap)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov3" title="2">if microTenantID, ok := dataMap["microtenantId"]; ok &amp;&amp; microTenantID != nil &amp;&amp; microTenantID != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("%v", microTenantID)
        }</span>
        <span class="cov3" title="2">return ""</span>
}

func getMicrotenantIDFromEnvVar(body interface{}) string <span class="cov6" title="6">{
        return os.Getenv("ZPA_MICROTENANT_ID")
}</span>

func (client *Client) injectMicrotentantID(body interface{}, q url.Values) url.Values <span class="cov6" title="6">{
        if q.Has("microtenantId") &amp;&amp; q.Get("microtenantId") != "" </span><span class="cov0" title="0">{
                return q
        }</span>

        <span class="cov6" title="6">microTenantID := getMicrotenantIDFromBody(body)
        if microTenantID != "" </span><span class="cov0" title="0">{
                q.Add("microtenantId", microTenantID)
                return q
        }</span>

        <span class="cov6" title="6">microTenantID = getMicrotenantIDFromEnvVar(body)
        if microTenantID != "" </span><span class="cov0" title="0">{
                q.Add("microtenantId", microTenantID)
                return q
        }</span>
        <span class="cov6" title="6">return q</span>
}

func (client *Client) getRequest(method, urlPath string, options, body interface{}) (*http.Request, error) <span class="cov6" title="6">{
        var buf io.ReadWriter
        if body != nil </span><span class="cov3" title="2">{
                buf = new(bytes.Buffer)
                err := json.NewEncoder(buf).Encode(body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Parse the URL path to separate the path from any query string
        <span class="cov6" title="6">parsedPath, err := url.Parse(urlPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Join the parsed path with the base URL
        <span class="cov6" title="6">u := client.Config.BaseURL.ResolveReference(parsedPath)

        // Handle query parameters from options and any additional logic
        if options == nil </span><span class="cov6" title="6">{
                options = struct{}{}
        }</span>
        <span class="cov6" title="6">q, err := query.Values(options)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Here, injectMicrotenantID or any similar function should ensure
        // it's not duplicating query parameters that may already be present in urlPath
        <span class="cov6" title="6">q = client.injectMicrotentantID(body, q)

        // Merge query params from urlPath and options. Avoid overwriting any existing params.
        for key, values := range parsedPath.Query() </span><span class="cov0" title="0">{
                for _, value := range values </span><span class="cov0" title="0">{
                        q.Add(key, value)
                }</span>
        }

        // Set the final query string
        <span class="cov6" title="6">u.RawQuery = q.Encode()

        req, err := http.NewRequest(method, u.String(), buf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="6">return req, nil</span>
}

// Generating the Http request
func (client *Client) newRequest(method, urlPath string, options, body interface{}) (*http.Request, error) <span class="cov4" title="3">{
        if client.Config.AuthToken == nil || client.Config.AuthToken.AccessToken == "" </span><span class="cov0" title="0">{
                client.Config.Logger.Printf("[ERROR] Failed to signin the user %s=%s\n", ZPA_CLIENT_ID, client.Config.ClientID)
                return nil, fmt.Errorf("failed to signin the user %s=%s", ZPA_CLIENT_ID, client.Config.ClientID)
        }</span>
        <span class="cov4" title="3">req, err := client.getRequest(method, urlPath, options, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="3">req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", client.Config.AuthToken.AccessToken))
        req.Header.Add("Content-Type", "application/json")

        if client.Config.UserAgent != "" </span><span class="cov4" title="3">{
                req.Header.Add("User-Agent", client.Config.UserAgent)
        }</span>

        <span class="cov4" title="3">return req, nil</span>
}

func (client *Client) do(req *http.Request, v interface{}, start time.Time, reqID string) (*http.Response, error) <span class="cov4" title="3">{
        resp, err := client.Config.GetHTTPClient().Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="3">respData, err := io.ReadAll(resp.Body)
        if err == nil </span><span class="cov4" title="3">{
                resp.Body = io.NopCloser(bytes.NewBuffer(respData))
        }</span>
        <span class="cov4" title="3">if err := checkErrorInResponse(resp, respData); err != nil </span><span class="cov1" title="1">{
                return resp, err
        }</span>

        <span class="cov3" title="2">if v != nil </span><span class="cov3" title="2">{
                if err := decodeJSON(respData, v); err != nil </span><span class="cov0" title="0">{
                        return resp, err
                }</span>
        }
        <span class="cov3" title="2">logger.LogResponse(client.Config.Logger, resp, start, reqID)
        unescapeHTML(v)
        return resp, nil</span>
}

func decodeJSON(respData []byte, v interface{}) error <span class="cov3" title="2">{
        return json.NewDecoder(bytes.NewBuffer(respData)).Decode(&amp;v)
}</span>

func unescapeHTML(entity interface{}) <span class="cov3" title="2">{
        if entity == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov3" title="2">data, err := json.Marshal(entity)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov3" title="2">var mapData map[string]interface{}
        err = json.Unmarshal(data, &amp;mapData)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov3" title="2">for _, field := range []string{"name", "description"} </span><span class="cov5" title="4">{
                if v, ok := mapData[field]; ok &amp;&amp; v != nil </span><span class="cov5" title="4">{
                        str, ok := v.(string)
                        if ok </span><span class="cov5" title="4">{
                                mapData[field] = html.UnescapeString(html.UnescapeString(str))
                        }</span>
                }
        }
        <span class="cov3" title="2">data, err = json.Marshal(mapData)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov3" title="2">_ = json.Unmarshal(data, entity)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package zpa

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "math"
        "net/http"
        "net/url"
        "os"
        "os/user"
        "path/filepath"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/hashicorp/go-retryablehttp"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
        logger "github.com/zscaler/zscaler-sdk-go/v2/logger"
        rl "github.com/zscaler/zscaler-sdk-go/v2/ratelimiter"
)

const (
        defaultBaseURL           = "https://config.private.zscaler.com"
        betaBaseURL              = "https://config.zpabeta.net"
        zpaTwoBaseUrl            = "https://config.zpatwo.net"
        govBaseURL               = "https://config.zpagov.net"
        govUsBaseURL             = "https://config.zpagov.us"
        previewBaseUrl           = "https://config.zpapreview.net"
        devBaseUrl               = "https://public-api.dev.zpath.net"
        devAuthUrl               = "https://authn1.dev.zpath.net/authn/v1/oauth/token?grant_type=CLIENT_CREDENTIALS"
        qaBaseUrl                = "https://config.qa.zpath.net"
        qa2BaseUrl               = "https://pdx2-zpa-config.qa2.zpath.net"
        defaultTimeout           = 240 * time.Second
        loggerPrefix             = "zpa-logger: "
        ZPA_CLIENT_ID            = "ZPA_CLIENT_ID"
        ZPA_CLIENT_SECRET        = "ZPA_CLIENT_SECRET"
        ZPA_CUSTOMER_ID          = "ZPA_CUSTOMER_ID"
        ZPA_CLOUD                = "ZPA_CLOUD"
        configPath        string = ".zpa/credentials.json"
)

var defaultBackoffConf = &amp;BackoffConfig{
        Enabled:             true,
        MaxNumOfRetries:     100,
        RetryWaitMaxSeconds: 10,
        RetryWaitMinSeconds: 2,
}

type BackoffConfig struct {
        Enabled             bool // Set to true to enable backoff and retry mechanism
        RetryWaitMinSeconds int  // Minimum time to wait
        RetryWaitMaxSeconds int  // Maximum time to wait
        MaxNumOfRetries     int  // Maximum number of retries
}

type AuthToken struct {
        TokenType   string `json:"token_type"`
        AccessToken string `json:"access_token"`
}

type CredentialsConfig struct {
        ClientID     string `json:"zpa_client_id"`
        ClientSecret string `json:"zpa_client_secret"`
        CustomerID   string `json:"zpa_customer_id"`
        ZpaCloud     string `json:"zpa_cloud"`
}

// Config contains all the configuration data for the API client
type Config struct {
        BaseURL     *url.URL
        httpClient  *http.Client
        rateLimiter *rl.RateLimiter
        // The logger writer interface to write logging messages to. Defaults to standard out.
        Logger logger.Logger
        // Credentials for basic authentication.
        ClientID, ClientSecret, CustomerID, Cloud string
        // Backoff config
        BackoffConf *BackoffConfig
        AuthToken   *AuthToken
        sync.Mutex
        UserAgent        string
        cacheEnabled     bool
        freshCache       bool
        cacheTtl         time.Duration
        cacheCleanwindow time.Duration
        cacheMaxSizeMB   int
}

/*
NewConfig returns a default configuration for the client.
By default it will try to read the access and te secret from the environment variable.
*/
// Need to implement exponential back off to comply with the API rate limit. https://help.zscaler.com/zpa/about-rate-limiting
// 20 times in a 10 second interval for a GET call.
// 10 times in a 10 second interval for any POST/PUT/DELETE call.
// TODO Add healthCheck method to NewConfig
func NewConfig(clientID, clientSecret, customerID, cloud, userAgent string) (*Config, error) <span class="cov10" title="15">{
        var logger logger.Logger = logger.GetDefaultLogger(loggerPrefix)
        // if creds not provided in TF config, try loading from env vars
        if clientID == "" || clientSecret == "" || customerID == "" || cloud == "" || userAgent == "" </span><span class="cov8" title="10">{
                clientID = os.Getenv(ZPA_CLIENT_ID)
                clientSecret = os.Getenv(ZPA_CLIENT_SECRET)
                customerID = os.Getenv(ZPA_CUSTOMER_ID)
                cloud = os.Getenv(ZPA_CLOUD)
        }</span>
        // last resort to configuration file:
        <span class="cov10" title="15">if clientID == "" || clientSecret == "" || customerID == "" </span><span class="cov0" title="0">{
                creds, err := loadCredentialsFromConfig(logger)
                if err != nil || creds == nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">clientID = creds.ClientID
                clientSecret = creds.ClientSecret
                customerID = creds.CustomerID
                cloud = creds.ZpaCloud</span>
        }
        <span class="cov10" title="15">rawUrl := defaultBaseURL
        if cloud == "" </span><span class="cov1" title="1">{
                cloud = os.Getenv(ZPA_CLOUD)
        }</span> else<span class="cov9" title="14"> if cloud != "" </span><span class="cov9" title="14">{
                rawUrl = cloud
        }</span>
        <span class="cov10" title="15">if strings.EqualFold(cloud, "PRODUCTION") </span><span class="cov1" title="1">{
                rawUrl = defaultBaseURL
        }</span> else<span class="cov9" title="14"> if strings.EqualFold(cloud, "ZPATWO") </span><span class="cov1" title="1">{
                rawUrl = zpaTwoBaseUrl
        }</span> else<span class="cov9" title="13"> if strings.EqualFold(cloud, "BETA") </span><span class="cov1" title="1">{
                rawUrl = betaBaseURL
        }</span> else<span class="cov9" title="12"> if strings.EqualFold(cloud, "GOV") </span><span class="cov1" title="1">{
                rawUrl = govBaseURL
        }</span> else<span class="cov8" title="11"> if strings.EqualFold(cloud, "GOVUS") </span><span class="cov1" title="1">{
                rawUrl = govUsBaseURL
        }</span> else<span class="cov8" title="10"> if strings.EqualFold(cloud, "PREVIEW") </span><span class="cov1" title="1">{
                rawUrl = previewBaseUrl
        }</span> else<span class="cov8" title="9"> if strings.EqualFold(cloud, "DEV") </span><span class="cov0" title="0">{
                rawUrl = devBaseUrl
        }</span> else<span class="cov8" title="9"> if strings.EqualFold(cloud, "QA") </span><span class="cov1" title="1">{
                rawUrl = qaBaseUrl
        }</span> else<span class="cov7" title="8"> if strings.EqualFold(cloud, "QA2") </span><span class="cov1" title="1">{
                rawUrl = qa2BaseUrl
        }</span>

        <span class="cov10" title="15">baseURL, err := url.Parse(rawUrl)
        if err != nil </span><span class="cov0" title="0">{
                logger.Printf("[ERROR] error occurred while configuring the client: %v", err)
        }</span>
        <span class="cov10" title="15">cacheDisabled, _ := strconv.ParseBool(os.Getenv("ZSCALER_SDK_CACHE_DISABLED"))
        return &amp;Config{
                BaseURL:          baseURL,
                Logger:           logger,
                httpClient:       nil,
                ClientID:         clientID,
                ClientSecret:     clientSecret,
                CustomerID:       customerID,
                Cloud:            cloud,
                BackoffConf:      defaultBackoffConf,
                UserAgent:        userAgent,
                rateLimiter:      rl.NewRateLimiter(20, 10, 10, 10),
                cacheEnabled:     !cacheDisabled,
                cacheTtl:         time.Minute * 10,
                cacheCleanwindow: time.Minute * 8,
                cacheMaxSizeMB:   0,
        }, err</span>
}

func (c *Config) WithCache(cache bool) <span class="cov0" title="0">{
        c.cacheEnabled = cache
}</span>

func (c *Config) WithCacheTtl(i time.Duration) <span class="cov0" title="0">{
        c.cacheTtl = i
}</span>

func (c *Config) WithCacheCleanWindow(i time.Duration) <span class="cov0" title="0">{
        c.cacheCleanwindow = i
}</span>

func (c *Config) SetBackoffConfig(backoffConf BackoffConfig) <span class="cov0" title="0">{
        c.BackoffConf = &amp;backoffConf
}</span>

// loadCredentialsFromConfig Returns the credentials found in a config file
func loadCredentialsFromConfig(logger logger.Logger) (*CredentialsConfig, error) <span class="cov0" title="0">{
        usr, _ := user.Current()
        dir := usr.HomeDir
        path := filepath.Join(dir, configPath)
        logger.Printf("[INFO]Loading configuration file at:%s", path)
        file, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("Could not open credentials file, needs to contain one json object with keys: zpa_client_id, zpa_client_secret, zpa_customer_id, and zpa_cloud. " + err.Error())
        }</span>
        <span class="cov0" title="0">configBytes, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var config CredentialsConfig
        err = json.Unmarshal(configBytes, &amp;config)
        if err != nil || config.ClientID == "" || config.ClientSecret == "" || config.CustomerID == "" || config.ZpaCloud == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not parse credentials file, needs to contain one json object with keys: zpa_client_id, zpa_client_secret, zpa_customer_id, and zpa_cloud. error: %v", err)
        }</span>
        <span class="cov0" title="0">return &amp;config, nil</span>
}

func (c *Config) GetHTTPClient() *http.Client <span class="cov7" title="8">{
        if c.httpClient == nil </span><span class="cov5" title="4">{
                if c.BackoffConf != nil &amp;&amp; c.BackoffConf.Enabled </span><span class="cov5" title="4">{
                        retryableClient := retryablehttp.NewClient()
                        retryableClient.Logger = c.Logger
                        retryableClient.RetryWaitMin = time.Second * time.Duration(c.BackoffConf.RetryWaitMinSeconds)
                        retryableClient.Backoff = func(min, max time.Duration, attemptNum int, resp *http.Response) time.Duration </span><span class="cov0" title="0">{
                                if resp != nil </span><span class="cov0" title="0">{
                                        if resp.StatusCode == http.StatusTooManyRequests || resp.StatusCode == http.StatusServiceUnavailable </span><span class="cov0" title="0">{
                                                if s := resp.Header.Get("Retry-After"); s != "" </span><span class="cov0" title="0">{
                                                        if sleep, err := strconv.ParseInt(s, 10, 64); err == nil </span><span class="cov0" title="0">{
                                                                return time.Second * time.Duration(sleep)
                                                        }</span> else<span class="cov0" title="0"> {
                                                                dur, err := time.ParseDuration(s)
                                                                if err == nil </span><span class="cov0" title="0">{
                                                                        return dur
                                                                }</span>
                                                        }
                                                }
                                        }
                                        <span class="cov0" title="0">if resp.Request != nil </span><span class="cov0" title="0">{
                                                wait, duration := c.rateLimiter.Wait(resp.Request.Method)
                                                if wait </span><span class="cov0" title="0">{
                                                        c.Logger.Printf("[INFO] rate limiter wait duration:%s\n", duration.String())
                                                }</span> else<span class="cov0" title="0"> {
                                                        return 0
                                                }</span>
                                        }
                                }
                                // default to exp backoff
                                <span class="cov0" title="0">mult := math.Pow(2, float64(attemptNum)) * float64(min)
                                sleep := time.Duration(mult)
                                if float64(sleep) != mult || sleep &gt; max </span><span class="cov0" title="0">{
                                        sleep = max
                                }</span>
                                <span class="cov0" title="0">return sleep</span>
                        }
                        <span class="cov5" title="4">retryableClient.RetryWaitMax = time.Second * time.Duration(c.BackoffConf.RetryWaitMaxSeconds)
                        retryableClient.RetryMax = c.BackoffConf.MaxNumOfRetries
                        retryableClient.HTTPClient.Transport = logging.NewSubsystemLoggingHTTPTransport("gozscaler", retryableClient.HTTPClient.Transport)
                        retryableClient.CheckRetry = checkRetry
                        retryableClient.HTTPClient.Timeout = defaultTimeout
                        c.httpClient = retryableClient.StandardClient()</span>
                } else<span class="cov0" title="0"> {
                        c.httpClient = &amp;http.Client{
                                Timeout: defaultTimeout,
                        }
                }</span>
        }
        <span class="cov7" title="8">return c.httpClient</span>
}

func containsInt(codes []int, code int) bool <span class="cov7" title="8">{
        for _, a := range codes </span><span class="cov7" title="8">{
                if a == code </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov7" title="8">return false</span>
}

// getRetryOnStatusCodes return a list of http status codes we want to apply retry on.
// return empty slice to enable retry on all connection &amp; server errors.
// or return []int{429}  to retry on only TooManyRequests error
func getRetryOnStatusCodes() []int <span class="cov7" title="8">{
        return []int{http.StatusTooManyRequests}
}</span>

// Used to make http client retry on provided list of response status codes
func checkRetry(ctx context.Context, resp *http.Response, err error) (bool, error) <span class="cov7" title="8">{
        // do not retry on context.Canceled or context.DeadlineExceeded
        if ctx.Err() != nil </span><span class="cov0" title="0">{
                return false, ctx.Err()
        }</span>
        <span class="cov7" title="8">if resp != nil &amp;&amp; containsInt(getRetryOnStatusCodes(), resp.StatusCode) </span><span class="cov0" title="0">{
                return true, nil
        }</span>
        <span class="cov7" title="8">if resp != nil &amp;&amp; resp.StatusCode == http.StatusBadRequest </span><span class="cov1" title="1">{
                respMap := map[string]string{}
                data, err := io.ReadAll(resp.Body)
                resp.Body = io.NopCloser(bytes.NewBuffer(data))
                if err == nil </span><span class="cov1" title="1">{
                        _ = json.Unmarshal(data, &amp;respMap)
                        if errorID, ok := respMap["id"]; ok &amp;&amp; (errorID == "non.restricted.entity.authorization.failed" || errorID == "bad.request") </span><span class="cov0" title="0">{
                                return true, nil
                        }</span>
                }
                // Implemented to handle upstream restrictions on simultaneous requests when dealing with CRUD operations, related to ZPA Access policy rule order
                // ET-53585: https://jira.corp.zscaler.com/browse/ET-53585
                // ET-48860: https://confluence.corp.zscaler.com/display/ET/ET-48860+incorrect+rules+order
                <span class="cov1" title="1">if err == nil </span><span class="cov1" title="1">{
                        _ = json.Unmarshal(data, &amp;respMap)
                        if errorID, ok := respMap["id"]; ok &amp;&amp; (errorID == "db.simultaneous.request" || errorID == "bad.request") </span><span class="cov0" title="0">{
                                return true, nil
                        }</span>
                }
        }
        <span class="cov7" title="8">return retryablehttp.DefaultRetryPolicy(ctx, resp, err)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package zpa

import (
        "encoding/json"
        "fmt"
        "net/http"
)

type ErrorResponse struct {
        Response *http.Response
        Message  string
}

func (r *ErrorResponse) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("FAILED: %v, %v, %d, %v, %v", r.Response.Request.Method, r.Response.Request.URL, r.Response.StatusCode, r.Response.Status, r.Message)
}</span>

func checkErrorInResponse(res *http.Response, respData []byte) error <span class="cov10" title="3">{
        if c := res.StatusCode; c &gt;= 200 &amp;&amp; c &lt;= 299 </span><span class="cov6" title="2">{
                return nil
        }</span>
        <span class="cov1" title="1">errorResponse := &amp;ErrorResponse{Response: res}
        if len(respData) &gt; 0 </span><span class="cov1" title="1">{
                errorResponse.Message = string(respData)
        }</span>
        <span class="cov1" title="1">return errorResponse</span>
}

type apiErrorResponse struct {
        ID string `json:"id"`
}

// isResourceNotFoundError returns true on missing object error (400).
func (r ErrorResponse) isResourceNotFoundError() bool <span class="cov0" title="0">{
        resp := apiErrorResponse{}
        err := json.Unmarshal([]byte(r.Message), &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return resp.ID == "resource.not.found"</span>
}

// IsObjectNotFound returns true on missing object error (404 &amp; 400 with response  "id": "resource.not.found",).
func (r ErrorResponse) IsObjectNotFound() bool <span class="cov0" title="0">{
        return r.Response.StatusCode == 404 || r.Response.StatusCode == 400 &amp;&amp; r.isResourceNotFoundError()
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package appconnectorcontroller

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client        *zpa.Client
        microTenantID *string
}

func New(c *zpa.Client) *Service <span class="cov0" title="0">{
        return &amp;Service{Client: c}
}</span>

func (service *Service) WithMicroTenant(microTenantID string) *Service <span class="cov0" title="0">{
        var mid *string
        if microTenantID != "" </span><span class="cov0" title="0">{
                mid_ := microTenantID
                mid = &amp;mid_
        }</span>
        <span class="cov0" title="0">return &amp;Service{
                Client:        service.Client,
                microTenantID: mid,
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package appconnectorcontroller

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfig           = "/mgmtconfig/v1/admin/customers/"
        appConnectorEndpoint = "/connector"
        scheduleEndpoint     = "/assistantSchedule"
)

type AppConnector struct {
        ApplicationStartTime             string                 `json:"applicationStartTime,omitempty"`
        AppConnectorGroupID              string                 `json:"appConnectorGroupId,omitempty"`
        AppConnectorGroupName            string                 `json:"appConnectorGroupName,omitempty"`
        ControlChannelStatus             string                 `json:"controlChannelStatus,omitempty"`
        CreationTime                     string                 `json:"creationTime,omitempty"`
        CtrlBrokerName                   string                 `json:"ctrlBrokerName,omitempty"`
        CurrentVersion                   string                 `json:"currentVersion,omitempty"`
        Description                      string                 `json:"description,omitempty"`
        Enabled                          bool                   `json:"enabled,omitempty"`
        ExpectedUpgradeTime              string                 `json:"expectedUpgradeTime,omitempty"`
        ExpectedVersion                  string                 `json:"expectedVersion,omitempty"`
        Fingerprint                      string                 `json:"fingerprint,omitempty"`
        ID                               string                 `json:"id,omitempty"`
        IPACL                            string                 `json:"ipAcl,omitempty"`
        IssuedCertID                     string                 `json:"issuedCertId,omitempty"`
        LastBrokerConnectTime            string                 `json:"lastBrokerConnectTime,omitempty"`
        LastBrokerConnectTimeDuration    string                 `json:"lastBrokerConnectTimeDuration,omitempty"`
        LastBrokerDisconnectTime         string                 `json:"lastBrokerDisconnectTime,omitempty"`
        LastBrokerDisconnectTimeDuration string                 `json:"lastBrokerDisconnectTimeDuration,omitempty"`
        LastUpgradeTime                  string                 `json:"lastUpgradeTime,omitempty"`
        Latitude                         string                 `json:"latitude,omitempty"`
        Location                         string                 `json:"location,omitempty"`
        Longitude                        string                 `json:"longitude,omitempty"`
        ModifiedBy                       string                 `json:"modifiedBy,omitempty"`
        ModifiedTime                     string                 `json:"modifiedTime,omitempty"`
        Name                             string                 `json:"name,omitempty"`
        ProvisioningKeyID                string                 `json:"provisioningKeyId"`
        ProvisioningKeyName              string                 `json:"provisioningKeyName"`
        Platform                         string                 `json:"platform,omitempty"`
        PreviousVersion                  string                 `json:"previousVersion,omitempty"`
        PrivateIP                        string                 `json:"privateIp,omitempty"`
        PublicIP                         string                 `json:"publicIp,omitempty"`
        SargeVersion                     string                 `json:"sargeVersion,omitempty"`
        EnrollmentCert                   map[string]interface{} `json:"enrollmentCert,omitempty"`
        UpgradeAttempt                   string                 `json:"upgradeAttempt,omitempty"`
        UpgradeStatus                    string                 `json:"upgradeStatus,omitempty"`
        MicroTenantID                    string                 `json:"microtenantId,omitempty"`
        MicroTenantName                  string                 `json:"microtenantName,omitempty"`
}

type AssistantSchedule struct {
        // The unique identifier for the App Connector auto deletion configuration for a customer. This field is only required for the PUT request to update the frequency of the App Connector Settings.
        ID string `json:"id,omitempty"`

        // The unique identifier of the ZPA tenant.
        CustomerID string `json:"customerId"`

        // Indicates if the App Connectors are included for deletion if they are in a disconnected state based on frequencyInterval and frequency values.
        DeleteDisabled bool `json:"deleteDisabled"`

        // Indicates if the setting for deleting App Connectors is enabled or disabled.
        Enabled bool `json:"enabled"`

        // The scheduled frequency at which the disconnected App Connectors are deleted.
        Frequency string `json:"frequency"`

        // The interval for the configured frequency value. The minimum supported value is 5.
        FrequencyInterval string `json:"frequencyInterval"`
}

// This function search the App Connector by ID
func (service *Service) Get(appConnectorID string) (*AppConnector, *http.Response, error) <span class="cov0" title="0">{
        v := new(AppConnector)
        path := fmt.Sprintf("%v/%v", mgmtConfig+service.Client.Config.CustomerID+appConnectorEndpoint, appConnectorID)
        resp, err := service.Client.NewRequestDo("GET", path, common.Filter{MicroTenantID: service.microTenantID}, nil, v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return v, resp, nil</span>
}

// This function search the App Connector by Name
func (service *Service) GetByName(appConnectorName string) (*AppConnector, *http.Response, error) <span class="cov0" title="0">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + appConnectorEndpoint
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[AppConnector](service.Client, relativeURL, common.Filter{Search: appConnectorName, MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">for _, app := range list </span><span class="cov0" title="0">{
                if strings.EqualFold(app.Name, appConnectorName) </span><span class="cov0" title="0">{
                        return &amp;app, resp, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, resp, fmt.Errorf("no app connector named '%s' was found", appConnectorName)</span>
}

func (service *Service) GetAll() ([]AppConnector, *http.Response, error) <span class="cov0" title="0">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + appConnectorEndpoint
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[AppConnector](service.Client, relativeURL, common.Filter{MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return list, resp, nil</span>
}

type BulkDeleteRequest struct {
        IDs []string `json:"ids"`
}

// Update Updates the App Connector details for the specified ID.
func (service *Service) Update(appConnectorID string, appConnector AppConnector) (*AppConnector, *http.Response, error) <span class="cov0" title="0">{
        path := fmt.Sprintf("%v/%v", mgmtConfig+service.Client.Config.CustomerID+appConnectorEndpoint, appConnectorID)
        _, err := service.Client.NewRequestDo("PUT", path, common.Filter{MicroTenantID: service.microTenantID}, appConnector, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">resource, resp, err := service.Get(appConnectorID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return resource, resp, nil</span>
}

// Delete Deletes the App Connector for the specified ID.
func (service *Service) Delete(appConnectorID string) (*http.Response, error) <span class="cov0" title="0">{
        path := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+appConnectorEndpoint, appConnectorID)
        resp, err := service.Client.NewRequestDo("DELETE", path, common.Filter{MicroTenantID: service.microTenantID}, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resp, err</span>
}

// BulkDelete Bulk deletes the App Connectors.
func (service *Service) BulkDelete(appConnectorIDs []string) (*http.Response, error) <span class="cov0" title="0">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + appConnectorEndpoint + "/bulkDelete"
        resp, err := service.Client.NewRequestDo("POST", relativeURL, common.Filter{MicroTenantID: service.microTenantID}, BulkDeleteRequest{IDs: appConnectorIDs}, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}

// Get a Configured App Connector schedule frequency.
func (service *Service) GetSchedule() (*AssistantSchedule, *http.Response, error) <span class="cov0" title="0">{
        v := new(AssistantSchedule)
        path := fmt.Sprintf("%v", mgmtConfig+service.Client.Config.CustomerID+scheduleEndpoint)
        resp, err := service.Client.NewRequestDo("GET", path, nil, nil, v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return v, resp, nil</span>
}

// Configure a App Connector schedule frequency to delete the in active connectors with configured frequency.
func (service *Service) CreateSchedule(assistantSchedule AssistantSchedule) (*AssistantSchedule, *http.Response, error) <span class="cov0" title="0">{
        v := new(AssistantSchedule)
        resp, err := service.Client.NewRequestDo("POST", mgmtConfig+service.Client.Config.CustomerID+scheduleEndpoint, nil, assistantSchedule, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">return v, resp, nil</span>
}

func (service *Service) UpdateSchedule(schedulerID string, assistantSchedule *AssistantSchedule) (*http.Response, error) <span class="cov0" title="0">{
        // Validate FrequencyInterval
        validIntervals := map[string]bool{"5": true, "7": true, "14": true, "30": true, "60": true, "90": true}
        if _, valid := validIntervals[assistantSchedule.FrequencyInterval]; !valid </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid FrequencyInterval: %s", assistantSchedule.FrequencyInterval)
        }</span>

        <span class="cov0" title="0">relativeURL := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+scheduleEndpoint, schedulerID)
        resp, err := service.Client.NewRequestDo("PUT", relativeURL, nil, assistantSchedule, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package appconnectorgroup

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client        *zpa.Client
        microTenantID *string
}

func New(c *zpa.Client) *Service <span class="cov10" title="5">{
        return &amp;Service{Client: c}
}</span>

func (service *Service) WithMicroTenant(microTenantID string) *Service <span class="cov0" title="0">{
        var mid *string
        if microTenantID != "" </span><span class="cov0" title="0">{
                mid_ := microTenantID
                mid = &amp;mid_
        }</span>
        <span class="cov0" title="0">return &amp;Service{
                Client:        service.Client,
                microTenantID: mid,
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package appconnectorgroup

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfig                = "/mgmtconfig/v1/admin/customers/"
        appConnectorGroupEndpoint = "/appConnectorGroup"
)

type AppConnectorGroup struct {
        CityCountry                   string           `json:"cityCountry"`
        CountryCode                   string           `json:"countryCode,omitempty"`
        CreationTime                  string           `json:"creationTime,omitempty"`
        Description                   string           `json:"description,omitempty"`
        DNSQueryType                  string           `json:"dnsQueryType,omitempty"`
        Enabled                       bool             `json:"enabled"`
        GeoLocationID                 string           `json:"geoLocationId,omitempty"`
        ID                            string           `json:"id,omitempty"`
        Latitude                      string           `json:"latitude,omitempty"`
        Location                      string           `json:"location,omitempty"`
        Longitude                     string           `json:"longitude,omitempty"`
        ModifiedBy                    string           `json:"modifiedBy,omitempty"`
        ModifiedTime                  string           `json:"modifiedTime,omitempty"`
        Name                          string           `json:"name,omitempty"`
        OverrideVersionProfile        bool             `json:"overrideVersionProfile"`
        PRAEnabled                    bool             `json:"praEnabled"`
        WAFDisabled                   bool             `json:"wafDisabled"`
        UpgradeDay                    string           `json:"upgradeDay,omitempty"`
        UpgradeTimeInSecs             string           `json:"upgradeTimeInSecs,omitempty"`
        VersionProfileID              string           `json:"versionProfileId,omitempty"`
        VersionProfileName            string           `json:"versionProfileName,omitempty"`
        VersionProfileVisibilityScope string           `json:"versionProfileVisibilityScope,omitempty"`
        TCPQuickAckApp                bool             `json:"tcpQuickAckApp"`
        TCPQuickAckAssistant          bool             `json:"tcpQuickAckAssistant"`
        UseInDrMode                   bool             `json:"useInDrMode"`
        TCPQuickAckReadAssistant      bool             `json:"tcpQuickAckReadAssistant"`
        LSSAppConnectorGroup          bool             `json:"lssAppConnectorGroup"`
        MicroTenantID                 string           `json:"microtenantId,omitempty"`
        MicroTenantName               string           `json:"microtenantName,omitempty"`
        AppServerGroup                []AppServerGroup `json:"serverGroups,omitempty"`
        Connectors                    []Connector      `json:"connectors,omitempty"`
}

type Connector struct {
        ApplicationStartTime             string                 `json:"applicationStartTime,omitempty"`
        AppConnectorGroupID              string                 `json:"appConnectorGroupId,omitempty"`
        AppConnectorGroupName            string                 `json:"appConnectorGroupName,omitempty"`
        ControlChannelStatus             string                 `json:"controlChannelStatus,omitempty"`
        CreationTime                     string                 `json:"creationTime,omitempty"`
        CtrlBrokerName                   string                 `json:"ctrlBrokerName,omitempty"`
        CurrentVersion                   string                 `json:"currentVersion,omitempty"`
        Description                      string                 `json:"description,omitempty"`
        Enabled                          bool                   `json:"enabled,omitempty"`
        ExpectedUpgradeTime              string                 `json:"expectedUpgradeTime,omitempty"`
        ExpectedVersion                  string                 `json:"expectedVersion,omitempty"`
        Fingerprint                      string                 `json:"fingerprint,omitempty"`
        ID                               string                 `json:"id,omitempty"`
        IPACL                            string                 `json:"ipAcl,omitempty"`
        IssuedCertID                     string                 `json:"issuedCertId,omitempty"`
        LastBrokerConnectTime            string                 `json:"lastBrokerConnectTime,omitempty"`
        LastBrokerConnectTimeDuration    string                 `json:"lastBrokerConnectTimeDuration,omitempty"`
        LastBrokerDisconnectTime         string                 `json:"lastBrokerDisconnectTime,omitempty"`
        LastBrokerDisconnectTimeDuration string                 `json:"lastBrokerDisconnectTimeDuration,omitempty"`
        LastUpgradeTime                  string                 `json:"lastUpgradeTime,omitempty"`
        Latitude                         string                 `json:"latitude,omitempty"`
        Location                         string                 `json:"location,omitempty"`
        Longitude                        string                 `json:"longitude,omitempty"`
        ModifiedBy                       string                 `json:"modifiedBy,omitempty"`
        ModifiedTime                     string                 `json:"modifiedTime,omitempty"`
        Name                             string                 `json:"name,omitempty"`
        ProvisioningKeyID                string                 `json:"provisioningKeyId"`
        ProvisioningKeyName              string                 `json:"provisioningKeyName"`
        Platform                         string                 `json:"platform,omitempty"`
        PreviousVersion                  string                 `json:"previousVersion,omitempty"`
        PrivateIP                        string                 `json:"privateIp,omitempty"`
        PublicIP                         string                 `json:"publicIp,omitempty"`
        SargeVersion                     string                 `json:"sargeVersion,omitempty"`
        EnrollmentCert                   map[string]interface{} `json:"enrollmentCert,omitempty"`
        UpgradeAttempt                   string                 `json:"upgradeAttempt,omitempty"`
        UpgradeStatus                    string                 `json:"upgradeStatus,omitempty"`
}

type AppServerGroup struct {
        ConfigSpace      string `json:"configSpace,omitempty"`
        CreationTime     string `json:"creationTime,omitempty"`
        Description      string `json:"description,omitempty"`
        Enabled          bool   `json:"enabled,omitempty"`
        ID               string `json:"id,omitempty"`
        DynamicDiscovery bool   `json:"dynamicDiscovery,omitempty"`
        ModifiedBy       string `json:"modifiedBy,omitempty"`
        ModifiedTime     string `json:"modifiedTime,omitempty"`
        Name             string `json:"name,omitempty"`
}

func (service *Service) Get(appConnectorGroupID string) (*AppConnectorGroup, *http.Response, error) <span class="cov10" title="2">{
        v := new(AppConnectorGroup)
        path := fmt.Sprintf("%v/%v", mgmtConfig+service.Client.Config.CustomerID+appConnectorGroupEndpoint, appConnectorGroupID)
        resp, err := service.Client.NewRequestDo("GET", path, common.Filter{MicroTenantID: service.microTenantID}, nil, v)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return v, resp, nil</span>
}

func (service *Service) GetByName(appConnectorGroupName string) (*AppConnectorGroup, *http.Response, error) <span class="cov10" title="2">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + appConnectorGroupEndpoint
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[AppConnectorGroup](service.Client, relativeURL, common.Filter{Search: appConnectorGroupName, MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov10" title="2">for _, app := range list </span><span class="cov1" title="1">{
                if strings.EqualFold(app.Name, appConnectorGroupName) </span><span class="cov1" title="1">{
                        return &amp;app, resp, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, resp, fmt.Errorf("no app connector group named '%s' was found", appConnectorGroupName)</span>
}

func (service *Service) Create(appConnectorGroup AppConnectorGroup) (*AppConnectorGroup, *http.Response, error) <span class="cov1" title="1">{
        v := new(AppConnectorGroup)
        resp, err := service.Client.NewRequestDo("POST", mgmtConfig+service.Client.Config.CustomerID+appConnectorGroupEndpoint, common.Filter{MicroTenantID: service.microTenantID}, appConnectorGroup, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return v, resp, nil</span>
}

func (service *Service) Update(appConnectorGroupID string, appConnectorGroup *AppConnectorGroup) (*http.Response, error) <span class="cov10" title="2">{
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+appConnectorGroupEndpoint, appConnectorGroupID)
        resp, err := service.Client.NewRequestDo("PUT", relativeURL, common.Filter{MicroTenantID: service.microTenantID}, appConnectorGroup, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp, err</span>
}

func (service *Service) Delete(appConnectorGroupID string) (*http.Response, error) <span class="cov10" title="2">{
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+appConnectorGroupEndpoint, appConnectorGroupID)
        resp, err := service.Client.NewRequestDo("DELETE", relativeURL, common.Filter{MicroTenantID: service.microTenantID}, nil, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp, nil</span>
}

func (service *Service) GetAll() ([]AppConnectorGroup, *http.Response, error) <span class="cov1" title="1">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + appConnectorGroupEndpoint
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[AppConnectorGroup](service.Client, relativeURL, common.Filter{MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return list, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package applicationsegment

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client        *zpa.Client
        microTenantID *string
}

func New(c *zpa.Client) *Service <span class="cov10" title="5">{
        return &amp;Service{Client: c}
}</span>

func (service *Service) WithMicroTenant(microTenantID string) *Service <span class="cov0" title="0">{
        var mid *string
        if microTenantID != "" </span><span class="cov0" title="0">{
                mid_ := microTenantID
                mid = &amp;mid_
        }</span>
        <span class="cov0" title="0">return &amp;Service{
                Client:        service.Client,
                microTenantID: mid,
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package applicationsegment

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/applicationsegmentpra"
        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/browseraccess"
        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfig         = "/mgmtconfig/v1/admin/customers/"
        appSegmentEndpoint = "/application"
)

type ApplicationSegmentResource struct {
        ID                        string                              `json:"id,omitempty"`
        DomainNames               []string                            `json:"domainNames,omitempty"`
        Name                      string                              `json:"name,omitempty"`
        Description               string                              `json:"description,omitempty"`
        Enabled                   bool                                `json:"enabled"`
        ADPEnabled                bool                                `json:"adpEnabled"`
        PassiveHealthEnabled      bool                                `json:"passiveHealthEnabled"`
        DoubleEncrypt             bool                                `json:"doubleEncrypt"`
        ConfigSpace               string                              `json:"configSpace,omitempty"`
        Applications              string                              `json:"applications,omitempty"`
        BypassType                string                              `json:"bypassType,omitempty"`
        BypassOnReauth            bool                                `json:"bypassOnReauth,omitempty"`
        HealthCheckType           string                              `json:"healthCheckType,omitempty"`
        IsCnameEnabled            bool                                `json:"isCnameEnabled"`
        IpAnchored                bool                                `json:"ipAnchored"`
        FQDNDnsCheck              bool                                `json:"fqdnDnsCheck"`
        HealthReporting           string                              `json:"healthReporting,omitempty"`
        SelectConnectorCloseToApp bool                                `json:"selectConnectorCloseToApp"`
        IcmpAccessType            string                              `json:"icmpAccessType,omitempty"`
        AppRecommendationId       string                              `json:"appRecommendationId,omitempty"`
        SegmentGroupID            string                              `json:"segmentGroupId"`
        SegmentGroupName          string                              `json:"segmentGroupName,omitempty"`
        CreationTime              string                              `json:"creationTime,omitempty"`
        ModifiedBy                string                              `json:"modifiedBy,omitempty"`
        ModifiedTime              string                              `json:"modifiedTime,omitempty"`
        TCPKeepAlive              string                              `json:"tcpKeepAlive,omitempty"`
        IsIncompleteDRConfig      bool                                `json:"isIncompleteDRConfig"`
        UseInDrMode               bool                                `json:"useInDrMode"`
        InspectTrafficWithZia     bool                                `json:"inspectTrafficWithZia"`
        MicroTenantID             string                              `json:"microtenantId,omitempty"`
        MicroTenantName           string                              `json:"microtenantName,omitempty"`
        MatchStyle                string                              `json:"matchStyle,omitempty"`
        TCPPortRanges             []string                            `json:"tcpPortRanges"`
        UDPPortRanges             []string                            `json:"udpPortRanges"`
        TCPAppPortRange           []common.NetworkPorts               `json:"tcpPortRange,omitempty"`
        UDPAppPortRange           []common.NetworkPorts               `json:"udpPortRange,omitempty"`
        ServerGroups              []AppServerGroups                   `json:"serverGroups"`
        DefaultIdleTimeout        string                              `json:"defaultIdleTimeout,omitempty"`
        DefaultMaxAge             string                              `json:"defaultMaxAge,omitempty"`
        CommonAppsDto             applicationsegmentpra.CommonAppsDto `json:"commonAppsDto,omitempty"`
        ClientlessApps            []browseraccess.ClientlessApps      `json:"clientlessApps,omitempty"`
        ShareToMicrotenants       []string                            `json:"shareToMicrotenants"`
        SharedMicrotenantDetails  SharedMicrotenantDetails            `json:"sharedMicrotenantDetails,omitempty"`
}

type SharedMicrotenantDetails struct {
        SharedFromMicrotenant SharedFromMicrotenant `json:"sharedFromMicrotenant,omitempty"`
        SharedToMicrotenants  []SharedToMicrotenant `json:"sharedToMicrotenants,omitempty"`
}

type SharedFromMicrotenant struct {
        ID   string `json:"id,omitempty"`
        Name string `json:"name,omitempty"`
}

type SharedToMicrotenant struct {
        ID   string `json:"id,omitempty"`
        Name string `json:"name,omitempty"`
}

type MicrotenantMove struct {
        TargetSegmentGroupId string `json:"targetSegmentGroupId,omitempty"`
        TargetMicrotenantId  string `json:"targetMicrotenantId,omitempty"`
        TargetServerGroupId  string `json:"targetServerGroupId,omitempty"`
}

type AppServerGroups struct {
        ConfigSpace      string `json:"configSpace,omitempty"`
        CreationTime     string `json:"creationTime,omitempty"`
        Description      string `json:"description,omitempty"`
        Enabled          bool   `json:"enabled"`
        ID               string `json:"id,omitempty"`
        DynamicDiscovery bool   `json:"dynamicDiscovery"`
        ModifiedBy       string `json:"modifiedBy,omitempty"`
        ModifiedTime     string `json:"modifiedTime,omitempty"`
        Name             string `json:"name"`
}

func (service *Service) Get(applicationID string) (*ApplicationSegmentResource, *http.Response, error) <span class="cov10" title="4">{
        v := new(ApplicationSegmentResource)
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+appSegmentEndpoint, applicationID)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, common.Filter{MicroTenantID: service.microTenantID}, nil, v)
        if err != nil </span><span class="cov5" title="2">{
                return nil, nil, err
        }</span>

        <span class="cov5" title="2">return v, resp, nil</span>
}

func (service *Service) GetByName(appName string) (*ApplicationSegmentResource, *http.Response, error) <span class="cov5" title="2">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + appSegmentEndpoint
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[ApplicationSegmentResource](service.Client, relativeURL, common.Filter{Search: appName, MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov5" title="2">for _, app := range list </span><span class="cov1" title="1">{
                if strings.EqualFold(app.Name, appName) </span><span class="cov1" title="1">{
                        return &amp;app, resp, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, resp, fmt.Errorf("no application segment named '%s' was found", appName)</span>
}

func (service *Service) Create(appSegment ApplicationSegmentResource) (*ApplicationSegmentResource, *http.Response, error) <span class="cov1" title="1">{
        v := new(ApplicationSegmentResource)
        resp, err := service.Client.NewRequestDo("POST", mgmtConfig+service.Client.Config.CustomerID+appSegmentEndpoint, common.Filter{MicroTenantID: service.microTenantID}, appSegment, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return v, resp, nil</span>
}

func (service *Service) Update(applicationId string, appSegmentRequest ApplicationSegmentResource) (*http.Response, error) <span class="cov5" title="2">{
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+appSegmentEndpoint, applicationId)
        resp, err := service.Client.NewRequestDo("PUT", relativeURL, common.Filter{MicroTenantID: service.microTenantID}, appSegmentRequest, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp, err</span>
}

func (service *Service) Delete(applicationId string) (*http.Response, error) <span class="cov5" title="2">{
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+appSegmentEndpoint, applicationId)
        resp, err := service.Client.NewRequestDo("DELETE", relativeURL, common.DeleteApplicationQueryParams{ForceDelete: true, MicroTenantID: service.microTenantID}, nil, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp, nil</span>
}

func (service *Service) GetAll() ([]ApplicationSegmentResource, *http.Response, error) <span class="cov1" title="1">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + appSegmentEndpoint
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[ApplicationSegmentResource](service.Client, relativeURL, common.Filter{MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">result := []ApplicationSegmentResource{}
        // filter apps
        for _, item := range list </span><span class="cov10" title="4">{
                if len(item.ClientlessApps) == 0 &amp;&amp; (len(item.CommonAppsDto.AppsConfig) == 0 || !common.InList(item.CommonAppsDto.AppsConfig[0].AppTypes, "SECURE_REMOTE_ACCESS") &amp;&amp; !common.InList(item.CommonAppsDto.AppsConfig[0].AppTypes, "INSPECT")) </span><span class="cov10" title="4">{
                        result = append(result, item)
                }</span>
        }
        <span class="cov1" title="1">return result, resp, nil</span>
}

func (service *Service) AppSegmentMicrotenantShare(applicationID string, appSegmentRequest ApplicationSegmentResource) (*http.Response, error) <span class="cov0" title="0">{
        // Corrected URL format to include the applicationID before /share
        relativeURL := fmt.Sprintf("%s%s%s/%s/share",
                mgmtConfig, service.Client.Config.CustomerID, appSegmentEndpoint, applicationID)

        // Since microtenantId is being passed via an environment variable, it's not explicitly included in the URL.
        // Ensure the NewRequestDo method or the infrastructure around it appropriately injects the microtenantId.
        resp, err := service.Client.NewRequestDo("PUT", relativeURL, common.Filter{}, appSegmentRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resp, nil</span>
}

// Move Application Segments from parent to another Microtenant Is Allowed
// Application Segments can be moved from local microtenant to parent
// Application Segments CANNOT be moved in between local microtenants.
func (service *Service) AppSegmentMicrotenantMove(applicationID string, move MicrotenantMove) (*http.Response, error) <span class="cov0" title="0">{
        // Corrected URL format to include the applicationID before /move
        relativeURL := fmt.Sprintf("%s%s%s/%s/move",
                mgmtConfig, service.Client.Config.CustomerID, appSegmentEndpoint, applicationID)
        resp, err := service.Client.NewRequestDo("POST", relativeURL, common.Filter{}, move, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package applicationsegmentbytype

import (
        "fmt"
        "net/http"
        "net/url"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfig              = "/mgmtconfig/v1/admin/customers/"
        applicationTypeEndpoint = "/application/getAppsByType"
)

type AppSegmentBaseAppDto struct {
        ID                  string `json:"id,omitempty"`
        AppID               string `json:"appId,omitempty"`
        Name                string `json:"name,omitempty"`
        Enabled             bool   `json:"enabled"`
        Domain              string `json:"domain,omitempty"`
        ApplicationPort     string `json:"applicationPort,omitempty"`
        ApplicationProtocol string `json:"applicationProtocol,omitempty"`
        CertificateID       string `json:"certificateId,omitempty"`
        CertificateName     string `json:"certificateName,omitempty"`
        MicroTenantID       string `json:"microtenantId,omitempty"`
        MicroTenantName     string `json:"microtenantName,omitempty"`
}

func (service *Service) GetByApplicationType(appName, applicationType string, expandAll bool) ([]AppSegmentBaseAppDto, *http.Response, error) <span class="cov10" title="7">{
        validApplicationTypes := map[string]bool{
                "BROWSER_ACCESS":       true,
                "INSPECT":              true,
                "SECURE_REMOTE_ACCESS": true,
        }

        if !validApplicationTypes[applicationType] </span><span class="cov1" title="1">{
                return nil, nil, fmt.Errorf("invalid applicationType '%s'. Valid types are 'BROWSER_ACCESS', 'INSPECT', 'SECURE_REMOTE_ACCESS'", applicationType)
        }</span>

        <span class="cov9" title="6">relativeURL := mgmtConfig + service.Client.Config.CustomerID + applicationTypeEndpoint

        // Construct the URL with expandAll and applicationType parameters
        query := url.Values{}
        query.Set("expandAll", fmt.Sprintf("%t", expandAll))
        query.Set("applicationType", applicationType)
        if appName != "" </span><span class="cov6" title="3">{
                query.Set("search", appName)
        }</span>

        <span class="cov9" title="6">constructedURL := relativeURL + "?" + query.Encode()
        // log.Printf("Constructed URL: %s\n", constructedURL)

        // Construct the filter
        filter := common.Filter{
                MicroTenantID: service.microTenantID,
        }
        if appName != "" </span><span class="cov6" title="3">{
                filter.Search = appName
        }</span>

        <span class="cov9" title="6">list, resp, err := common.GetAllPagesGenericWithCustomFilters[AppSegmentBaseAppDto](service.Client, constructedURL, filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov9" title="6">return list, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package applicationsegmentbytype

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client        *zpa.Client
        microTenantID *string
}

func New(c *zpa.Client) *Service <span class="cov8" title="1">{
        return &amp;Service{Client: c}
}</span>

func (service *Service) WithMicroTenant(microTenantID string) *Service <span class="cov0" title="0">{
        var mid *string
        if microTenantID != "" </span><span class="cov0" title="0">{
                mid_ := microTenantID
                mid = &amp;mid_
        }</span>
        <span class="cov0" title="0">return &amp;Service{
                Client:        service.Client,
                microTenantID: mid,
        }</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package applicationsegmentinspection

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client        *zpa.Client
        microTenantID *string
}

func New(c *zpa.Client) *Service <span class="cov10" title="5">{
        return &amp;Service{Client: c}
}</span>

func (service *Service) WithMicroTenant(microTenantID string) *Service <span class="cov0" title="0">{
        var mid *string
        if microTenantID != "" </span><span class="cov0" title="0">{
                mid_ := microTenantID
                mid = &amp;mid_
        }</span>
        <span class="cov0" title="0">return &amp;Service{
                Client:        service.Client,
                microTenantID: mid,
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package applicationsegmentinspection

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfig                   = "/mgmtconfig/v1/admin/customers/"
        appSegmentInspectionEndpoint = "/application"
        applicationTypeEndpoint      = "/application/getAppsByType"
)

type AppSegmentInspection struct {
        ID                        string                   `json:"id,omitempty"`
        SegmentGroupID            string                   `json:"segmentGroupId,omitempty"`
        SegmentGroupName          string                   `json:"segmentGroupName,omitempty"`
        BypassType                string                   `json:"bypassType,omitempty"`
        BypassOnReauth            bool                     `json:"bypassOnReauth,omitempty"`
        ConfigSpace               string                   `json:"configSpace,omitempty"`
        DomainNames               []string                 `json:"domainNames,omitempty"`
        Name                      string                   `json:"name,omitempty"`
        Description               string                   `json:"description,omitempty"`
        Enabled                   bool                     `json:"enabled"`
        AppRecommendationId       string                   `json:"appRecommendationId,omitempty"`
        ICMPAccessType            string                   `json:"icmpAccessType,omitempty"`
        PassiveHealthEnabled      bool                     `json:"passiveHealthEnabled,omitempty"`
        FQDNDnsCheck              bool                     `json:"fqdnDnsCheck"`
        MatchStyle                string                   `json:"matchStyle,omitempty"`
        SelectConnectorCloseToApp bool                     `json:"selectConnectorCloseToApp"`
        DoubleEncrypt             bool                     `json:"doubleEncrypt"`
        HealthCheckType           string                   `json:"healthCheckType,omitempty"`
        IsCnameEnabled            bool                     `json:"isCnameEnabled"`
        IPAnchored                bool                     `json:"ipAnchored"`
        HealthReporting           string                   `json:"healthReporting,omitempty"`
        CreationTime              string                   `json:"creationTime,omitempty"`
        ModifiedBy                string                   `json:"modifiedBy,omitempty"`
        ModifiedTime              string                   `json:"modifiedTime,omitempty"`
        TCPKeepAlive              string                   `json:"tcpKeepAlive,omitempty"`
        IsIncompleteDRConfig      bool                     `json:"isIncompleteDRConfig"`
        UseInDrMode               bool                     `json:"useInDrMode"`
        MicroTenantID             string                   `json:"microtenantId,omitempty"`
        MicroTenantName           string                   `json:"microtenantName,omitempty"`
        TCPPortRanges             []string                 `json:"tcpPortRanges,omitempty"`
        UDPPortRanges             []string                 `json:"udpPortRanges,omitempty"`
        TCPAppPortRange           []common.NetworkPorts    `json:"tcpPortRange,omitempty"`
        UDPAppPortRange           []common.NetworkPorts    `json:"udpPortRange,omitempty"`
        TCPProtocols              []string                 `json:"tcpProtocols,omitempty"`
        UDPProtocols              []string                 `json:"udpProtocols,omitempty"`
        InspectionAppDto          []InspectionAppDto       `json:"inspectionApps,omitempty"`
        CommonAppsDto             CommonAppsDto            `json:"commonAppsDto,omitempty"`
        AppServerGroups           []AppServerGroups        `json:"serverGroups,omitempty"`
        SharedMicrotenantDetails  SharedMicrotenantDetails `json:"sharedMicrotenantDetails,omitempty"`
}

type SharedMicrotenantDetails struct {
        SharedFromMicrotenant SharedFromMicrotenant `json:"sharedFromMicrotenant,omitempty"`
        SharedToMicrotenants  []SharedToMicrotenant `json:"sharedToMicrotenants,omitempty"`
}

type SharedFromMicrotenant struct {
        ID   string `json:"id,omitempty"`
        Name string `json:"name,omitempty"`
}

type SharedToMicrotenant struct {
        ID   string `json:"id,omitempty"`
        Name string `json:"name,omitempty"`
}

type CommonAppsDto struct {
        AppsConfig         []AppsConfig `json:"appsConfig,omitempty"`
        DeletedInspectApps []string     `json:"deletedInspectApps,omitempty"`
}

type AppsConfig struct {
        ID                  string   `json:"id,omitempty"`
        AppID               string   `json:"appId,omitempty"`
        Name                string   `json:"name,omitempty"`
        Description         string   `json:"description,omitempty"`
        Enabled             bool     `json:"enabled"`
        AllowOptions        bool     `json:"allowOptions"`
        AppTypes            []string `json:"appTypes,omitempty"`
        ApplicationPort     string   `json:"applicationPort,omitempty"`
        ApplicationProtocol string   `json:"applicationProtocol,omitempty"`
        InspectAppID        string   `json:"inspectAppId,omitempty"`
        CertificateID       string   `json:"certificateId,omitempty"`
        CertificateName     string   `json:"certificateName,omitempty"`
        Cname               string   `json:"cname,omitempty"`
        Domain              string   `json:"domain,omitempty"`
        Hidden              bool     `json:"hidden"`
        TrustUntrustedCert  bool     `json:"trustUntrustedCert"`
        LocalDomain         string   `json:"localDomain,omitempty"`
        Portal              bool     `json:"portal"`
}

type InspectionAppDto struct {
        ID                  string   `json:"id,omitempty"`
        AppID               string   `json:"appId,omitempty"`
        Name                string   `json:"name,omitempty"`
        Description         string   `json:"description,omitempty"`
        Enabled             bool     `json:"enabled"`
        ApplicationPort     string   `json:"applicationPort,omitempty"`
        ApplicationProtocol string   `json:"applicationProtocol,omitempty"`
        CertificateID       string   `json:"certificateId,omitempty"`
        CertificateName     string   `json:"certificateName,omitempty"`
        Domain              string   `json:"domain,omitempty"`
        Protocols           []string `json:"protocols,omitempty"`
        TrustUntrustedCert  bool     `json:"trustUntrustedCert"`
        MicroTenantID       string   `json:"microtenantId,omitempty"`
        MicroTenantName     string   `json:"microtenantName,omitempty"`
}

type AppServerGroups struct {
        ID string `json:"id"`
}

func (service *Service) Get(id string) (*AppSegmentInspection, *http.Response, error) <span class="cov10" title="6">{
        v := new(AppSegmentInspection)
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+appSegmentInspectionEndpoint, id)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, common.Filter{MicroTenantID: service.microTenantID}, nil, v)
        if err != nil </span><span class="cov6" title="3">{
                return nil, nil, err
        }</span>
        <span class="cov6" title="3">return v, resp, nil</span>
}

func (service *Service) GetByName(appSegmentName string) (*AppSegmentInspection, *http.Response, error) <span class="cov4" title="2">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + appSegmentInspectionEndpoint
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[AppSegmentInspection](service.Client, relativeURL, common.Filter{Search: appSegmentName, MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov4" title="2">for _, app := range list </span><span class="cov6" title="3">{
                if strings.EqualFold(app.Name, appSegmentName) </span><span class="cov1" title="1">{
                        return &amp;app, resp, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, resp, fmt.Errorf("no inspection application segment named '%s' was found", appSegmentName)</span>
}

func (service *Service) Create(appSegmentInspection AppSegmentInspection) (*AppSegmentInspection, *http.Response, error) <span class="cov1" title="1">{
        v := new(AppSegmentInspection)
        resp, err := service.Client.NewRequestDo("POST", mgmtConfig+service.Client.Config.CustomerID+appSegmentInspectionEndpoint, common.Filter{MicroTenantID: service.microTenantID}, appSegmentInspection, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return v, resp, nil</span>
}

// return the new items that were added to slice1
func difference(slice1 []AppsConfig, slice2 []AppsConfig) []AppsConfig <span class="cov4" title="2">{
        var diff []AppsConfig
        for _, s1 := range slice1 </span><span class="cov1" title="1">{
                found := false
                for _, s2 := range slice2 </span><span class="cov0" title="0">{
                        if s1.Domain == s2.Domain || s1.Name == s2.Name </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov1" title="1">if !found </span><span class="cov1" title="1">{
                        diff = append(diff, s1)
                }</span>
        }
        <span class="cov4" title="2">return diff</span>
}

func mapInspectionApp(InspectionAppDto []InspectionAppDto) []AppsConfig <span class="cov1" title="1">{
        result := []AppsConfig{}
        for _, app := range InspectionAppDto </span><span class="cov1" title="1">{
                result = append(result, AppsConfig{
                        Name:   app.Name,
                        Domain: app.Domain,
                        ID:     app.ID,
                        AppID:  app.AppID,
                })
        }</span>
        <span class="cov1" title="1">return result</span>
}

func appToListStringIDs(apps []AppsConfig) []string <span class="cov1" title="1">{
        result := []string{}
        for _, app := range apps </span><span class="cov1" title="1">{
                result = append(result, app.ID)
        }</span>
        <span class="cov1" title="1">return result</span>
}

func (service *Service) Update(id string, appSegmentInspection *AppSegmentInspection) (*http.Response, error) <span class="cov4" title="2">{
        existingResource, _, err := service.Get(id)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">existingApps := mapInspectionApp(existingResource.InspectionAppDto)
        newApps := difference(appSegmentInspection.CommonAppsDto.AppsConfig, existingApps)
        removedApps := difference(existingApps, appSegmentInspection.CommonAppsDto.AppsConfig)
        appSegmentInspection.CommonAppsDto.AppsConfig = newApps
        appSegmentInspection.CommonAppsDto.DeletedInspectApps = appToListStringIDs(removedApps)
        path := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+appSegmentInspectionEndpoint, id)
        resp, err := service.Client.NewRequestDo("PUT", path, common.Filter{MicroTenantID: service.microTenantID}, appSegmentInspection, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return resp, err</span>
}

func (service *Service) Delete(id string) (*http.Response, error) <span class="cov4" title="2">{
        path := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+appSegmentInspectionEndpoint, id)
        resp, err := service.Client.NewRequestDo("DELETE", path, common.DeleteApplicationQueryParams{ForceDelete: true, MicroTenantID: service.microTenantID}, nil, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return resp, err</span>
}

func (service *Service) GetAll() ([]AppSegmentInspection, *http.Response, error) <span class="cov0" title="0">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + appSegmentInspectionEndpoint
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[AppSegmentInspection](service.Client, relativeURL, common.Filter{MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">result := []AppSegmentInspection{}
        // filter inspection apps
        for _, item := range list </span><span class="cov0" title="0">{
                if len(item.CommonAppsDto.AppsConfig) &gt; 0 &amp;&amp; common.InList(item.CommonAppsDto.AppsConfig[0].AppTypes, "INSPECT") </span><span class="cov0" title="0">{
                        result = append(result, item)
                }</span>
        }
        <span class="cov0" title="0">return result, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package applicationsegmentpra

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client        *zpa.Client
        microTenantID *string
}

func New(c *zpa.Client) *Service <span class="cov10" title="5">{
        return &amp;Service{Client: c}
}</span>

func (service *Service) WithMicroTenant(microTenantID string) *Service <span class="cov0" title="0">{
        var mid *string
        if microTenantID != "" </span><span class="cov0" title="0">{
                mid_ := microTenantID
                mid = &amp;mid_
        }</span>
        <span class="cov0" title="0">return &amp;Service{
                Client:        service.Client,
                microTenantID: mid,
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package applicationsegmentpra

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfig              = "/mgmtconfig/v1/admin/customers/"
        appSegmentPraEndpoint   = "/application"
        applicationTypeEndpoint = "/application/getAppsByType"
)

type AppSegmentPRA struct {
        ID                        string                   `json:"id,omitempty"`
        DomainNames               []string                 `json:"domainNames,omitempty"`
        Name                      string                   `json:"name,omitempty"`
        Description               string                   `json:"description,omitempty"`
        Enabled                   bool                     `json:"enabled"`
        PassiveHealthEnabled      bool                     `json:"passiveHealthEnabled"`
        SelectConnectorCloseToApp bool                     `json:"selectConnectorCloseToApp"`
        DoubleEncrypt             bool                     `json:"doubleEncrypt"`
        AppRecommendationId       string                   `json:"appRecommendationId,omitempty"`
        ConfigSpace               string                   `json:"configSpace,omitempty"`
        Applications              string                   `json:"applications,omitempty"`
        BypassType                string                   `json:"bypassType,omitempty"`
        MatchStyle                string                   `json:"matchStyle,omitempty"`
        BypassOnReauth            bool                     `json:"bypassOnReauth,omitempty"`
        FQDNDnsCheck              bool                     `json:"fqdnDnsCheck"`
        HealthCheckType           string                   `json:"healthCheckType,omitempty"`
        IsCnameEnabled            bool                     `json:"isCnameEnabled"`
        IpAnchored                bool                     `json:"ipAnchored"`
        HealthReporting           string                   `json:"healthReporting,omitempty"`
        IcmpAccessType            string                   `json:"icmpAccessType,omitempty"`
        SegmentGroupID            string                   `json:"segmentGroupId"`
        SegmentGroupName          string                   `json:"segmentGroupName,omitempty"`
        CreationTime              string                   `json:"creationTime,omitempty"`
        ModifiedBy                string                   `json:"modifiedBy,omitempty"`
        ModifiedTime              string                   `json:"modifiedTime,omitempty"`
        TCPKeepAlive              string                   `json:"tcpKeepAlive,omitempty"`
        IsIncompleteDRConfig      bool                     `json:"isIncompleteDRConfig"`
        UseInDrMode               bool                     `json:"useInDrMode"`
        MicroTenantID             string                   `json:"microtenantId,omitempty"`
        MicroTenantName           string                   `json:"microtenantName,omitempty"`
        TCPAppPortRange           []common.NetworkPorts    `json:"tcpPortRange,omitempty"`
        UDPAppPortRange           []common.NetworkPorts    `json:"udpPortRange,omitempty"`
        TCPPortRanges             []string                 `json:"tcpPortRanges,omitempty"`
        UDPPortRanges             []string                 `json:"udpPortRanges,omitempty"`
        ServerGroups              []AppServerGroups        `json:"serverGroups,omitempty"`
        DefaultIdleTimeout        string                   `json:"defaultIdleTimeout,omitempty"`
        DefaultMaxAge             string                   `json:"defaultMaxAge,omitempty"`
        PRAApps                   []PRAApps                `json:"praApps"`
        CommonAppsDto             CommonAppsDto            `json:"commonAppsDto,omitempty"`
        SharedMicrotenantDetails  SharedMicrotenantDetails `json:"sharedMicrotenantDetails,omitempty"`
}

type SharedMicrotenantDetails struct {
        SharedFromMicrotenant SharedFromMicrotenant `json:"sharedFromMicrotenant,omitempty"`
        SharedToMicrotenants  []SharedToMicrotenant `json:"sharedToMicrotenants,omitempty"`
}

type SharedFromMicrotenant struct {
        ID   string `json:"id,omitempty"`
        Name string `json:"name,omitempty"`
}

type SharedToMicrotenant struct {
        ID   string `json:"id,omitempty"`
        Name string `json:"name,omitempty"`
}
type CommonAppsDto struct {
        AppsConfig     []AppsConfig `json:"appsConfig,omitempty"`
        DeletedSraApps []string     `json:"deletedSraApps,omitempty"`
}

type AppsConfig struct {
        ID                  string   `json:"id,omitempty"`
        AppID               string   `json:"appId,omitempty"`
        Name                string   `json:"name,omitempty"`
        Description         string   `json:"description,omitempty"`
        Enabled             bool     `json:"enabled,omitempty"`
        AppTypes            []string `json:"appTypes,omitempty"`
        ApplicationPort     string   `json:"applicationPort,omitempty"`
        ApplicationProtocol string   `json:"applicationProtocol,omitempty"`
        Cname               string   `json:"cname,omitempty"`
        ConnectionSecurity  string   `json:"connectionSecurity,omitempty"`
        Domain              string   `json:"domain,omitempty"`
        Hidden              bool     `json:"hidden,omitempty"`
        LocalDomain         string   `json:"localDomain,omitempty"`
        Portal              bool     `json:"portal,omitempty"`
}

type PRAApps struct {
        ID                  string `json:"id,omitempty"`
        Name                string `json:"name,omitempty"`
        AppID               string `json:"appId,omitempty"`
        ApplicationPort     string `json:"applicationPort,omitempty"`
        ApplicationProtocol string `json:"applicationProtocol,omitempty"`
        CertificateID       string `json:"certificateId,omitempty"`
        CertificateName     string `json:"certificateName,omitempty"`
        ConnectionSecurity  string `json:"connectionSecurity,omitempty"`
        Hidden              bool   `json:"hidden"`
        Portal              bool   `json:"portal"`
        Description         string `json:"description,omitempty"`
        Domain              string `json:"domain,omitempty"`
        Enabled             bool   `json:"enabled"`
        MicroTenantID       string `json:"microtenantId,omitempty"`
        MicroTenantName     string `json:"microtenantName,omitempty"`
}

type AppServerGroups struct {
        ID string `json:"id"`
}

func (service *Service) Get(id string) (*AppSegmentPRA, *http.Response, error) <span class="cov10" title="6">{
        v := new(AppSegmentPRA)
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+appSegmentPraEndpoint, id)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, common.Filter{MicroTenantID: service.microTenantID}, nil, v)
        if err != nil </span><span class="cov6" title="3">{
                return nil, nil, err
        }</span>
        <span class="cov6" title="3">return v, resp, nil</span>
}

func (service *Service) GetByName(BaName string) (*AppSegmentPRA, *http.Response, error) <span class="cov4" title="2">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + appSegmentPraEndpoint
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[AppSegmentPRA](service.Client, relativeURL, common.Filter{Search: BaName, MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov4" title="2">for _, app := range list </span><span class="cov4" title="2">{
                if strings.EqualFold(app.Name, BaName) </span><span class="cov1" title="1">{
                        return &amp;app, resp, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, resp, fmt.Errorf("no browser access application named '%s' was found", BaName)</span>
}

func (service *Service) Create(appSegmentPra AppSegmentPRA) (*AppSegmentPRA, *http.Response, error) <span class="cov1" title="1">{
        v := new(AppSegmentPRA)
        resp, err := service.Client.NewRequestDo("POST", mgmtConfig+service.Client.Config.CustomerID+appSegmentPraEndpoint, common.Filter{MicroTenantID: service.microTenantID}, appSegmentPra, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return v, resp, nil</span>
}

// return the new items that were added to slice1
func difference(slice1 []AppsConfig, slice2 []AppsConfig) []AppsConfig <span class="cov4" title="2">{
        var diff []AppsConfig
        for _, s1 := range slice1 </span><span class="cov1" title="1">{
                found := false
                for _, s2 := range slice2 </span><span class="cov0" title="0">{
                        if s1.Domain == s2.Domain || s1.Name == s2.Name </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov1" title="1">if !found </span><span class="cov1" title="1">{
                        diff = append(diff, s1)
                }</span>
        }
        <span class="cov4" title="2">return diff</span>
}

func mapSraApp(PRAApps []PRAApps) []AppsConfig <span class="cov1" title="1">{
        result := []AppsConfig{}
        for _, app := range PRAApps </span><span class="cov1" title="1">{
                result = append(result, AppsConfig{
                        Name:   app.Name,
                        Domain: app.Domain,
                        ID:     app.ID,
                        AppID:  app.AppID,
                })
        }</span>
        <span class="cov1" title="1">return result</span>
}

func appToListStringIDs(apps []AppsConfig) []string <span class="cov1" title="1">{
        result := []string{}
        for _, app := range apps </span><span class="cov1" title="1">{
                result = append(result, app.ID)
        }</span>
        <span class="cov1" title="1">return result</span>
}

func (service *Service) Update(id string, appSegmentPra *AppSegmentPRA) (*http.Response, error) <span class="cov4" title="2">{
        existingResource, _, err := service.Get(id)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">existingApps := mapSraApp(existingResource.PRAApps)
        newApps := difference(appSegmentPra.CommonAppsDto.AppsConfig, existingApps)
        removedApps := difference(existingApps, appSegmentPra.CommonAppsDto.AppsConfig)
        appSegmentPra.CommonAppsDto.AppsConfig = newApps
        appSegmentPra.CommonAppsDto.DeletedSraApps = appToListStringIDs(removedApps)
        path := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+appSegmentPraEndpoint, id)
        resp, err := service.Client.NewRequestDo("PUT", path, common.Filter{MicroTenantID: service.microTenantID}, appSegmentPra, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return resp, err</span>
}

func (service *Service) Delete(id string) (*http.Response, error) <span class="cov4" title="2">{
        path := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+appSegmentPraEndpoint, id)
        resp, err := service.Client.NewRequestDo("DELETE", path, common.DeleteApplicationQueryParams{ForceDelete: true, MicroTenantID: service.microTenantID}, nil, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return resp, err</span>
}

func (service *Service) GetAll() ([]AppSegmentPRA, *http.Response, error) <span class="cov1" title="1">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + appSegmentPraEndpoint
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[AppSegmentPRA](service.Client, relativeURL, common.Filter{MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">result := []AppSegmentPRA{}
        // filter pra apps
        for _, item := range list </span><span class="cov6" title="3">{
                if len(item.CommonAppsDto.AppsConfig) == 0 || (!common.InList(item.CommonAppsDto.AppsConfig[0].AppTypes, "SECURE_REMOTE_ACCESS") &amp;&amp; !common.InList(item.CommonAppsDto.AppsConfig[0].AppTypes, "INSPECT")) </span><span class="cov6" title="3">{
                        result = append(result, item)
                }</span>
        }
        <span class="cov1" title="1">return result, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package appservercontroller

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client        *zpa.Client
        microTenantID *string
}

func New(c *zpa.Client) *Service <span class="cov10" title="5">{
        return &amp;Service{Client: c}
}</span>

func (service *Service) WithMicroTenant(microTenantID string) *Service <span class="cov0" title="0">{
        var mid *string
        if microTenantID != "" </span><span class="cov0" title="0">{
                mid_ := microTenantID
                mid = &amp;mid_
        }</span>
        <span class="cov0" title="0">return &amp;Service{
                Client:        service.Client,
                microTenantID: mid,
        }</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package appservercontroller

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfig                  = "/mgmtconfig/v1/admin/customers/"
        appServerControllerEndpoint = "/server"
)

type ApplicationServer struct {
        Address           string   `json:"address"`
        AppServerGroupIds []string `json:"appServerGroupIds"`
        ConfigSpace       string   `json:"configSpace,omitempty"`
        CreationTime      string   `json:"creationTime,"`
        Description       string   `json:"description"`
        Enabled           bool     `json:"enabled"`
        ID                string   `json:"id,omitempty"`
        ModifiedBy        string   `json:"modifiedBy"`
        ModifiedTime      string   `json:"modifiedTime"`
        Name              string   `json:"name"`
        MicroTenantID     string   `json:"microtenantId,omitempty"`
        MicroTenantName   string   `json:"microtenantName,omitempty"`
}

func (service *Service) Get(id string) (*ApplicationServer, *http.Response, error) <span class="cov10" title="2">{
        v := new(ApplicationServer)
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+appServerControllerEndpoint, id)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, common.Filter{MicroTenantID: service.microTenantID}, nil, v)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return v, resp, nil</span>
}

func (service *Service) GetByName(appServerName string) (*ApplicationServer, *http.Response, error) <span class="cov10" title="2">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + appServerControllerEndpoint
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[ApplicationServer](service.Client, relativeURL, common.Filter{Search: appServerName, MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov10" title="2">for _, app := range list </span><span class="cov1" title="1">{
                if strings.EqualFold(app.Name, appServerName) </span><span class="cov1" title="1">{
                        return &amp;app, resp, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, resp, fmt.Errorf("no application server named '%s' was found", appServerName)</span>
}

func (service *Service) Create(server ApplicationServer) (*ApplicationServer, *http.Response, error) <span class="cov1" title="1">{
        v := new(ApplicationServer)
        resp, err := service.Client.NewRequestDo("POST", mgmtConfig+service.Client.Config.CustomerID+appServerControllerEndpoint, common.Filter{MicroTenantID: service.microTenantID}, server, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return v, resp, nil</span>
}

func (service *Service) Update(id string, appServer ApplicationServer) (*http.Response, error) <span class="cov10" title="2">{
        path := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+appServerControllerEndpoint, id)
        resp, err := service.Client.NewRequestDo("PUT", path, common.Filter{MicroTenantID: service.microTenantID}, appServer, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return resp, err</span>
}

func (service *Service) Delete(id string) (*http.Response, error) <span class="cov10" title="2">{
        path := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+appServerControllerEndpoint, id)
        resp, err := service.Client.NewRequestDo("DELETE", path, common.Filter{MicroTenantID: service.microTenantID}, nil, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return resp, err</span>
}

func (service *Service) GetAll() ([]ApplicationServer, *http.Response, error) <span class="cov1" title="1">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + appServerControllerEndpoint
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[ApplicationServer](service.Client, relativeURL, common.Filter{MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return list, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package bacertificate

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client        *zpa.Client
        microTenantID *string
}

func New(c *zpa.Client) *Service <span class="cov8" title="1">{
        return &amp;Service{Client: c}
}</span>

func (service *Service) WithMicroTenant(microTenantID string) *Service <span class="cov0" title="0">{
        var mid *string
        if microTenantID != "" </span><span class="cov0" title="0">{
                mid_ := microTenantID
                mid = &amp;mid_
        }</span>
        <span class="cov0" title="0">return &amp;Service{
                Client:        service.Client,
                microTenantID: mid,
        }</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package bacertificate

import (
        "fmt"
        "net/http"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfigV1                = "/mgmtconfig/v1/admin/customers/"
        baCertificateEndpoint       = "/certificate"
        mgmtConfigV2                = "/mgmtconfig/v2/admin/customers/"
        baCertificateIssuedEndpoint = "/clientlessCertificate/issued"
)

type BaCertificate struct {
        ID                  string   `json:"id,omitempty"`
        Name                string   `json:"name,omitempty"`
        Description         string   `json:"description,omitempty"`
        CName               string   `json:"cName,omitempty"`
        CertChain           string   `json:"certChain,omitempty"`
        CertBlob            string   `json:"certBlob,omitempty"`
        Certificate         string   `json:"certificate,omitempty"`
        PublicKey           string   `json:"publicKey,omitempty"`
        CreationTime        string   `json:"creationTime,omitempty"`
        IssuedBy            string   `json:"issuedBy,omitempty"`
        IssuedTo            string   `json:"issuedTo,omitempty"`
        ModifiedBy          string   `json:"modifiedBy,omitempty"`
        ModifiedTime        string   `json:"modifiedTime,omitempty"`
        San                 []string `json:"san,omitempty"`
        SerialNo            string   `json:"serialNo,omitempty"`
        Status              string   `json:"status,omitempty"`
        ValidFromInEpochSec string   `json:"validFromInEpochSec,omitempty"`
        ValidToInEpochSec   string   `json:"validToInEpochSec,omitempty"`
        MicrotenantID       string   `json:"microtenantId,omitempty"`
        MicrotenantName     string   `json:"microtenantName,omitempty"`
}

func (service *Service) Get(baCertificateID string) (*BaCertificate, *http.Response, error) <span class="cov10" title="2">{
        v := new(BaCertificate)
        relativeURL := fmt.Sprintf("%v/%v", mgmtConfigV1+service.Client.Config.CustomerID+baCertificateEndpoint, baCertificateID)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, common.Filter{MicroTenantID: service.microTenantID}, nil, v)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return v, resp, nil</span>
}

func (service *Service) GetIssuedByName(CertName string) (*BaCertificate, *http.Response, error) <span class="cov0" title="0">{
        relativeURL := fmt.Sprintf(mgmtConfigV2 + service.Client.Config.CustomerID + baCertificateIssuedEndpoint)
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[BaCertificate](service.Client, relativeURL, common.Filter{Search: CertName, MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">for _, baCertificate := range list </span><span class="cov0" title="0">{
                if baCertificate.Name == CertName </span><span class="cov0" title="0">{
                        return &amp;baCertificate, resp, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, resp, fmt.Errorf("no issued certificate named '%s' was found", CertName)</span>
}

func (service *Service) GetAll() ([]BaCertificate, *http.Response, error) <span class="cov0" title="0">{
        relativeURL := fmt.Sprintf(mgmtConfigV2 + service.Client.Config.CustomerID + baCertificateIssuedEndpoint)
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[BaCertificate](service.Client, relativeURL, common.Filter{MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return list, resp, nil</span>
}

func (service *Service) Create(baCertificate BaCertificate) (*BaCertificate, *http.Response, error) <span class="cov10" title="2">{
        v := new(BaCertificate)
        resp, err := service.Client.NewRequestDo("POST", mgmtConfigV1+service.Client.Config.CustomerID+baCertificateEndpoint, common.Filter{MicroTenantID: service.microTenantID}, baCertificate, &amp;v)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return v, resp, nil</span>
}

func (service *Service) Delete(baCertificateID string) (*http.Response, error) <span class="cov0" title="0">{
        path := fmt.Sprintf("%s/%s", mgmtConfigV1+service.Client.Config.CustomerID+baCertificateEndpoint, baCertificateID)
        resp, err := service.Client.NewRequestDo("DELETE", path, common.Filter{MicroTenantID: service.microTenantID}, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package browseraccess

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client        *zpa.Client
        microTenantID *string
}

func New(c *zpa.Client) *Service <span class="cov10" title="5">{
        return &amp;Service{Client: c}
}</span>

func (service *Service) WithMicroTenant(microTenantID string) *Service <span class="cov0" title="0">{
        var mid *string
        if microTenantID != "" </span><span class="cov0" title="0">{
                mid_ := microTenantID
                mid = &amp;mid_
        }</span>
        <span class="cov0" title="0">return &amp;Service{
                Client:        service.Client,
                microTenantID: mid,
        }</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package browseraccess

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfig              = "/mgmtconfig/v1/admin/customers/"
        browserAccessEndpoint   = "/application"
        applicationTypeEndpoint = "/application/getAppsByType"
)

type BrowserAccess struct {
        ID                        string                   `json:"id,omitempty"`
        Name                      string                   `json:"name,omitempty"`
        Description               string                   `json:"description,omitempty"`
        SegmentGroupID            string                   `json:"segmentGroupId,omitempty"`
        SegmentGroupName          string                   `json:"segmentGroupName,omitempty"`
        BypassType                string                   `json:"bypassType,omitempty"`
        BypassOnReauth            bool                     `json:"bypassOnReauth,omitempty"`
        AppRecommendationId       string                   `json:"appRecommendationId,omitempty"`
        MatchStyle                string                   `json:"matchStyle,omitempty"`
        ConfigSpace               string                   `json:"configSpace,omitempty"`
        DomainNames               []string                 `json:"domainNames,omitempty"`
        Enabled                   bool                     `json:"enabled"`
        PassiveHealthEnabled      bool                     `json:"passiveHealthEnabled"`
        FQDNDnsCheck              bool                     `json:"fqdnDnsCheck"`
        SelectConnectorCloseToApp bool                     `json:"selectConnectorCloseToApp"`
        DoubleEncrypt             bool                     `json:"doubleEncrypt"`
        HealthCheckType           string                   `json:"healthCheckType,omitempty"`
        IsCnameEnabled            bool                     `json:"isCnameEnabled"`
        IPAnchored                bool                     `json:"ipAnchored"`
        TCPKeepAlive              string                   `json:"tcpKeepAlive,omitempty"`
        IsIncompleteDRConfig      bool                     `json:"isIncompleteDRConfig"`
        UseInDrMode               bool                     `json:"useInDrMode"`
        InspectTrafficWithZia     bool                     `json:"inspectTrafficWithZia"`
        MicroTenantID             string                   `json:"microtenantId,omitempty"`
        MicroTenantName           string                   `json:"microtenantName,omitempty"`
        HealthReporting           string                   `json:"healthReporting,omitempty"`
        ICMPAccessType            string                   `json:"icmpAccessType,omitempty"`
        CreationTime              string                   `json:"creationTime,omitempty"`
        ModifiedBy                string                   `json:"modifiedBy,omitempty"`
        ModifiedTime              string                   `json:"modifiedTime,omitempty"`
        TCPPortRanges             []string                 `json:"tcpPortRanges,omitempty"`
        UDPPortRanges             []string                 `json:"udpPortRanges,omitempty"`
        TCPAppPortRange           []common.NetworkPorts    `json:"tcpPortRange,omitempty"`
        UDPAppPortRange           []common.NetworkPorts    `json:"udpPortRange,omitempty"`
        ClientlessApps            []ClientlessApps         `json:"clientlessApps,omitempty"`
        AppServerGroups           []AppServerGroups        `json:"serverGroups,omitempty"`
        SharedMicrotenantDetails  SharedMicrotenantDetails `json:"sharedMicrotenantDetails,omitempty"`
}

type SharedMicrotenantDetails struct {
        SharedFromMicrotenant SharedFromMicrotenant `json:"sharedFromMicrotenant,omitempty"`
        SharedToMicrotenants  []SharedToMicrotenant `json:"sharedToMicrotenants,omitempty"`
}

type SharedFromMicrotenant struct {
        ID   string `json:"id,omitempty"`
        Name string `json:"name,omitempty"`
}

type SharedToMicrotenant struct {
        ID   string `json:"id,omitempty"`
        Name string `json:"name,omitempty"`
}

type ClientlessApps struct {
        AllowOptions        bool   `json:"allowOptions"`
        AppID               string `json:"appId,omitempty"`
        ApplicationPort     string `json:"applicationPort,omitempty"`
        ApplicationProtocol string `json:"applicationProtocol,omitempty"`
        CertificateID       string `json:"certificateId,omitempty"`
        CertificateName     string `json:"certificateName,omitempty"`
        Cname               string `json:"cname,omitempty"`
        CreationTime        string `json:"creationTime,omitempty"`
        Description         string `json:"description,omitempty"`
        Domain              string `json:"domain,omitempty"`
        Enabled             bool   `json:"enabled"`
        Hidden              bool   `json:"hidden"`
        ID                  string `json:"id,omitempty"`
        LocalDomain         string `json:"localDomain,omitempty"`
        ModifiedBy          string `json:"modifiedBy,omitempty"`
        ModifiedTime        string `json:"modifiedTime,omitempty"`
        Name                string `json:"name,omitempty"`
        Path                string `json:"path,omitempty"`
        MicroTenantID       string `json:"microtenantId,omitempty"`
        MicroTenantName     string `json:"microtenantName,omitempty"`
        TrustUntrustedCert  bool   `json:"trustUntrustedCert"`
}

type AppServerGroups struct {
        ID string `json:"id"`
}

func (service *Service) Get(id string) (*BrowserAccess, *http.Response, error) <span class="cov10" title="4">{
        v := new(BrowserAccess)
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+browserAccessEndpoint, id)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, common.Filter{MicroTenantID: service.microTenantID}, nil, v)
        if err != nil </span><span class="cov5" title="2">{
                return nil, nil, err
        }</span>
        <span class="cov5" title="2">return v, resp, nil</span>
}

func (service *Service) GetByName(BaName string) (*BrowserAccess, *http.Response, error) <span class="cov5" title="2">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + browserAccessEndpoint
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[BrowserAccess](service.Client, relativeURL, common.Filter{MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov5" title="2">for _, app := range list </span><span class="cov1" title="1">{
                if strings.EqualFold(app.Name, BaName) </span><span class="cov1" title="1">{
                        return &amp;app, resp, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, resp, fmt.Errorf("no browser access application named '%s' was found", BaName)</span>
}

func (service *Service) Create(browserAccess BrowserAccess) (*BrowserAccess, *http.Response, error) <span class="cov1" title="1">{
        v := new(BrowserAccess)
        resp, err := service.Client.NewRequestDo("POST", mgmtConfig+service.Client.Config.CustomerID+browserAccessEndpoint, common.Filter{MicroTenantID: service.microTenantID}, browserAccess, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return v, resp, nil</span>
}

func (service *Service) Update(id string, browserAccess *BrowserAccess) (*http.Response, error) <span class="cov5" title="2">{
        path := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+browserAccessEndpoint, id)
        resp, err := service.Client.NewRequestDo("PUT", path, common.Filter{MicroTenantID: service.microTenantID}, browserAccess, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return resp, err</span>
}

func (service *Service) Delete(id string) (*http.Response, error) <span class="cov5" title="2">{
        path := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+browserAccessEndpoint, id)
        resp, err := service.Client.NewRequestDo("DELETE", path, common.DeleteApplicationQueryParams{ForceDelete: true, MicroTenantID: service.microTenantID}, nil, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return resp, err</span>
}

func (service *Service) GetAll() ([]BrowserAccess, *http.Response, error) <span class="cov1" title="1">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + browserAccessEndpoint
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[BrowserAccess](service.Client, relativeURL, common.Filter{MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">result := []BrowserAccess{}
        // filter browser access apps
        for _, item := range list </span><span class="cov5" title="2">{
                if len(item.ClientlessApps) &gt; 0 </span><span class="cov1" title="1">{
                        result = append(result, item)
                }</span>
        }
        <span class="cov1" title="1">return result, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package clienttypes

import (
        "net/http"
)

const (
        mgmtConfig          = "/mgmtconfig/v1/admin/customers/"
        clientTypesEndpoint = "/clientTypes"
)

type ClientTypes struct {
        ZPNClientTypeExplorer         string `json:"zpn_client_type_exporter"`
        ZPNClientTypeNoAuth           string `json:"zpn_client_type_exporter_noauth"`
        ZPNClientTypeBrowserIsolation string `json:"zpn_client_type_browser_isolation"`
        ZPNClientTypeMachineTunnel    string `json:"zpn_client_type_machine_tunnel"`
        ZPNClientTypeIPAnchoring      string `json:"zpn_client_type_ip_anchoring"`
        ZPNClientTypeEdgeConnector    string `json:"zpn_client_type_edge_connector"`
        ZPNClientTypeZAPP             string `json:"zpn_client_type_zapp"`
        ZPNClientTypeSlogger          string `json:"zpn_client_type_slogger"`
        ZPNClientTypeBranchConnector  string `json:"zpn_client_type_branch_connector"`
        ZPNClientTypePartner          string `json:"zpn_client_type_zapp_partner"`
}

func (service *Service) GetAllClientTypes() (*ClientTypes, *http.Response, error) <span class="cov8" title="1">{
        v := new(ClientTypes)
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + clientTypesEndpoint
        resp, err := service.Client.NewRequestDo("GET", relativeURL, nil, nil, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">return v, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package clienttypes

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client *zpa.Client
}

func New(c *zpa.Client) *Service <span class="cov8" title="1">{
        return &amp;Service{Client: c}
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package cbibannercontroller

import (
        "fmt"
        "net/http"
        "strings"
)

const (
        cbiConfig          = "/cbiconfig/cbi/api/customers/"
        cbiBannerEndpoint  = "/banner"
        cbiBannersEndpoint = "/banners"
)

type CBIBannerController struct {
        ID                string `json:"id,omitempty"`
        Name              string `json:"name,omitempty"`
        PrimaryColor      string `json:"primaryColor,omitempty"`
        TextColor         string `json:"textColor,omitempty"`
        NotificationTitle string `json:"notificationTitle,omitempty"`
        NotificationText  string `json:"notificationText,omitempty"`
        Logo              string `json:"logo,omitempty"`
        Banner            bool   `json:"banner,omitempty"`
        IsDefault         bool   `json:"isDefault,omitempty"`
        Persist           bool   `json:"persist,omitempty"`
}

func (service *Service) Get(bannerID string) (*CBIBannerController, *http.Response, error) <span class="cov10" title="4">{
        v := new(CBIBannerController)
        relativeURL := fmt.Sprintf("%s/%s", cbiConfig+service.Client.Config.CustomerID+cbiBannersEndpoint, bannerID)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, nil, nil, &amp;v)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="3">return v, resp, nil</span>
}

func (service *Service) GetByName(bannerName string) (*CBIBannerController, *http.Response, error) <span class="cov1" title="1">{
        list, resp, err := service.GetAll()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">for _, banner := range list </span><span class="cov5" title="2">{
                if strings.EqualFold(banner.Name, bannerName) </span><span class="cov1" title="1">{
                        return &amp;banner, resp, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, resp, fmt.Errorf("no cloud browser isolation banner named '%s' was found", bannerName)</span>
}

func (service *Service) Create(cbiBanner *CBIBannerController) (*CBIBannerController, *http.Response, error) <span class="cov1" title="1">{
        v := new(CBIBannerController)
        resp, err := service.Client.NewRequestDo("POST", cbiConfig+service.Client.Config.CustomerID+cbiBannerEndpoint, nil, cbiBanner, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return v, resp, nil</span>
}

func (service *Service) Update(cbiBannerID string, cbiBanner *CBIBannerController) (*http.Response, error) <span class="cov1" title="1">{
        path := fmt.Sprintf("%v/%v", cbiConfig+service.Client.Config.CustomerID+cbiBannersEndpoint, cbiBannerID)
        resp, err := service.Client.NewRequestDo("PUT", path, nil, cbiBanner, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return resp, err</span>
}

func (service *Service) Delete(cbiBannerID string) (*http.Response, error) <span class="cov1" title="1">{
        path := fmt.Sprintf("%v/%v", cbiConfig+service.Client.Config.CustomerID+cbiBannersEndpoint, cbiBannerID)
        resp, err := service.Client.NewRequestDo("DELETE", path, nil, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return resp, err</span>
}

func (service *Service) GetAll() ([]CBIBannerController, *http.Response, error) <span class="cov5" title="2">{
        relativeURL := cbiConfig + service.Client.Config.CustomerID + cbiBannersEndpoint
        var list []CBIBannerController
        resp, err := service.Client.NewRequestDo("GET", relativeURL, nil, nil, &amp;list)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov5" title="2">return list, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package cbibannercontroller

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client *zpa.Client
}

func New(c *zpa.Client) *Service <span class="cov8" title="1">{
        return &amp;Service{Client: c}
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package cbicertificatecontroller

import (
        "fmt"
        "net/http"
        "strings"
)

const (
        cbiConfig               = "/cbiconfig/cbi/api/customers/"
        cbiCertificateEndpoint  = "/certificate"
        cbiCertificatesEndpoint = "/certificates"
)

type CBICertificate struct {
        ID        string `json:"id,omitempty"`
        Name      string `json:"name,omitempty"`
        PEM       string `json:"pem,omitempty"`
        IsDefault bool   `json:"isDefault,omitempty"`
}

func (service *Service) Get(certificateID string) (*CBICertificate, *http.Response, error) <span class="cov10" title="2">{
        v := new(CBICertificate)
        relativeURL := fmt.Sprintf("%s/%s", cbiConfig+service.Client.Config.CustomerID+cbiCertificatesEndpoint, certificateID)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, nil, nil, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov10" title="2">return v, resp, nil</span>
}

func (service *Service) GetByName(certificateName string) (*CBICertificate, *http.Response, error) <span class="cov0" title="0">{
        list, resp, err := service.GetAll()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">for _, profile := range list </span><span class="cov0" title="0">{
                if strings.EqualFold(profile.Name, certificateName) </span><span class="cov0" title="0">{
                        return &amp;profile, resp, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, resp, fmt.Errorf("no certificate named '%s' was found", certificateName)</span>
}

func (service *Service) Create(cbiProfile *CBICertificate) (*CBICertificate, *http.Response, error) <span class="cov10" title="2">{
        v := new(CBICertificate)
        resp, err := service.Client.NewRequestDo("POST", cbiConfig+service.Client.Config.CustomerID+cbiCertificateEndpoint, nil, cbiProfile, &amp;v)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return v, resp, nil</span>
}

func (service *Service) Update(certificateID string, certificateRequest *CBICertificate) (*http.Response, error) <span class="cov1" title="1">{
        path := fmt.Sprintf("%v/%v", cbiConfig+service.Client.Config.CustomerID+cbiCertificatesEndpoint, certificateID)
        resp, err := service.Client.NewRequestDo("PUT", path, nil, certificateRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return resp, err</span>
}

func (service *Service) Delete(certificateID string) (*http.Response, error) <span class="cov0" title="0">{
        path := fmt.Sprintf("%v/%v", cbiConfig+service.Client.Config.CustomerID+cbiCertificatesEndpoint, certificateID)
        resp, err := service.Client.NewRequestDo("DELETE", path, nil, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resp, err</span>
}

func (service *Service) GetAll() ([]CBICertificate, *http.Response, error) <span class="cov1" title="1">{
        relativeURL := cbiConfig + service.Client.Config.CustomerID + cbiCertificatesEndpoint
        var list []CBICertificate
        resp, err := service.Client.NewRequestDo("GET", relativeURL, nil, nil, &amp;list)
        if err != nil </span><span class="cov0" title="0">{
                return nil, resp, err
        }</span>
        <span class="cov1" title="1">return list, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package cbicertificatecontroller

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client *zpa.Client
}

func New(c *zpa.Client) *Service <span class="cov8" title="1">{
        return &amp;Service{Client: c}
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package cbiprofilecontroller

import (
        "fmt"
        "net/http"
        "strings"
)

const (
        cbiConfig          = "/cbiconfig/cbi/api/customers/"
        cbiProfileEndpoint = "/profiles"
)

type IsolationProfile struct {
        ID               string            `json:"id,omitempty"`
        Name             string            `json:"name,omitempty"`
        Description      string            `json:"description,omitempty"`
        Enabled          bool              `json:"enabled,omitempty"`
        CreationTime     string            `json:"creationTime,omitempty"`
        ModifiedBy       string            `json:"modifiedBy,omitempty"`
        ModifiedTime     string            `json:"modifiedTime,omitempty"`
        CBITenantID      string            `json:"cbiTenantId,omitempty"`
        CBIProfileID     string            `json:"cbiProfileId,omitempty"`
        CBIURL           string            `json:"cbiUrl,omitempty"`
        BannerID         string            `json:"bannerId,omitempty"`
        SecurityControls *SecurityControls `json:"securityControls,omitempty"`
        IsDefault        bool              `json:"isDefault,omitempty"`
        Regions          []Regions         `json:"regions,omitempty"`
        RegionIDs        []string          `json:"regionIds,omitempty"`
        Href             string            `json:"href,omitempty"`
        UserExperience   *UserExperience   `json:"userExperience,omitempty"`
        Certificates     []Certificates    `json:"certificates,omitempty"`
        CertificateIDs   []string          `json:"certificateIds,omitempty"`
        Banner           *Banner           `json:"banner,omitempty"`
        DebugMode        *DebugMode        `json:"debugMode,omitempty"`
}

type Certificates struct {
        ID        string `json:"id,omitempty"`
        Name      string `json:"name,omitempty"`
        IsDefault bool   `json:"isDefault,omitempty"`
}

type Banner struct {
        ID string `json:"id,omitempty"`
}

type UserExperience struct {
        SessionPersistence  bool          `json:"sessionPersistence,omitempty"`
        BrowserInBrowser    bool          `json:"browserInBrowser,omitempty"`
        PersistIsolationBar bool          `json:"persistIsolationBar,omitempty"`
        ForwardToZia        *ForwardToZia `json:"forwardToZia,omitempty"`
}

type ForwardToZia struct {
        Enabled        bool   `json:"enabled,omitempty"`
        OrganizationID bool   `json:"organizationId,omitempty"`
        CloudName      string `json:"cloudName,omitempty"`
        PacFileUrl     string `json:"pacFileUrl,omitempty"`
}

type Watermark struct {
        Enabled       bool `json:"enabled,omitempty"`
        ShowUserID    bool `json:"showUserId,omitempty"`
        ShowTimestamp bool `json:"showTimestamp,omitempty"`
        ShowMessage   bool `json:"showMessage,omitempty"`
        Message       bool `json:"message,omitempty"`
}
type SecurityControls struct {
        DocumentViewer     bool      `json:"documentViewer,omitempty"`
        AllowPrinting      bool      `json:"allowPrinting,omitempty"`
        Watermark          Watermark `json:"watermark,omitempty"`
        FlattenedPdf       bool      `json:"flattenedPdf,omitempty"`
        UploadDownload     string    `json:"uploadDownload,omitempty"`
        RestrictKeystrokes bool      `json:"restrictKeystrokes,omitempty"`
        CopyPaste          string    `json:"copyPaste,omitempty"`
        LocalRender        bool      `json:"localRender,omitempty"`
}
type Regions struct {
        Name string `json:"name,omitempty"`
        ID   string `json:"id,omitempty"`
}

type DebugMode struct {
        Allowed      bool   `json:"allowed,omitempty"`
        FilePassword string `json:"filePassword,omitempty"`
}

func (service *Service) Get(profileID string) (*IsolationProfile, *http.Response, error) <span class="cov8" title="4">{
        v := new(IsolationProfile)
        relativeURL := fmt.Sprintf("%s/%s", cbiConfig+service.Client.Config.CustomerID+cbiProfileEndpoint, profileID)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, nil, nil, &amp;v)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>

        <span class="cov7" title="3">return v, resp, nil</span>
}

func (service *Service) GetByName(profileName string) (*IsolationProfile, *http.Response, error) <span class="cov1" title="1">{
        list, resp, err := service.GetAll()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">for _, profile := range list </span><span class="cov10" title="5">{
                if strings.EqualFold(profile.Name, profileName) </span><span class="cov1" title="1">{
                        return &amp;profile, resp, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, resp, fmt.Errorf("no isolation profile named '%s' was found", profileName)</span>
}

func (service *Service) Create(cbiProfile *IsolationProfile) (*IsolationProfile, *http.Response, error) <span class="cov1" title="1">{
        v := new(IsolationProfile)
        resp, err := service.Client.NewRequestDo("POST", cbiConfig+service.Client.Config.CustomerID+cbiProfileEndpoint, nil, cbiProfile, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return v, resp, nil</span>
}

func (service *Service) Update(segmentGroupId string, segmentGroupRequest *IsolationProfile) (*http.Response, error) <span class="cov1" title="1">{
        path := fmt.Sprintf("%v/%v", cbiConfig+service.Client.Config.CustomerID+cbiProfileEndpoint, segmentGroupId)
        resp, err := service.Client.NewRequestDo("PUT", path, nil, segmentGroupRequest, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return resp, err</span>
}

func (service *Service) Delete(profileID string) (*http.Response, error) <span class="cov1" title="1">{
        path := fmt.Sprintf("%v/%v", cbiConfig+service.Client.Config.CustomerID+cbiProfileEndpoint, profileID)
        resp, err := service.Client.NewRequestDo("DELETE", path, nil, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return resp, err</span>
}

func (service *Service) GetAll() ([]IsolationProfile, *http.Response, error) <span class="cov4" title="2">{
        relativeURL := cbiConfig + service.Client.Config.CustomerID + cbiProfileEndpoint
        var list []IsolationProfile
        resp, err := service.Client.NewRequestDo("GET", relativeURL, nil, nil, &amp;list)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov4" title="2">return list, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package cbiprofilecontroller

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client *zpa.Client
}

func New(c *zpa.Client) *Service <span class="cov8" title="1">{
        return &amp;Service{Client: c}
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package cbiregions

import (
        "fmt"
        "net/http"
        "strings"
)

const (
        cbiConfig          = "/cbiconfig/cbi/api/customers/"
        cbiRegionsEndpoint = "/regions"
)

type CBIRegions struct {
        ID   string `json:"id,omitempty"`
        Name string `json:"name,omitempty"`
}

// The current API does not seem to support search by Name
func (service *Service) GetByName(cbiRegionName string) (*CBIRegions, *http.Response, error) <span class="cov5" title="8">{
        list, resp, err := service.GetAll()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov5" title="8">for _, app := range list </span><span class="cov10" title="69">{
                if strings.EqualFold(app.Name, cbiRegionName) </span><span class="cov3" title="4">{
                        return &amp;app, resp, nil
                }</span>
        }
        <span class="cov3" title="4">return nil, resp, fmt.Errorf("no region named '%s' was found", cbiRegionName)</span>
}

func (service *Service) GetAll() ([]CBIRegions, *http.Response, error) <span class="cov5" title="9">{
        relativeURL := cbiConfig + service.Client.Config.CustomerID + cbiRegionsEndpoint
        var list []CBIRegions
        resp, err := service.Client.NewRequestDo("GET", relativeURL, nil, nil, &amp;list)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov5" title="9">return list, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package cbiregions

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client *zpa.Client
}

func New(c *zpa.Client) *Service <span class="cov10" title="3">{
        return &amp;Service{Client: c}
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package cbizpaprofile

import (
        "fmt"
        "net/http"
        "strings"
)

const (
        cbiConfig                 = "/cbiconfig/cbi/api/customers/"
        zpaProfileEndpoint string = "/zpaprofiles"
)

type ZPAProfiles struct {
        ID           string `json:"id,omitempty"`
        Name         string `json:"name,omitempty"`
        Description  string `json:"description,omitempty"`
        Enabled      bool   `json:"enabled"`
        CreationTime string `json:"creationTime,omitempty"`
        ModifiedBy   string `json:"modifiedBy,omitempty"`
        ModifiedTime string `json:"modifiedTime,omitempty"`
        CBITenantID  string `json:"cbiTenantId,omitempty"`
        CBIProfileID string `json:"cbiProfileId,omitempty"`
        CBIURL       string `json:"cbiUrl"`
}

// The current API does not seem to support search by ID
func (service *Service) Get(profileID string) (*ZPAProfiles, *http.Response, error) <span class="cov0" title="0">{
        // First get all the profiles
        profiles, resp, err := service.GetAll()
        if err != nil </span><span class="cov0" title="0">{
                return nil, resp, err
        }</span>

        // Loop through the profiles and find the one with the matching ID
        <span class="cov0" title="0">for _, profile := range profiles </span><span class="cov0" title="0">{
                if profile.ID == profileID </span><span class="cov0" title="0">{
                        return &amp;profile, resp, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, resp, fmt.Errorf("no isolation profile with ID '%s' was found", profileID)</span>
}

// The current API does not seem to support search by Name
func (service *Service) GetByName(profileName string) (*ZPAProfiles, *http.Response, error) <span class="cov7" title="18">{
        list, resp, err := service.GetAll()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov7" title="18">for _, app := range list </span><span class="cov10" title="50">{
                if strings.EqualFold(app.Name, profileName) </span><span class="cov7" title="16">{
                        return &amp;app, resp, nil
                }</span>
        }
        <span class="cov2" title="2">return nil, resp, fmt.Errorf("no zpa profile named '%s' was found", profileName)</span>
}

func (service *Service) GetAll() ([]ZPAProfiles, *http.Response, error) <span class="cov7" title="20">{
        relativeURL := cbiConfig + service.Client.Config.CustomerID + zpaProfileEndpoint
        var list []ZPAProfiles
        resp, err := service.Client.NewRequestDo("GET", relativeURL, nil, nil, &amp;list)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov7" title="20">return list, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package cbizpaprofile

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client *zpa.Client
}

func New(c *zpa.Client) *Service <span class="cov10" title="5">{
        return &amp;Service{Client: c}
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package isolationprofile

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfig               = "/mgmtconfig/v1/admin/customers/"
        isolationProfileEndpoint = "/isolation/profiles"
)

type IsolationProfile struct {
        ID                 string `json:"id,omitempty"`
        Name               string `json:"name,omitempty"`
        Description        string `json:"description,omitempty"`
        Enabled            bool   `json:"enabled"`
        CreationTime       string `json:"creationTime,omitempty"`
        ModifiedBy         string `json:"modifiedBy,omitempty"`
        ModifiedTime       string `json:"modifiedTime,omitempty"`
        IsolationProfileID string `json:"isolationProfileId,omitempty"`
        IsolationTenantID  string `json:"isolationTenantId,omitempty"`
        IsolationURL       string `json:"isolationUrl"`
}

func (service *Service) GetByName(profileName string) (*IsolationProfile, *http.Response, error) <span class="cov8" title="18">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + isolationProfileEndpoint

        // Set up custom filters for pagination
        filters := common.Filter{Search: profileName} // We only have the Search filter as per your example. You can add more filters if required.

        // Use the custom pagination function
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[IsolationProfile](service.Client, relativeURL, filters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // The rest remains the same as your logic for finding the profile by its name
        <span class="cov8" title="18">for _, profile := range list </span><span class="cov10" title="28">{
                if strings.EqualFold(profile.Name, profileName) </span><span class="cov8" title="16">{
                        return &amp;profile, resp, nil
                }</span>
        }
        <span class="cov2" title="2">return nil, resp, fmt.Errorf("no isolation profile named '%s' was found", profileName)</span>
}

func (service *Service) GetAll() ([]IsolationProfile, *http.Response, error) <span class="cov2" title="2">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + isolationProfileEndpoint
        list, resp, err := common.GetAllPagesGeneric[IsolationProfile](service.Client, relativeURL, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov2" title="2">return list, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package isolationprofile

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client *zpa.Client
}

func New(c *zpa.Client) *Service <span class="cov10" title="5">{
        return &amp;Service{Client: c}
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package cloudconnectorgroup

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client *zpa.Client
}

func New(c *zpa.Client) *Service <span class="cov0" title="0">{
        return &amp;Service{Client: c}
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package cloudconnectorgroup

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfig                  = "/mgmtconfig/v1/admin/customers/"
        cloudConnectorGroupEndpoint = "/cloudConnectorGroup"
)

type CloudConnectorGroup struct {
        CreationTime    string            `json:"creationTime,omitempty"`
        Description     string            `json:"description,omitempty"`
        CloudConnectors []CloudConnectors `json:"cloudConnectors,omitempty"`
        Enabled         bool              `json:"enabled,omitempty"`
        GeolocationID   string            `json:"geoLocationId,omitempty"`
        ID              string            `json:"id,omitempty"`
        ModifiedBy      string            `json:"modifiedBy,omitempty"`
        ModifiedTime    string            `json:"modifiedTime,omitempty"`
        Name            string            `json:"name,omitempty"`
        ZiaCloud        string            `json:"ziaCloud,omitempty"`
        ZiaOrgid        string            `json:"ziaOrgId,omitempty"`
}

type CloudConnectors struct {
        ID              string                 `json:"id,omitempty"`
        Name            string                 `json:"name,omitempty"`
        CreationTime    string                 `json:"creationTime,omitempty"`
        Description     string                 `json:"description,omitempty"`
        Enabled         bool                   `json:"enabled,omitempty"`
        Fingerprint     string                 `json:"fingerprint,omitempty"`
        IPACL           []string               `json:"ipAcl,omitempty"`
        IssuedCertID    string                 `json:"issuedCertId,omitempty"`
        ModifiedBy      string                 `json:"modifiedBy,omitempty"`
        ModifiedTime    string                 `json:"modifiedTime,omitempty"`
        SigningCert     map[string]interface{} `json:"signingCert,omitempty"`
        MicroTenantID   string                 `json:"microtenantId,omitempty"`
        MicroTenantName string                 `json:"microtenantName,omitempty"`
}

func (service *Service) Get(cloudConnectorGroupID string) (*CloudConnectorGroup, *http.Response, error) <span class="cov0" title="0">{
        v := new(CloudConnectorGroup)
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + cloudConnectorGroupEndpoint + "/" + cloudConnectorGroupID
        resp, err := service.Client.NewRequestDo("GET", relativeURL, nil, nil, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">return v, resp, nil</span>
}

func (service *Service) GetByName(cloudConnectorGroupName string) (*CloudConnectorGroup, *http.Response, error) <span class="cov0" title="0">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + cloudConnectorGroupEndpoint
        list, resp, err := common.GetAllPagesGeneric[CloudConnectorGroup](service.Client, relativeURL, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">for _, app := range list </span><span class="cov0" title="0">{
                if strings.EqualFold(app.Name, cloudConnectorGroupName) </span><span class="cov0" title="0">{
                        return &amp;app, resp, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, resp, fmt.Errorf("no application named '%s' was found", cloudConnectorGroupName)</span>
}

func (service *Service) GetAll() ([]CloudConnectorGroup, *http.Response, error) <span class="cov0" title="0">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + cloudConnectorGroupEndpoint
        list, resp, err := common.GetAllPagesGeneric[CloudConnectorGroup](service.Client, relativeURL, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return list, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package common

import (
        "fmt"
        "net/http"
        "net/url"
        "regexp"
        "strconv"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

const (
        DefaultPageSize = 500
)

type Pagination struct {
        PageSize        int     `json:"pagesize,omitempty" url:"pagesize,omitempty"`
        Page            int     `json:"page,omitempty" url:"page,omitempty"`
        Search          string  `json:"-" url:"-"`
        Search2         string  `json:"search,omitempty" url:"search,omitempty"`
        MicroTenantID   *string `url:"microtenantId,omitempty"`
        MicroTenantName *string `url:"-,omitempty"`
        SortBy          string  `json:"sortBy,omitempty" url:"sortBy,omitempty"`       // New field for sorting by attribute
        SortOrder       string  `json:"sortOrder,omitempty" url:"sortOrder,omitempty"` // New field for the sort order (ASC or DESC)
}

type Filter struct {
        Search          string  `url:"search,omitempty"`
        MicroTenantID   *string `url:"microtenantId,omitempty"`
        MicroTenantName *string `url:"-,omitempty"`
        SortBy          string  `url:"sortBy,omitempty"`          // New field for sorting by attribute
        SortOrder       string  `url:"sortOrder,omitempty"`       // New field for the sort order (ASC or DESC)
        ApplicationType string  `url:"applicationType,omitempty"` // New field for filtering by application type
        ExpandAll       bool    `url:"expandAll,omitempty"`       // New field for deciding whether to expand all attributes
}

type DeleteApplicationQueryParams struct {
        ForceDelete   bool    `json:"forceDelete,omitempty" url:"forceDelete,omitempty"`
        MicroTenantID *string `url:"microtenantId,omitempty"`
}
type NetworkPorts struct {
        From string `json:"from,omitempty"`
        To   string `json:"to,omitempty"`
}

// ZPA Inspection Rules
type Rules struct {
        Conditions []Conditions `json:"conditions,omitempty"`
        Names      string       `json:"names,omitempty"`
        Type       string       `json:"type,omitempty"`
        Version    string       `json:"version,omitempty"`
}

type Conditions struct {
        LHS string `json:"lhs,omitempty"`
        OP  string `json:"op,omitempty"`
        RHS string `json:"rhs,omitempty"`
}

type AssociatedProfileNames struct {
        ID   string `json:"id,omitempty"`
        Name string `json:"name,omitempty"`
}

// ZPA Common Structs to Avoid Repetion
type CommonConfigDetails struct {
        Name   string `json:"name,omitempty"`
        Reason string `json:"reason,omitempty"`
}

// RemoveCloudSuffix removes appended cloud name (zscalerthree.net) i.e "CrowdStrike_ZPA_Pre-ZTA (zscalerthree.net)"
func RemoveCloudSuffix(str string) string <span class="cov8" title="83">{
        reg := regexp.MustCompile(`(.*)[\s]+\([a-zA-Z0-9\-_\.]*\)[\s]*$`)
        res := reg.ReplaceAllString(str, "${1}")
        return strings.Trim(res, " ")
}</span>

func InList(list []string, item string) bool <span class="cov0" title="0">{
        for _, i := range list </span><span class="cov0" title="0">{
                if i == item </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func getAllPagesGenericWithCustomFilters[T any](client *zpa.Client, relativeURL string, page, pageSize int, filters Filter) (int, []T, *http.Response, error) <span class="cov10" title="288">{
        var v struct {
                TotalPages interface{} `json:"totalPages"`
                List       []T         `json:"list"`
        }
        resp, err := client.NewRequestDo("GET", relativeURL, Pagination{
                Search2:       filters.Search,
                MicroTenantID: filters.MicroTenantID,
                PageSize:      pageSize,
                Page:          page,
                SortBy:        filters.SortBy,
                SortOrder:     filters.SortOrder,
        }, nil, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return 0, nil, resp, err
        }</span>

        <span class="cov10" title="288">pages := fmt.Sprintf("%v", v.TotalPages)
        totalPages, _ := strconv.Atoi(pages)

        return totalPages, v.List, resp, nil</span>
}

func getAllPagesGeneric[T any](client *zpa.Client, relativeURL string, page, pageSize int, filters Filter) (int, []T, *http.Response, error) <span class="cov8" title="98">{
        return getAllPagesGenericWithCustomFilters[T](
                client,
                relativeURL,
                page,
                pageSize,
                filters,
        )
}</span>

// GetAllPagesGeneric fetches all resources instead of just one single page
func GetAllPagesGeneric[T any](client *zpa.Client, relativeURL, searchQuery string) ([]T, *http.Response, error) <span class="cov8" title="98">{
        searchQuery = url.QueryEscape(searchQuery)
        totalPages, result, resp, err := getAllPagesGeneric[T](client, relativeURL, 1, DefaultPageSize, Filter{Search: searchQuery})
        if err != nil </span><span class="cov0" title="0">{
                return nil, resp, err
        }</span>
        <span class="cov8" title="98">var l []T
        for page := 2; page &lt;= totalPages; page++ </span><span class="cov0" title="0">{
                totalPages, l, resp, err = getAllPagesGeneric[T](client, relativeURL, page, DefaultPageSize, Filter{Search: searchQuery})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, resp, err
                }</span>
                <span class="cov0" title="0">result = append(result, l...)</span>
        }

        <span class="cov8" title="98">return result, resp, nil</span>
}

type microTenantSample struct {
        ID   string `json:"id,omitempty"`
        Name string `json:"name,omitempty"`
}

func getMicroTenantByName(client *zpa.Client, microTenantName string) (*microTenantSample, *http.Response, error) <span class="cov0" title="0">{
        relativeURL := "/mgmtconfig/v1/admin/customers/" + client.Config.CustomerID + "/microtenants"
        list, resp, err := GetAllPagesGeneric[microTenantSample](client, relativeURL, microTenantName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, resp, err
        }</span>
        <span class="cov0" title="0">for _, app := range list </span><span class="cov0" title="0">{
                if strings.EqualFold(app.Name, microTenantName) </span><span class="cov0" title="0">{
                        return &amp;app, resp, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, resp, fmt.Errorf("no microtenant named '%s' was found", microTenantName)</span>
}

// GetAllPagesGenericWithCustomFilters fetches all resources instead of just one single page
func GetAllPagesGenericWithCustomFilters[T any](client *zpa.Client, relativeURL string, filters Filter) ([]T, *http.Response, error) <span class="cov9" title="176">{
        if (filters.MicroTenantID == nil || *filters.MicroTenantID == "") &amp;&amp; filters.MicroTenantName != nil &amp;&amp; *filters.MicroTenantName != "" </span><span class="cov0" title="0">{
                // get microtenant id by name
                mt, resp, err := getMicroTenantByName(client, *filters.MicroTenantName)
                if err == nil </span><span class="cov0" title="0">{
                        return nil, resp, err
                }</span>
                <span class="cov0" title="0">if mt != nil </span><span class="cov0" title="0">{
                        filters.MicroTenantID = &amp;mt.ID
                }</span>
        }

        // Updated filter search: replace spaces with '&amp;' for the API's search query format
        <span class="cov9" title="176">filters.Search = strings.ReplaceAll(filters.Search, " ", "&amp;")

        totalPages, result, resp, err := getAllPagesGenericWithCustomFilters[T](client, relativeURL, 1, DefaultPageSize, filters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, resp, err
        }</span>
        <span class="cov9" title="176">var l []T
        for page := 2; page &lt;= totalPages; page++ </span><span class="cov5" title="14">{
                totalPages, l, resp, err = getAllPagesGenericWithCustomFilters[T](client, relativeURL, page, DefaultPageSize, filters)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, resp, err
                }</span>
                <span class="cov5" title="14">result = append(result, l...)</span>
        }

        <span class="cov9" title="176">return result, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package customerversionprofile

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client *zpa.Client
}

func New(c *zpa.Client) *Service <span class="cov10" title="2">{
        return &amp;Service{Client: c}
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package customerversionprofile

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfig                     = "/mgmtconfig/v1/admin/customers/"
        customerVersionProfileEndpoint = "/visible/versionProfiles"
)

type CustomerVersionProfile struct {
        CreationTime                  string                        `json:"creationTime,omitempty"`
        CustomScopeCustomerIDs        []CustomScopeCustomerIDs      `json:"customScopeCustomerIds"`
        CustomScopeRequestCustomerIDs CustomScopeRequestCustomerIDs `json:"customScopeRequestCustomerIds"`
        CustomerID                    string                        `json:"customerId"`
        Description                   string                        `json:"description"`
        ID                            string                        `json:"id,omitempty"`
        ModifiedBy                    string                        `json:"modifiedBy"`
        ModifiedTime                  string                        `json:"modifiedTime"`
        Name                          string                        `json:"name"`
        UpgradePriority               string                        `json:"upgradePriority"`
        Versions                      []Versions                    `json:"versions"`
        VisibilityScope               string                        `json:"visibilityScope"`
}

type CustomScopeCustomerIDs struct {
        CustomerID           string `json:"customerId"`
        ExcludeConstellation bool   `json:"excludeConstellation"`
        Name                 string `json:"name"`
}

type CustomScopeRequestCustomerIDs struct {
        AddCustomerIDs    string `json:"addCustomerIds"`
        DeletecustomerIDs string `json:"deleteCustomerIds"`
}

type Versions struct {
        CreationTime             string `json:"creationTime,omitempty"`
        CustomerID               string `json:"customerId"`
        ID                       string `json:"id,omitempty"`
        ModifiedBy               string `json:"modifiedBy"`
        ModifiedTime             string `json:"modifiedTime"`
        Platform                 string `json:"platform"`
        RestartAfterUptimeInDays string `json:"restartAfterUptimeInDays"`
        Role                     string `json:"role"`
        Version                  string `json:"version"`
        VersionProfileGID        string `json:"version_profile_gid"`
}

func (service *Service) GetByName(versionProfileName string) (*CustomerVersionProfile, *http.Response, error) <span class="cov7" title="13">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + customerVersionProfileEndpoint
        list, resp, err := common.GetAllPagesGeneric[CustomerVersionProfile](service.Client, relativeURL, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov7" title="13">for _, app := range list </span><span class="cov10" title="34">{
                if strings.EqualFold(app.Name, versionProfileName) </span><span class="cov7" title="13">{
                        return &amp;app, resp, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, resp, fmt.Errorf("no version profile named '%s' was found", versionProfileName)</span>
}

func (service *Service) GetAll() ([]CustomerVersionProfile, *http.Response, error) <span class="cov1" title="1">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + customerVersionProfileEndpoint
        list, resp, err := common.GetAllPagesGeneric[CustomerVersionProfile](service.Client, relativeURL, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return list, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package emergencyaccess

import (
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

const (
        mgmtConfig              = "/mgmtconfig/v1/admin/customers/"
        emergencyAccessEndpoint = "/emergencyAccess/user"
)

type EmergencyAccess struct {
        ActivatedOn       string `json:"activatedOn,omitempty"`
        AllowedActivate   bool   `json:"allowedActivate"`
        AllowedDeactivate bool   `json:"allowedDeactivate"`
        EmailID           string `json:"emailId,omitempty"`
        FirstName         string `json:"firstName,omitempty"`
        LastLoginTime     string `json:"lastLoginTime,omitempty"`
        LastName          string `json:"lastName,omitempty"`
        UpdateEnabled     bool   `json:"updateEnabled"`
        UserID            string `json:"userId,omitempty"`
        UserStatus        string `json:"userStatus,omitempty"`
        ActivateNow       bool   `json:"activateNow,omitempty" url:"activateNow,omitempty"`
}

func (service *Service) Get(profileID string) (*EmergencyAccess, *http.Response, error) <span class="cov2" title="2">{
        v := new(EmergencyAccess)
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+emergencyAccessEndpoint, profileID)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, nil, nil, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov2" title="2">return v, resp, nil</span>
}

func (service *Service) GetByEmailID(emailID string) (*EmergencyAccess, *http.Response, error) <span class="cov1" title="1">{
        // Use the GetAll function to retrieve all EmergencyAccess records
        list, resp, err := service.GetAll()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // Filter the retrieved list for the specific emailID
        <span class="cov1" title="1">for _, emgAccess := range list </span><span class="cov10" title="282">{
                if strings.EqualFold(emgAccess.EmailID, emailID) </span><span class="cov1" title="1">{
                        return &amp;emgAccess, resp, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, resp, fmt.Errorf("no emergency access record found with email ID '%s'", emailID)</span>
}

func (service *Service) Create(emergencyAccess *EmergencyAccess) (*EmergencyAccess, *http.Response, error) <span class="cov1" title="1">{
        emergencyAccess.ActivateNow = false
        relativeURL := fmt.Sprintf("%s%s%s", mgmtConfig, service.Client.Config.CustomerID, emergencyAccessEndpoint)
        v := new(EmergencyAccess)
        resp, err := service.Client.NewRequestDo("POST", relativeURL, nil, emergencyAccess, v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return v, resp, nil</span>
}

func (service *Service) Update(userID string, emergencyAccess *EmergencyAccess) (*http.Response, error) <span class="cov1" title="1">{
        path := fmt.Sprintf("%v/%v", mgmtConfig+service.Client.Config.CustomerID+emergencyAccessEndpoint, userID)
        resp, err := service.Client.NewRequestDo("PUT", path, nil, emergencyAccess, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return resp, err</span>
}

// PUT - /mgmtconfig/v1/admin/customers/{customerId}/emergencyAccess/user/{userId}/activate
func (service *Service) Activate(userID string) (*http.Response, error) <span class="cov1" title="1">{
        path := fmt.Sprintf("%s/%s/activate", mgmtConfig+service.Client.Config.CustomerID+emergencyAccessEndpoint, userID)
        resp, err := service.Client.NewRequestDo("PUT", path, nil, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return resp, nil</span>
}

// PUT - /mgmtconfig/v1/admin/customers/{customerId}/emergencyAccess/user/{userId}/deactivate
func (service *Service) Deactivate(userID string) (*http.Response, error) <span class="cov2" title="2">{
        path := fmt.Sprintf("%s/%s/deactivate", mgmtConfig+service.Client.Config.CustomerID+emergencyAccessEndpoint, userID)
        resp, err := service.Client.NewRequestDo("PUT", path, nil, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov2" title="2">return resp, nil</span>
}

func (service *Service) GetAll() ([]EmergencyAccess, *http.Response, error) <span class="cov2" title="2">{
        relativeURL := fmt.Sprintf("%s%s%s", mgmtConfig, service.Client.Config.CustomerID, emergencyAccessEndpoint+"s") // Correct endpoint
        pageSize := 500                                                                                                 // Define the pageSize as needed
        initialPageId := ""                                                                                             // Start without a pageId or as required

        return GetAllEmergencyAccessUsers(service.Client, relativeURL, pageSize, initialPageId)
}</span>

func fetchEmergencyAccessUsersPage(client *zpa.Client, fullURL string) (*http.Response, error) <span class="cov3" title="4">{
        return client.NewRequestDo("GET", fullURL, nil, nil, nil)
}</span>

func GetAllEmergencyAccessUsers(client *zpa.Client, baseRelativeURL string, pageSize int, initialPageId string) ([]EmergencyAccess, *http.Response, error) <span class="cov2" title="2">{
        var allUsers []EmergencyAccess
        var lastResponse *http.Response
        pageId := initialPageId

        for </span><span class="cov3" title="4">{
                // Construct the URL for each request to avoid duplication and encoding issues
                var fullURL string
                if pageId != "" </span><span class="cov2" title="2">{
                        fullURL = fmt.Sprintf("%s?pageSize=%d&amp;pageId=%s", baseRelativeURL, pageSize, pageId)
                }</span> else<span class="cov2" title="2"> {
                        fullURL = fmt.Sprintf("%s?pageSize=%d", baseRelativeURL, pageSize)
                }</span>

                <span class="cov3" title="4">resp, err := fetchEmergencyAccessUsersPage(client, fullURL)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, lastResponse, err
                }</span>
                // Assume this struct matches the expected JSON response structure
                <span class="cov3" title="4">var pageData struct {
                        Items    []EmergencyAccess `json:"items"`
                        NextPage string            `json:"nextPage"`
                }

                bodyBytes, err := ioutil.ReadAll(resp.Body)
                resp.Body.Close() // Ensure the body is always closed after reading
                if err != nil </span><span class="cov0" title="0">{
                        return nil, resp, fmt.Errorf("error reading response body: %w", err)
                }</span>

                <span class="cov3" title="4">if err := json.Unmarshal(bodyBytes, &amp;pageData); err != nil </span><span class="cov0" title="0">{
                        return nil, resp, fmt.Errorf("error unmarshalling response: %w", err)
                }</span>

                <span class="cov3" title="4">allUsers = append(allUsers, pageData.Items...)
                if pageData.NextPage == "" </span><span class="cov2" title="2">{
                        break</span> // Exit the loop if there are no more pages
                }

                // Update pageId for the next iteration
                <span class="cov2" title="2">pageId = pageData.NextPage
                lastResponse = resp</span>
        }

        <span class="cov2" title="2">return allUsers, lastResponse, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package emergencyaccess

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client *zpa.Client
}

func New(c *zpa.Client) *Service <span class="cov8" title="1">{
        return &amp;Service{Client: c}
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package enrollmentcert

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client        *zpa.Client
        microTenantID *string
}

func New(c *zpa.Client) *Service <span class="cov10" title="3">{
        return &amp;Service{Client: c}
}</span>

func (service *Service) WithMicroTenant(microTenantID string) *Service <span class="cov0" title="0">{
        var mid *string
        if microTenantID != "" </span><span class="cov0" title="0">{
                mid_ := microTenantID
                mid = &amp;mid_
        }</span>
        <span class="cov0" title="0">return &amp;Service{
                Client:        service.Client,
                microTenantID: mid,
        }</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package enrollmentcert

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfigV1           = "/mgmtconfig/v1/admin/customers/"
        mgmtConfigV2           = "/mgmtconfig/v2/admin/customers/"
        enrollmentCertEndpoint = "/enrollmentCert"
)

type EnrollmentCert struct {
        AllowSigning            bool   `json:"allowSigning,omitempty"`
        Cname                   string `json:"cName,omitempty"`
        Certificate             string `json:"certificate,omitempty"`
        ClientCertType          string `json:"clientCertType,omitempty"`
        CreationTime            string `json:"creationTime,omitempty"`
        CSR                     string `json:"csr,omitempty"`
        Description             string `json:"description,omitempty"`
        ID                      string `json:"id,omitempty"`
        IssuedBy                string `json:"issuedBy,omitempty"`
        IssuedTo                string `json:"issuedTo,omitempty"`
        ModifiedBy              string `json:"modifiedBy,omitempty"`
        ModifiedTime            string `json:"modifiedTime,omitempty"`
        Name                    string `json:"name,omitempty"`
        ParentCertID            string `json:"parentCertId,omitempty"`
        ParentCertName          string `json:"parentCertName,omitempty"`
        PrivateKey              string `json:"privateKey,omitempty"`
        PrivateKeyPresent       bool   `json:"privateKeyPresent,omitempty"`
        SerialNo                string `json:"serialNo,omitempty"`
        ValidFromInEpochSec     string `json:"validFromInEpochSec,omitempty"`
        ValidToInEpochSec       string `json:"validToInEpochSec,omitempty"`
        ZrsaEncryptedPrivateKey string `json:"zrsaencryptedprivatekey,omitempty"`
        ZrsaEncryptedSessionKey string `json:"zrsaencryptedsessionkey,omitempty"`
        MicrotenantID           string `json:"microtenantId,omitempty"`
}

func (service *Service) Get(id string) (*EnrollmentCert, *http.Response, error) <span class="cov1" title="1">{
        v := new(EnrollmentCert)
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfigV1+service.Client.Config.CustomerID+enrollmentCertEndpoint, id)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, common.Filter{MicroTenantID: service.microTenantID}, nil, v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return v, resp, nil</span>
}

func (service *Service) GetByName(certName string) (*EnrollmentCert, *http.Response, error) <span class="cov10" title="21">{
        relativeURL := mgmtConfigV2 + service.Client.Config.CustomerID + enrollmentCertEndpoint
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[EnrollmentCert](service.Client, relativeURL, common.Filter{Search: certName, MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov10" title="21">for _, cert := range list </span><span class="cov9" title="20">{
                if strings.EqualFold(cert.Name, certName) </span><span class="cov9" title="20">{
                        return &amp;cert, resp, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, resp, fmt.Errorf("no signing certificate named '%s' was found", certName)</span>
}

func (service *Service) GetAll() ([]EnrollmentCert, *http.Response, error) <span class="cov1" title="1">{
        relativeURL := mgmtConfigV2 + service.Client.Config.CustomerID + enrollmentCertEndpoint
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[EnrollmentCert](service.Client, relativeURL, common.Filter{MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return list, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package idpcontroller

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client *zpa.Client
}

func New(c *zpa.Client) *Service <span class="cov10" title="3">{
        return &amp;Service{Client: c}
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package idpcontroller

import (
        "fmt"
        "net/http"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfigV1          = "/mgmtconfig/v1/admin/customers/"
        mgmtConfigV2          = "/mgmtconfig/v2/admin/customers/"
        idpControllerEndpoint = "/idp"
)

type IdpController struct {
        AdminSpSigningCertID        string         `json:"adminSpSigningCertId,omitempty"`
        AutoProvision               string         `json:"autoProvision,omitempty"`
        CreationTime                string         `json:"creationTime,omitempty"`
        Description                 string         `json:"description,omitempty"`
        DisableSamlBasedPolicy      bool           `json:"disableSamlBasedPolicy"`
        Domainlist                  []string       `json:"domainList,omitempty"`
        EnableScimBasedPolicy       bool           `json:"enableScimBasedPolicy"`
        EnableArbitraryAuthDomains  string         `json:"enableArbitraryAuthDomains"`
        Enabled                     bool           `json:"enabled"`
        ForceAuth                   bool           `json:"forceAuth"`
        ID                          string         `json:"id,omitempty"`
        IdpEntityID                 string         `json:"idpEntityId,omitempty"`
        LoginHint                   bool           `json:"loginHint,omitempty"`
        LoginNameAttribute          string         `json:"loginNameAttribute,omitempty"`
        LoginURL                    string         `json:"loginUrl,omitempty"`
        ModifiedBy                  string         `json:"modifiedBy,omitempty"`
        ModifiedTime                string         `json:"modifiedTime,omitempty"`
        Name                        string         `json:"name,omitempty"`
        ReauthOnUserUpdate          bool           `json:"reauthOnUserUpdate"`
        RedirectBinding             bool           `json:"redirectBinding"`
        ScimEnabled                 bool           `json:"scimEnabled"`
        ScimServiceProviderEndpoint string         `json:"scimServiceProviderEndpoint,omitempty"`
        ScimSharedSecretExists      bool           `json:"scimSharedSecretExists,omitempty"`
        SignSamlRequest             string         `json:"signSamlRequest,,omitempty"`
        SsoType                     []string       `json:"ssoType,omitempty"`
        UseCustomSpMetadata         bool           `json:"useCustomSPMetadata"`
        UserSpSigningCertID         string         `json:"userSpSigningCertId,omitempty"`
        AdminMetadata               *AdminMetadata `json:"adminMetadata,omitempty"`
        UserMetadata                *UserMetadata  `json:"userMetadata,omitempty"`
}

type AdminMetadata struct {
        CertificateURL string `json:"certificateUrl"`
        SpBaseURL      string `json:"spBaseUrl"`
        SpEntityID     string `json:"spEntityId"`
        SpMetadataURL  string `json:"spMetadataUrl"`
        SpPostURL      string `json:"spPostUrl"`
}

type UserMetadata struct {
        CertificateURL string `json:"certificateUrl,omitempty"`
        SpBaseURL      string `json:"spBaseUrl"`
        SpEntityID     string `json:"spEntityId,omitempty"`
        SpMetadataURL  string `json:"spMetadataUrl,omitempty"`
        SpPostURL      string `json:"spPostUrl,omitempty"`
}

func (service *Service) Get(IdpID string) (*IdpController, *http.Response, error) <span class="cov1" title="1">{
        v := new(IdpController)
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfigV1+service.Client.Config.CustomerID+idpControllerEndpoint, IdpID)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, nil, nil, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return v, resp, nil</span>
}

func (service *Service) GetByName(idpName string) (*IdpController, *http.Response, error) <span class="cov7" title="3">{
        relativeURL := fmt.Sprintf(mgmtConfigV2 + service.Client.Config.CustomerID + idpControllerEndpoint)
        list, resp, err := common.GetAllPagesGeneric[IdpController](service.Client, relativeURL, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov7" title="3">for _, idpController := range list </span><span class="cov10" title="5">{
                if idpController.Name == idpName </span><span class="cov1" title="1">{
                        return &amp;idpController, resp, nil
                }</span>
        }
        <span class="cov4" title="2">return nil, resp, fmt.Errorf("no Idp-Controller named '%s' was found", idpName)</span>
}

func (service *Service) GetAll() ([]IdpController, *http.Response, error) <span class="cov4" title="2">{
        relativeURL := fmt.Sprintf(mgmtConfigV2 + service.Client.Config.CustomerID + idpControllerEndpoint)
        list, resp, err := common.GetAllPagesGeneric[IdpController](service.Client, relativeURL, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov4" title="2">return list, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package inspection_custom_controls

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client *zpa.Client
}

func New(c *zpa.Client) *Service <span class="cov10" title="5">{
        return &amp;Service{Client: c}
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package inspection_custom_controls

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfig             = "/mgmtconfig/v1/admin/customers/"
        customControlsEndpoint = "/inspectionControls/custom"
)

type InspectionCustomControl struct {
        ID                               string                   `json:"id,omitempty"`
        Action                           string                   `json:"action,omitempty"`
        ActionValue                      string                   `json:"actionValue,omitempty"`
        AssociatedInspectionProfileNames []AssociatedProfileNames `json:"associatedInspectionProfileNames,omitempty"`
        Rules                            []Rules                  `json:"rules,omitempty"`
        ControlNumber                    string                   `json:"controlNumber,omitempty"`
        ControlType                      string                   `json:"controlType,omitempty"`
        ControlRuleJson                  string                   `json:"controlRuleJson,omitempty"`
        CreationTime                     string                   `json:"creationTime,omitempty"`
        DefaultAction                    string                   `json:"defaultAction,omitempty"`
        DefaultActionValue               string                   `json:"defaultActionValue,omitempty"`
        Description                      string                   `json:"description,omitempty"`
        ModifiedBy                       string                   `json:"modifiedBy,omitempty"`
        ModifiedTime                     string                   `json:"modifiedTime,omitempty"`
        Name                             string                   `json:"name,omitempty"`
        ParanoiaLevel                    string                   `json:"paranoiaLevel,omitempty"`
        ProtocolType                     string                   `json:"protocolType,omitempty"`
        Severity                         string                   `json:"severity,omitempty"`
        Type                             string                   `json:"type,omitempty"`
        Version                          string                   `json:"version,omitempty"`
}

type Rules struct {
        Conditions []Conditions `json:"conditions,omitempty"`
        Names      []string     `json:"names,omitempty"`
        Type       string       `json:"type,omitempty"`
}

type Conditions struct {
        LHS string `json:"lhs,omitempty"`
        OP  string `json:"op,omitempty"`
        RHS string `json:"rhs,omitempty"`
}

type AssociatedProfileNames struct {
        ID   string `json:"id,omitempty"`
        Name string `json:"name,omitempty"`
}

func unmarshalRulesJson(rulesJsonStr string) ([]Rules, error) <span class="cov8" title="3">{
        var rules []Rules
        err := json.Unmarshal([]byte(rulesJsonStr), &amp;rules)
        return rules, err
}</span>

func (service *Service) Get(customID string) (*InspectionCustomControl, *http.Response, error) <span class="cov10" title="4">{
        v := new(InspectionCustomControl)
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+customControlsEndpoint, customID)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, nil, nil, &amp;v)
        if err != nil </span><span class="cov5" title="2">{
                return nil, nil, err
        }</span>
        <span class="cov5" title="2">rules, err := unmarshalRulesJson(v.ControlRuleJson)
        v.Rules = rules
        return v, resp, err</span>
}

func (service *Service) GetByName(controlName string) (*InspectionCustomControl, *http.Response, error) <span class="cov5" title="2">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + customControlsEndpoint
        list, resp, err := common.GetAllPagesGeneric[InspectionCustomControl](service.Client, relativeURL, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov5" title="2">for _, control := range list </span><span class="cov1" title="1">{
                if strings.EqualFold(control.Name, controlName) </span><span class="cov1" title="1">{
                        rules, err := unmarshalRulesJson(control.ControlRuleJson)
                        control.Rules = rules
                        return &amp;control, resp, err
                }</span>
        }
        <span class="cov1" title="1">return nil, resp, fmt.Errorf("no custom inspection control named '%s' was found", controlName)</span>
}

func (service *Service) Create(customControls InspectionCustomControl) (*InspectionCustomControl, *http.Response, error) <span class="cov1" title="1">{
        v := new(InspectionCustomControl)
        resp, err := service.Client.NewRequestDo("POST", mgmtConfig+service.Client.Config.CustomerID+customControlsEndpoint, nil, customControls, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return v, resp, nil</span>
}

func (service *Service) Update(customID string, customControls *InspectionCustomControl) (*http.Response, error) <span class="cov5" title="2">{
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+customControlsEndpoint, customID)
        resp, err := service.Client.NewRequestDo("PUT", relativeURL, nil, customControls, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp, err</span>
}

func (service *Service) Delete(customID string) (*http.Response, error) <span class="cov5" title="2">{
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+customControlsEndpoint, customID)
        resp, err := service.Client.NewRequestDo("DELETE", relativeURL, nil, nil, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp, nil</span>
}

func (service *Service) GetAll() ([]InspectionCustomControl, *http.Response, error) <span class="cov1" title="1">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + customControlsEndpoint
        list, resp, err := common.GetAllPagesGeneric[InspectionCustomControl](service.Client, relativeURL, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return list, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package inspection_predefined_controls

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client *zpa.Client
}

func New(c *zpa.Client) *Service <span class="cov10" title="3">{
        return &amp;Service{Client: c}
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package inspection_predefined_controls

import (
        "fmt"
        "net/http"
        "net/url"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfig           = "/mgmtconfig/v1/admin/customers/"
        predControlsEndpoint = "/inspectionControls/predefined"
)

type PredefinedControls struct {
        ID                               string                          `json:"id,omitempty"`
        Name                             string                          `json:"name,omitempty"`
        Action                           string                          `json:"action,omitempty"`
        ActionValue                      string                          `json:"actionValue,omitempty"`
        AssociatedInspectionProfileNames []common.AssociatedProfileNames `json:"associatedInspectionProfileNames,omitempty"`
        Attachment                       string                          `json:"attachment,omitempty"`
        ControlGroup                     string                          `json:"controlGroup,omitempty"`
        ControlType                      string                          `json:"controlType,omitempty"`
        ControlNumber                    string                          `json:"controlNumber,omitempty"`
        CreationTime                     string                          `json:"creationTime,omitempty"`
        DefaultAction                    string                          `json:"defaultAction,omitempty"`
        DefaultActionValue               string                          `json:"defaultActionValue,omitempty"`
        Description                      string                          `json:"description,omitempty"`
        ModifiedBy                       string                          `json:"modifiedBy,omitempty"`
        ModifiedTime                     string                          `json:"modifiedTime,omitempty"`
        ParanoiaLevel                    string                          `json:"paranoiaLevel,omitempty"`
        ProtocolType                     string                          `json:"protocolType,omitempty"`
        Severity                         string                          `json:"severity,omitempty"`
        Version                          string                          `json:"version,omitempty"`
}

type ControlGroupItem struct {
        ControlGroup                 string               `json:"controlGroup,omitempty"`
        PredefinedInspectionControls []PredefinedControls `json:"predefinedInspectionControls,omitempty"`
        DefaultGroup                 bool                 `json:"defaultGroup,omitempty"`
}

type ControlsRequestFilters struct {
        Version  string `url:"version,omitempty"`
        Search   string `url:"search,omitempty"`
        PageSize int    `url:"pagesize,omitempty"`
        Page     int    `url:"page,omitempty"`
}

// Get Predefined Controls by ID
// https://help.zscaler.com/zpa/api-reference#/inspection-control-controller/getPredefinedControlById
func (service *Service) Get(controlID string) (*PredefinedControls, *http.Response, error) <span class="cov0" title="0">{
        v := new(PredefinedControls)
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+predControlsEndpoint, controlID)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, nil, nil, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">return v, resp, nil</span>
}

func (service *Service) GetAll(version string) ([]PredefinedControls, error) <span class="cov2" title="2">{
        v := []ControlGroupItem{}
        relativeURL := fmt.Sprintf(mgmtConfig + service.Client.Config.CustomerID + predControlsEndpoint)
        _, err := service.Client.NewRequestDo("GET", relativeURL, struct {
                Version string `url:"version"`
        }{Version: version}, nil, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov2" title="2">predefinedControls := []PredefinedControls{}
        for _, group := range v </span><span class="cov7" title="26">{
                predefinedControls = append(predefinedControls, group.PredefinedInspectionControls...)
        }</span>
        <span class="cov2" title="2">return predefinedControls, nil</span>
}

func (service *Service) GetByName(name, version string) (*PredefinedControls, *http.Response, error) <span class="cov1" title="1">{
        relativeURL := fmt.Sprintf(mgmtConfig + service.Client.Config.CustomerID + predControlsEndpoint)
        searchQuery := strings.TrimSpace(name)
        searchQuery = strings.Split(searchQuery, " ")[0]
        searchQuery = strings.TrimSpace(searchQuery)
        searchQuery = url.QueryEscape(searchQuery)
        var v []ControlGroupItem
        resp, err := service.Client.NewRequestDo("GET", relativeURL, ControlsRequestFilters{
                Version: version,
                Search:  searchQuery,
        }, nil, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">for _, group := range v </span><span class="cov1" title="1">{
                for _, control := range group.PredefinedInspectionControls </span><span class="cov1" title="1">{
                        if strings.EqualFold(control.Name, name) </span><span class="cov1" title="1">{
                                service.Client.Config.Logger.Printf("[INFO] got predefined controls:%#v", v)
                                return &amp;control, resp, nil
                        }</span>
                }
        }
        <span class="cov0" title="0">service.Client.Config.Logger.Printf("[ERROR] no predefined control named '%s' found", name)
        return nil, resp, fmt.Errorf("no predefined control named '%s' found", name)</span>
}

func (service *Service) GetAllByGroup(version, groupName string) ([]PredefinedControls, error) <span class="cov6" title="14">{
        relativeURL := fmt.Sprintf(mgmtConfig + service.Client.Config.CustomerID + predControlsEndpoint)
        var v []ControlGroupItem
        _, err := service.Client.NewRequestDo("GET", relativeURL, ControlsRequestFilters{
                Version: version,
        }, nil, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="14">for _, group := range v </span><span class="cov10" title="92">{
                if strings.EqualFold(group.ControlGroup, groupName) </span><span class="cov6" title="14">{
                        return group.PredefinedInspectionControls, nil
                }</span>
        }
        <span class="cov0" title="0">return []PredefinedControls{}, nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package inspection_profile

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client *zpa.Client
}

func New(c *zpa.Client) *Service <span class="cov10" title="5">{
        return &amp;Service{Client: c}
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package inspection_profile

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfig                = "/mgmtconfig/v1/admin/customers/"
        inspectionProfileEndpoint = "/inspectionProfile"
        defaultVersion            = "OWASP_CRS/3.3.0"
)

type PatchQuery struct {
        Version string `json:"version,omitempty" url:"version,omitempty"`
}

type InspectionProfile struct {
        ID                                string                    `json:"id,omitempty"`
        CommonGlobalOverrideActionsConfig map[string]interface{}    `json:"commonGlobalOverrideActionsConfig,omitempty"`
        CreationTime                      string                    `json:"creationTime,omitempty"`
        ZSDefinedControlChoice            string                    `json:"zsDefinedControlChoice,omitempty"`
        Description                       string                    `json:"description,omitempty"`
        GlobalControlActions              []string                  `json:"globalControlActions,omitempty"`
        IncarnationNumber                 string                    `json:"incarnationNumber,omitempty"`
        ModifiedBy                        string                    `json:"modifiedBy,omitempty"`
        ModifiedTime                      string                    `json:"modifiedTime,omitempty"`
        Name                              string                    `json:"name,omitempty"`
        ParanoiaLevel                     string                    `json:"paranoiaLevel,omitempty"`
        PredefinedControlsVersion         string                    `json:"predefinedControlsVersion,omitempty"`
        CheckControlDeploymentStatus      bool                      `json:"checkControlDeploymentStatus,omitempty"`
        ControlInfoResource               []ControlInfoResource     `json:"controlsInfo,omitempty"`
        CustomControls                    []InspectionCustomControl `json:"customControls"`
        PredefinedControls                []CustomCommonControls    `json:"predefinedControls"`
        WebSocketControls                 []CustomCommonControls    `json:"websocketControls"`
        ThreatLabzControls                []ThreatLabzControls      `json:"threatlabzControls"`
}

type ControlInfoResource struct {
        ControlType string `json:"controlType,omitempty"`
        Count       string `json:"count,omitempty"`
}

type InspectionCustomControl struct {
        Action                           string                   `json:"action,omitempty"`
        ActionValue                      string                   `json:"actionValue,omitempty"`
        AssociatedInspectionProfileNames []AssociatedProfileNames `json:"associatedInspectionProfileNames,omitempty"`
        Rules                            []common.Rules           `json:"rules,omitempty"`
        ControlNumber                    string                   `json:"controlNumber,omitempty"`
        ControlRuleJson                  string                   `json:"controlRuleJson,omitempty"`
        ControlType                      string                   `json:"controlType,omitempty"`
        CreationTime                     string                   `json:"creationTime,omitempty"`
        DefaultAction                    string                   `json:"defaultAction,omitempty"`
        DefaultActionValue               string                   `json:"defaultActionValue,omitempty"`
        Description                      string                   `json:"description,omitempty"`
        ID                               string                   `json:"id,omitempty"`
        ModifiedBy                       string                   `json:"modifiedBy,omitempty"`
        ModifiedTime                     string                   `json:"modifiedTime,omitempty"`
        Name                             string                   `json:"name,omitempty"`
        ProtocolType                     string                   `json:"protocolType,omitempty"`
        ParanoiaLevel                    string                   `json:"paranoiaLevel,omitempty"`
        Severity                         string                   `json:"severity,omitempty"`
        Type                             string                   `json:"type,omitempty"`
        Version                          string                   `json:"version,omitempty"`
}

type CustomCommonControls struct {
        ID                               string                   `json:"id,omitempty"`
        Name                             string                   `json:"name,omitempty"`
        Action                           string                   `json:"action,omitempty"`
        ActionValue                      string                   `json:"actionValue,omitempty"`
        AssociatedInspectionProfileNames []AssociatedProfileNames `json:"associatedInspectionProfileNames,omitempty"`
        Attachment                       string                   `json:"attachment,omitempty"`
        ControlGroup                     string                   `json:"controlGroup,omitempty"`
        ControlNumber                    string                   `json:"controlNumber,omitempty"`
        ControlType                      string                   `json:"controlType,omitempty"`
        CreationTime                     string                   `json:"creationTime,omitempty"`
        DefaultAction                    string                   `json:"defaultAction,omitempty"`
        DefaultActionValue               string                   `json:"defaultActionValue,omitempty"`
        Description                      string                   `json:"description,omitempty"`
        ModifiedBy                       string                   `json:"modifiedBy,omitempty"`
        ModifiedTime                     string                   `json:"modifiedTime,omitempty"`
        ParanoiaLevel                    string                   `json:"paranoiaLevel,omitempty"`
        ProtocolType                     string                   `json:"protocolType,omitempty"`
        Severity                         string                   `json:"severity,omitempty"`
        Version                          string                   `json:"version,omitempty"`
}

type AssociatedProfileNames struct {
        ID   string `json:"id,omitempty"`
        Name string `json:"name,omitempty"`
}

type AssociatedCustomers struct {
        CustomerID           string `json:"customerId,omitempty"`
        ExcludeConstellation bool   `json:"excludeConstellation,omitempty"`
        IsPartner            bool   `json:"isPartner,omitempty"`
        Name                 string `json:"name,omitempty"`
}

type ThreatLabzControls struct {
        ID                               string                   `json:"id,omitempty"`
        Name                             string                   `json:"name,omitempty"`
        Enabled                          bool                     `json:"enabled,omitempty"`
        Action                           string                   `json:"action,omitempty"`
        ActionValue                      string                   `json:"actionValue,omitempty"`
        AssociatedCustomers              []AssociatedCustomers    `json:"associatedCustomers,omitempty"`
        AssociatedInspectionProfileNames []AssociatedProfileNames `json:"associatedInspectionProfileNames,omitempty"`
        Attachment                       string                   `json:"attachment,omitempty"`
        ControlGroup                     string                   `json:"controlGroup,omitempty"`
        ControlNumber                    string                   `json:"controlNumber,omitempty"`
        ControlType                      string                   `json:"controlType,omitempty"`
        CreationTime                     string                   `json:"creationTime,omitempty"`
        DefaultAction                    string                   `json:"defaultAction,omitempty"`
        DefaultActionValue               string                   `json:"defaultActionValue,omitempty"`
        Description                      string                   `json:"description,omitempty"`
        ModifiedBy                       string                   `json:"modifiedBy,omitempty"`
        ModifiedTime                     string                   `json:"modifiedTime,omitempty"`
        ParanoiaLevel                    string                   `json:"paranoiaLevel,omitempty"`
        ProtocolType                     string                   `json:"protocolType,omitempty"`
        Severity                         string                   `json:"severity,omitempty"`
        Version                          string                   `json:"version,omitempty"`
        EngineVersion                    string                   `json:"engineVersion,omitempty"`
        LastDeploymentTime               string                   `json:"lastDeploymentTime,omitempty"`
        RuleDeploymentState              string                   `json:"ruleDeploymentState,omitempty"`
        RuleMetadata                     string                   `json:"ruleMetadata,omitempty"`
        RuleProcessor                    string                   `json:"ruleProcessor,omitempty"`
        RulesetName                      string                   `json:"rulesetName,omitempty"`
        RulesetVersion                   string                   `json:"rulesetVersion,omitempty"`
        ZscalerInfoUrl                   string                   `json:"zscalerInfoUrl,omitempty"`
}

func (service *Service) Get(profileID string) (*InspectionProfile, *http.Response, error) <span class="cov10" title="7">{
        v := new(InspectionProfile)
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+inspectionProfileEndpoint, profileID)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, nil, nil, &amp;v)
        if err != nil </span><span class="cov7" title="4">{
                return nil, nil, err
        }</span>

        <span class="cov6" title="3">return v, resp, nil</span>
}

func setVersion(inspectionProfile *InspectionProfile) <span class="cov6" title="3">{
        // make sure to set version
        if inspectionProfile.PredefinedControlsVersion == "" </span><span class="cov4" title="2">{
                found := false
                for _, control := range inspectionProfile.PredefinedControls </span><span class="cov1" title="1">{
                        if control.Version != "" </span><span class="cov1" title="1">{
                                found = true
                                inspectionProfile.PredefinedControlsVersion = control.Version
                                break</span>
                        }
                }
                <span class="cov4" title="2">if !found </span><span class="cov1" title="1">{
                        inspectionProfile.PredefinedControlsVersion = defaultVersion
                }</span>
        }
}

func (service *Service) GetByName(profileName string) (*InspectionProfile, *http.Response, error) <span class="cov4" title="2">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + inspectionProfileEndpoint
        list, resp, err := common.GetAllPagesGeneric[InspectionProfile](service.Client, relativeURL, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov4" title="2">for _, inspection := range list </span><span class="cov8" title="5">{
                if strings.EqualFold(inspection.Name, profileName) </span><span class="cov1" title="1">{
                        return &amp;inspection, resp, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, resp, fmt.Errorf("no inspection profile named '%s' was found", profileName)</span>
}

func (service *Service) Create(inspectionProfile InspectionProfile) (*InspectionProfile, *http.Response, error) <span class="cov1" title="1">{
        setVersion(&amp;inspectionProfile)
        v := new(InspectionProfile)
        resp, err := service.Client.NewRequestDo("POST", mgmtConfig+service.Client.Config.CustomerID+inspectionProfileEndpoint, nil, inspectionProfile, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return v, resp, nil</span>
}

func (service *Service) Update(profileID string, inspectionProfile *InspectionProfile) (*http.Response, error) <span class="cov4" title="2">{
        setVersion(inspectionProfile)
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+inspectionProfileEndpoint, profileID)
        resp, err := service.Client.NewRequestDo("PUT", relativeURL, nil, inspectionProfile, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp, err</span>
}

func (service *Service) PutAssociate(profileID string, inspectionProfile *InspectionProfile) (*http.Response, error) <span class="cov0" title="0">{
        setVersion(inspectionProfile)
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+inspectionProfileEndpoint, profileID+"/associateAllPredefinedControls")
        resp, err := service.Client.NewRequestDo("PUT", relativeURL, PatchQuery{Version: inspectionProfile.PredefinedControlsVersion}, inspectionProfile, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return resp, err</span>
}

func (service *Service) PutDeassociate(profileID string, inspectionProfile *InspectionProfile) (*http.Response, error) <span class="cov0" title="0">{
        setVersion(inspectionProfile)
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+inspectionProfileEndpoint, profileID+"/deAssociateAllPredefinedControls")
        resp, err := service.Client.NewRequestDo("PUT", relativeURL, PatchQuery{Version: inspectionProfile.PredefinedControlsVersion}, inspectionProfile, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return resp, err</span>
}

func (service *Service) Patch(profileID string, inspectionProfile *InspectionProfile) (*http.Response, error) <span class="cov0" title="0">{
        setVersion(inspectionProfile)
        relativeURL := fmt.Sprintf("%s/%s/patch", mgmtConfig+service.Client.Config.CustomerID+inspectionProfileEndpoint, profileID)
        resp, err := service.Client.NewRequestDo("PATCH", relativeURL, PatchQuery{Version: inspectionProfile.PredefinedControlsVersion}, inspectionProfile, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resp, err</span>
}

func (service *Service) Delete(profileID string) (*http.Response, error) <span class="cov4" title="2">{
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+inspectionProfileEndpoint, profileID)
        resp, err := service.Client.NewRequestDo("DELETE", relativeURL, nil, nil, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp, nil</span>
}

func (service *Service) GetAll() ([]InspectionProfile, *http.Response, error) <span class="cov1" title="1">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + inspectionProfileEndpoint
        list, resp, err := common.GetAllPagesGeneric[InspectionProfile](service.Client, relativeURL, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return list, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package lssconfigcontroller

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client *zpa.Client
}

func New(c *zpa.Client) *Service <span class="cov10" title="11">{
        return &amp;Service{Client: c}
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package lssconfigcontroller

import (
        "net/http"
)

const (
        lssClientTypesEndpoint = "lssConfig/clientTypes"
)

type LSSClientTypes struct {
        ZPNClientTypeExporter      string `json:"zpn_client_type_exporter"`
        ZPNClientTypeMachineTunnel string `json:"zpn_client_type_machine_tunnel"`
        ZPNClientTypeIPAnchoring   string `json:"zpn_client_type_ip_anchoring"`
        ZPNClientTypeEdgeConnector string `json:"zpn_client_type_edge_connector"`
        ZPNClientTypeZAPP          string `json:"zpn_client_type_zapp"`
        ZPNClientTypeSlogger       string `json:"zpn_client_type_slogger,omitempty"`
}

func (service *Service) GetClientTypes() (*LSSClientTypes, *http.Response, error) <span class="cov10" title="3">{
        v := new(LSSClientTypes)
        relativeURL := mgmtConfigTypesAndFormats + lssClientTypesEndpoint
        resp, err := service.Client.NewRequestDo("GET", relativeURL, nil, nil, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov10" title="3">return v, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package lssconfigcontroller

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfig                = "/mgmtconfig/v2/admin/customers/"
        mgmtConfigTypesAndFormats = "/mgmtconfig/v2/admin/"
        lssConfigEndpoint         = "/lssConfig"
)

type LSSResource struct {
        ID                 string              `json:"id,omitempty"`
        LSSConfig          *LSSConfig          `json:"config"`
        ConnectorGroups    []ConnectorGroups   `json:"connectorGroups,omitempty"`
        PolicyRule         *PolicyRule         `json:"policyRule,omitempty"`
        PolicyRuleResource *PolicyRuleResource `json:"policyRuleResource,omitempty"`
}

type LSSConfig struct {
        ID              string   `json:"id,omitempty"`
        Name            string   `json:"name,omitempty"`
        Description     string   `json:"description,omitempty"`
        Enabled         bool     `json:"enabled,omitempty"`
        CreationTime    string   `json:"creationTime,omitempty"`
        ModifiedBy      string   `json:"modifiedBy,omitempty"`
        ModifiedTime    string   `json:"modifiedTime,omitempty"`
        Filter          []string `json:"filter,omitempty"`
        Format          string   `json:"format,omitempty"`
        AuditMessage    string   `json:"auditMessage,omitempty"`
        LSSHost         string   `json:"lssHost,omitempty"`
        LSSPort         string   `json:"lssPort,omitempty"`
        SourceLogType   string   `json:"sourceLogType,omitempty"`
        MicroTenantID   string   `json:"microtenantId,omitempty"`
        MicroTenantName string   `json:"microtenantName,omitempty"`
        UseTLS          bool     `json:"useTls,omitempty"`
}

type ConnectorGroups struct {
        ID   string `json:"id,omitempty"`
        Name string `json:"name,omitempty"`
}

type AppServerGroups struct {
        ID   string `json:"id,omitempty"`
        Name string `json:"name,omitempty"`
}

type PolicyRuleResource struct {
        ID                       string                         `json:"id,omitempty"`
        Name                     string                         `json:"name,omitempty"`
        Description              string                         `json:"description,omitempty"`
        Action                   string                         `json:"action,omitempty"`
        ActionID                 string                         `json:"actionId,omitempty"`
        ConnectorGroups          []ConnectorGroups              `json:"connectorGroups,omitempty"`
        AppServerGroups          []AppServerGroups              `json:"appServerGroups,omitempty"`
        CreationTime             string                         `json:"creationTime,omitempty"`
        ModifiedBy               string                         `json:"modifiedBy,omitempty"`
        ModifiedTime             string                         `json:"modifiedTime,omitempty"`
        AuditMessage             string                         `json:"auditMessage,omitempty"`
        CustomMsg                string                         `json:"customMsg,omitempty"`
        Operator                 string                         `json:"operator,omitempty"`
        PolicySetID              string                         `json:"policySetId,omitempty"`
        PolicyType               string                         `json:"policyType,omitempty"`
        Priority                 string                         `json:"priority,omitempty"`
        ReauthIdleTimeout        string                         `json:"reauthIdleTimeout,omitempty"`
        ReauthTimeout            string                         `json:"reauthTimeout,omitempty"`
        RuleOrder                string                         `json:"ruleOrder,omitempty"`
        ZpnCbiProfileID          string                         `json:"zpnCbiProfileId,omitempty"`
        ZpnInspectionProfileID   string                         `json:"zpnInspectionProfileId,omitempty"`
        ZpnInspectionProfileName string                         `json:"zpnInspectionProfileName,omitempty"`
        MicroTenantID            string                         `json:"microtenantId,omitempty"`
        MicroTenantName          string                         `json:"microtenantName,omitempty"`
        Conditions               []PolicyRuleResourceConditions `json:"conditions,omitempty"`
}

type PolicyRule struct {
        Action                   string       `json:"action,omitempty"`
        ActionID                 string       `json:"actionId,omitempty"`
        BypassDefaultRule        bool         `json:"bypassDefaultRule,omitempty"`
        CreationTime             string       `json:"creationTime,omitempty"`
        CustomMsg                string       `json:"customMsg,omitempty"`
        DefaultRule              bool         `json:"defaultRule,omitempty"`
        Description              string       `json:"description,omitempty"`
        ID                       string       `json:"id,omitempty"`
        IsolationDefaultRule     bool         `json:"isolationDefaultRule,omitempty"`
        ModifiedBy               string       `json:"modifiedBy,omitempty"`
        ModifiedTime             string       `json:"modifiedTime,omitempty"`
        Name                     string       `json:"name,omitempty"`
        Operator                 string       `json:"operator,omitempty"`
        PolicySetID              string       `json:"policySetId,omitempty"`
        PolicyType               string       `json:"policyType,omitempty"`
        Priority                 string       `json:"priority,omitempty"`
        ReauthDefaultRule        bool         `json:"reauthDefaultRule,omitempty"`
        ReauthIdleTimeout        string       `json:"reauthIdleTimeout,omitempty"`
        ReauthTimeout            string       `json:"reauthTimeout,omitempty"`
        RuleOrder                string       `json:"ruleOrder,omitempty"`
        LssDefaultRule           bool         `json:"lssDefaultRule,omitempty"`
        ZpnCbiProfileID          string       `json:"zpnCbiProfileId,omitempty"`
        ZpnInspectionProfileID   string       `json:"zpnInspectionProfileId,omitempty"`
        ZpnInspectionProfileName string       `json:"zpnInspectionProfileName,omitempty"`
        MicroTenantID            string       `json:"microtenantId,omitempty"`
        MicroTenantName          string       `json:"microtenantName,omitempty"`
        Conditions               []Conditions `json:"conditions,omitempty"`
}

type Conditions struct {
        CreationTime string      `json:"creationTime,omitempty"`
        ID           string      `json:"id,omitempty"`
        ModifiedBy   string      `json:"modifiedBy,omitempty"`
        ModifiedTime string      `json:"modifiedTime,omitempty"`
        Negated      bool        `json:"negated"`
        Operands     *[]Operands `json:"operands,omitempty"`
        Operator     string      `json:"operator,omitempty"`
}

type PolicyRuleResourceConditions struct {
        ID           string                        `json:"id,omitempty"`
        CreationTime string                        `json:"creationTime,omitempty"`
        ModifiedBy   string                        `json:"modifiedBy,omitempty"`
        ModifiedTime string                        `json:"modifiedTime,omitempty"`
        Negated      bool                          `json:"negated"`
        Operands     *[]PolicyRuleResourceOperands `json:"operands,omitempty"`
        Operator     string                        `json:"operator,omitempty"`
}

type PolicyRuleResourceOperands struct {
        ID                          string                         `json:"id,omitempty"`
        CreationTime                string                         `json:"creationTime,omitempty"`
        ModifiedBy                  string                         `json:"modifiedBy,omitempty"`
        ModifiedTime                string                         `json:"modifiedTime,omitempty"`
        ObjectType                  string                         `json:"objectType,omitempty"`
        Values                      []string                       `json:"values,omitempty"`
        IDPID                       string                         `json:"idpId,omitempty"`
        OperandsResourceLHSRHSValue *[]OperandsResourceLHSRHSValue `json:"entryValues,omitempty"`
}

type OperandsResourceLHSRHSValue struct {
        RHS string `json:"rhs,omitempty"`
        LHS string `json:"lhs,omitempty"`
}

type Operands struct {
        CreationTime string `json:"creationTime,omitempty"`
        ID           string `json:"id,omitempty"`
        IdpID        string `json:"idpId,omitempty"`
        LHS          string `json:"lhs,omitempty"`
        ModifiedBy   string `json:"modifiedBy,omitempty"`
        ModifiedTime string `json:"modifiedTime,omitempty"`
        Name         string `json:"name,omitempty"`
        ObjectType   string `json:"objectType,omitempty"`
        RHS          string `json:"rhs,omitempty"`
}

func (service *Service) Get(lssID string) (*LSSResource, *http.Response, error) <span class="cov10" title="4">{
        v := new(LSSResource)
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+lssConfigEndpoint, lssID)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, nil, nil, v)
        if err != nil </span><span class="cov5" title="2">{
                return nil, nil, err
        }</span>
        <span class="cov5" title="2">return v, resp, nil</span>
}

func (service *Service) GetByName(lssName string) (*LSSResource, *http.Response, error) <span class="cov5" title="2">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + lssConfigEndpoint
        list, resp, err := common.GetAllPagesGeneric[LSSResource](service.Client, relativeURL, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov5" title="2">for _, lss := range list </span><span class="cov1" title="1">{
                if strings.EqualFold(lss.LSSConfig.Name, lssName) </span><span class="cov1" title="1">{
                        return &amp;lss, resp, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, resp, fmt.Errorf("no lss controller named '%s' was found", lssName)</span>
}

func (service *Service) Create(lssConfig *LSSResource) (*LSSResource, *http.Response, error) <span class="cov1" title="1">{
        v := new(LSSResource)
        resp, err := service.Client.NewRequestDo("POST", mgmtConfig+service.Client.Config.CustomerID+lssConfigEndpoint, nil, lssConfig, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return v, resp, nil</span>
}

func (service *Service) Update(lssID string, lssConfig *LSSResource) (*http.Response, error) <span class="cov5" title="2">{
        path := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+lssConfigEndpoint, lssID)
        resp, err := service.Client.NewRequestDo("PUT", path, nil, lssConfig, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return resp, err</span>
}

func (service *Service) Delete(lssID string) (*http.Response, error) <span class="cov5" title="2">{
        path := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+lssConfigEndpoint, lssID)
        resp, err := service.Client.NewRequestDo("DELETE", path, nil, nil, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return resp, err</span>
}

func (service *Service) GetAll() ([]LSSResource, *http.Response, error) <span class="cov1" title="1">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + lssConfigEndpoint
        list, resp, err := common.GetAllPagesGeneric[LSSResource](service.Client, relativeURL, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return list, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package lssconfigcontroller

import (
        "fmt"
        "net/http"
)

type LSSFormats struct {
        Csv  string `json:"csv"`
        Tsv  string `json:"tsv"`
        Json string `json:"json"`
}

func (service *Service) GetFormats(logType string) (*LSSFormats, *http.Response, error) <span class="cov10" title="8">{
        v := new(LSSFormats)
        relativeURL := fmt.Sprintf("%slssConfig/logType/formats", mgmtConfigTypesAndFormats)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, struct {
                LogType string `url:"logType"`
        }{
                LogType: logType,
        }, nil, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov10" title="8">return v, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package lssconfigcontroller

import (
        "fmt"
        "net/http"
)

const (
        lssStatusCodesEndpoint = "lssConfig/statusCodes"
)

type LSSStatusCodes struct {
        ZPNAuthLog    map[string]interface{} `json:"zpn_auth_log"`
        ZPNAstAuthLog map[string]interface{} `json:"zpn_ast_auth_log"`
        ZPNTransLog   map[string]interface{} `json:"zpn_trans_log"`
        ZPNSysAuthLog map[string]interface{} `json:"zpn_sys_auth_log"`
}

func (service *Service) GetStatusCodes() (*LSSStatusCodes, *http.Response, error) <span class="cov10" title="2">{
        v := new(LSSStatusCodes)
        relativeURL := fmt.Sprintf(mgmtConfigTypesAndFormats + lssStatusCodesEndpoint)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, nil, nil, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov10" title="2">service.Client.Config.Logger.Printf("[INFO] got LSSStatusCodes:%#v", v)
        return v, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package machinegroup

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client        *zpa.Client
        microTenantID *string
}

func New(c *zpa.Client) *Service <span class="cov10" title="5">{
        return &amp;Service{Client: c}
}</span>

func (service *Service) WithMicroTenant(microTenantID string) *Service <span class="cov0" title="0">{
        var mid *string
        if microTenantID != "" </span><span class="cov0" title="0">{
                mid_ := microTenantID
                mid = &amp;mid_
        }</span>
        <span class="cov0" title="0">return &amp;Service{
                Client:        service.Client,
                microTenantID: mid,
        }</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package machinegroup

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfig                  = "/mgmtconfig/v1/admin/customers/"
        machineGroupEndpoint string = "/machineGroup"
)

type MachineGroup struct {
        ID              string     `json:"id,omitempty"`
        Name            string     `json:"name,omitempty"`
        Description     string     `json:"description,omitempty"`
        Enabled         bool       `json:"enabled,omitempty"`
        CreationTime    string     `json:"creationTime,omitempty"`
        Machines        []Machines `json:"machines,omitempty"`
        ModifiedBy      string     `json:"modifiedBy,omitempty"`
        ModifiedTime    string     `json:"modifiedTime,omitempty"`
        MicroTenantID   string     `json:"microtenantId,omitempty"`
        MicroTenantName string     `json:"microtenantName,omitempty"`
}

type Machines struct {
        ID               string                 `json:"id,omitempty"`
        Name             string                 `json:"name,omitempty"`
        Description      string                 `json:"description,omitempty"`
        CreationTime     string                 `json:"creationTime,omitempty"`
        Fingerprint      string                 `json:"fingerprint,omitempty"`
        IssuedCertID     string                 `json:"issuedCertId,omitempty"`
        MachineGroupID   string                 `json:"machineGroupId,omitempty"`
        MachineGroupName string                 `json:"machineGroupName,omitempty"`
        MachineTokenID   string                 `json:"machineTokenId,omitempty"`
        ModifiedBy       string                 `json:"modifiedBy,omitempty"`
        ModifiedTime     string                 `json:"modifiedTime,omitempty"`
        MicroTenantID    string                 `json:"microtenantId,omitempty"`
        MicroTenantName  string                 `json:"microtenantName,omitempty"`
        SigningCert      map[string]interface{} `json:"signingCert,omitempty"`
}

func (service *Service) Get(machineGroupID string) (*MachineGroup, *http.Response, error) <span class="cov1" title="1">{
        v := new(MachineGroup)
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+machineGroupEndpoint, machineGroupID)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, common.Filter{MicroTenantID: service.microTenantID}, nil, v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return v, resp, nil</span>
}

func (service *Service) GetByName(machineGroupName string) (*MachineGroup, *http.Response, error) <span class="cov7" title="15">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + machineGroupEndpoint
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[MachineGroup](service.Client, relativeURL, common.Filter{Search: machineGroupName, MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov7" title="15">for _, app := range list </span><span class="cov10" title="48">{
                if strings.EqualFold(app.Name, machineGroupName) </span><span class="cov6" title="13">{
                        return &amp;app, resp, nil
                }</span>
        }
        <span class="cov2" title="2">return nil, resp, fmt.Errorf("no machine group named '%s' was found", machineGroupName)</span>
}

func (service *Service) GetAll() ([]MachineGroup, *http.Response, error) <span class="cov2" title="2">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + machineGroupEndpoint
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[MachineGroup](service.Client, relativeURL, common.Filter{MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov2" title="2">return list, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package microtenants

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfig           = "/mgmtconfig/v1/admin/customers/"
        microtenantsEndpoint = "/microtenants"
)

type MicroTenant struct {
        ID                      string        `json:"id,omitempty"`
        Name                    string        `json:"name,omitempty"`
        Description             string        `json:"description,omitempty"`
        Enabled                 bool          `json:"enabled"`
        CriteriaAttribute       string        `json:"criteriaAttribute,omitempty"`
        CriteriaAttributeValues []string      `json:"criteriaAttributeValues,omitempty"`
        Operator                string        `json:"operator,omitempty"`
        Priority                string        `json:"priority,omitempty"`
        CreationTime            string        `json:"creationTime,omitempty"`
        ModifiedBy              string        `json:"modifiedBy,omitempty"`
        ModifiedTime            string        `json:"modifiedTime,omitempty"`
        Roles                   []Roles       `json:"roles,omitempty"`
        UserResource            *UserResource `json:"user,omitempty"`
}

type Roles struct {
        ID         string `json:"id"`
        Name       string `json:"name,omitempty"`
        CustomRole bool   `json:"customRole,omitempty"`
}

type UserResource struct {
        ID                 string   `json:"id"`
        Name               string   `json:"name,omitempty"`
        Description        string   `json:"description,omitempty"`
        Enabled            bool     `json:"enabled,omitempty"`
        Comments           string   `json:"comments,omitempty"`
        CustomerID         string   `json:"customerId,omitempty"`
        DeliveryTag        string   `json:"deliveryTag,omitempty"`
        DisplayName        string   `json:"displayName,omitempty"`
        Email              string   `json:"email,omitempty"`
        Eula               string   `json:"eula,omitempty"`
        ForcePwdChange     bool     `json:"forcePwdChange,omitempty"`
        GroupIDs           []string `json:"groupIds,omitempty"`
        IAMUserID          string   `json:"iamUserId,omitempty"`
        IsEnabled          bool     `json:"isEnabled,omitempty"`
        IsLocked           bool     `json:"isLocked,omitempty"`
        LanguageCode       string   `json:"languageCode,omitempty"`
        LocalLoginDisabled bool     `json:"localLoginDisabled,omitempty"`
        OneIdentityUser    bool     `json:"oneIdentityUser,omitempty"`
        OperationType      string   `json:"operationType,omitempty"`
        Password           string   `json:"password,omitempty"`
        PhoneNumber        string   `json:"phoneNumber,omitempty"`
        PinSession         bool     `json:"pinSession,omitempty"`
        RoleID             string   `json:"roleId,omitempty"`
        MicrotenantID      string   `json:"microtenantId,omitempty"`
        MicrotenantName    string   `json:"microtenantName,omitempty"`
        SyncVersion        string   `json:"syncVersion,omitempty"`
        Timezone           string   `json:"timezone,omitempty"`
        TmpPassword        string   `json:"tmpPassword,omitempty"`

        // This field is mandatory if twoFactorAuthEnabled is set.
        TokenID string `json:"tokenId,omitempty"`

        TwoFactorAuthEnabled bool `json:"twoFactorAuthEnabled,omitempty"`

        // This field is mandatory if twoFactorAuthEnabled is set. Accepted values: YUBIKEY/TOTP
        TwoFactorAuthType string `json:"twoFactorAuthType,omitempty"`

        // Mandatory only for POST. Not mandatory for PUT/DELETE requests.
        Username string `json:"username,omitempty"`

        // Only applicable for a GET request. Ignored in PUT/POST/DELETE requests.
        CreationTime string `json:"creationTime,omitempty"`

        // Only applicable for a GET request. Ignored in PUT/POST/DELETE requests.
        ModifiedBy string `json:"modifiedBy,omitempty"`

        // Only applicable for a GET request. Ignored in PUT/POST/DELETE requests.
        ModifiedTime string `json:"modifiedTime,omitempty"`
}

func (service *Service) Get(id string) (*MicroTenant, *http.Response, error) <span class="cov4" title="2">{
        v := new(MicroTenant)
        path := fmt.Sprintf("%v/%v", mgmtConfig+service.Client.Config.CustomerID+microtenantsEndpoint, id)
        resp, err := service.Client.NewRequestDo("GET", path, nil, nil, v)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return v, resp, nil</span>
}

func (service *Service) GetByName(microTenantName string) (*MicroTenant, *http.Response, error) <span class="cov4" title="2">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + microtenantsEndpoint
        list, resp, err := common.GetAllPagesGeneric[MicroTenant](service.Client, relativeURL, microTenantName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov4" title="2">for _, app := range list </span><span class="cov4" title="2">{
                if strings.EqualFold(app.Name, microTenantName) </span><span class="cov1" title="1">{
                        return &amp;app, resp, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, resp, fmt.Errorf("no microtenant named '%s' was found", microTenantName)</span>
}

func (service *Service) Create(microTenant MicroTenant) (*MicroTenant, *http.Response, error) <span class="cov10" title="5">{
        v := new(MicroTenant)
        resp, err := service.Client.NewRequestDo("POST", mgmtConfig+service.Client.Config.CustomerID+microtenantsEndpoint, nil, microTenant, &amp;v)
        if err != nil </span><span class="cov8" title="4">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return v, resp, nil</span>
}

func (service *Service) Update(microTenantID string, microTenant *MicroTenant) (*http.Response, error) <span class="cov4" title="2">{
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+microtenantsEndpoint, microTenantID)
        resp, err := service.Client.NewRequestDo("PUT", relativeURL, nil, microTenant, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp, err</span>
}

func (service *Service) Delete(microTenantID string) (*http.Response, error) <span class="cov4" title="2">{
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+microtenantsEndpoint, microTenantID)
        resp, err := service.Client.NewRequestDo("DELETE", relativeURL, nil, nil, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp, nil</span>
}

func (service *Service) GetAll() ([]MicroTenant, *http.Response, error) <span class="cov1" title="1">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + microtenantsEndpoint
        list, resp, err := common.GetAllPagesGeneric[MicroTenant](service.Client, relativeURL, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return list, resp, nil</span>
}

func (service *Service) GetMicrotenantSummary() ([]MicroTenant, *http.Response, error) <span class="cov0" title="0">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + microtenantsEndpoint + "/summary"

        var list []MicroTenant // This will be used to decode the response

        // Since you're performing a GET request, the body is nil. The last parameter is also nil,
        // assuming it's for optional parameters or headers that aren't needed here.
        // Adjust this call if your service.Client.NewRequestDo method requires a different setup for headers or options.
        resp, err := service.Client.NewRequestDo("GET", relativeURL, nil, &amp;list, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                return nil, resp, fmt.Errorf("API request error: %s", resp.Status)
        }</span>

        // The response is already decoded into list by NewRequestDo, so no need to decode it again.

        <span class="cov0" title="0">return list, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package microtenants

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client *zpa.Client
}

func New(c *zpa.Client) *Service <span class="cov10" title="5">{
        return &amp;Service{Client: c}
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package platforms

import (
        "net/http"
)

const (
        mgmtConfig       = "/mgmtconfig/v1/admin/customers/"
        platformEndpoint = "/platform"
)

type Platforms struct {
        Linux   string `json:"linux"`
        Android string `json:"android"`
        Windows string `json:"windows"`
        IOS     string `json:"ios"`
        MacOS   string `json:"mac"`
}

func (service *Service) GetAllPlatforms() (*Platforms, *http.Response, error) <span class="cov8" title="1">{
        v := new(Platforms)
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + platformEndpoint
        resp, err := service.Client.NewRequestDo("GET", relativeURL, nil, nil, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">return v, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package platforms

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client *zpa.Client
}

func New(c *zpa.Client) *Service <span class="cov8" title="1">{
        return &amp;Service{Client: c}
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package policysetcontroller

import (
        "fmt"
        "io"
        "log"
        "net/http"
        "sort"
        "strconv"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfig = "/mgmtconfig/v1/admin/customers/"
)

type PolicySet struct {
        CreationTime    string       `json:"creationTime,omitempty"`
        Description     string       `json:"description,omitempty"`
        Enabled         bool         `json:"enabled"`
        ID              string       `json:"id,omitempty"`
        ModifiedBy      string       `json:"modifiedBy,omitempty"`
        ModifiedTime    string       `json:"modifiedTime,omitempty"`
        Name            string       `json:"name,omitempty"`
        Sorted          bool         `json:"sorted"`
        PolicyType      string       `json:"policyType,omitempty"`
        MicroTenantID   string       `json:"microtenantId,omitempty"`
        MicroTenantName string       `json:"microtenantName,omitempty"`
        Rules           []PolicyRule `json:"rules"`
}

type PolicyRule struct {
        Action                   string                 `json:"action,omitempty"`
        ActionID                 string                 `json:"actionId,omitempty"`
        BypassDefaultRule        bool                   `json:"bypassDefaultRule"`
        CreationTime             string                 `json:"creationTime,omitempty"`
        CustomMsg                string                 `json:"customMsg,omitempty"`
        DefaultRule              bool                   `json:"defaultRule,omitempty"`
        DefaultRuleName          string                 `json:"defaultRuleName,omitempty"`
        Description              string                 `json:"description,omitempty"`
        ID                       string                 `json:"id,omitempty"`
        IsolationDefaultRule     bool                   `json:"isolationDefaultRule"`
        ModifiedBy               string                 `json:"modifiedBy,omitempty"`
        ModifiedTime             string                 `json:"modifiedTime,omitempty"`
        Name                     string                 `json:"name,omitempty"`
        Operator                 string                 `json:"operator,omitempty"`
        PolicySetID              string                 `json:"policySetId"`
        PolicyType               string                 `json:"policyType,omitempty"`
        Priority                 string                 `json:"priority,omitempty"`
        ReauthDefaultRule        bool                   `json:"reauthDefaultRule"`
        ReauthIdleTimeout        string                 `json:"reauthIdleTimeout,omitempty"`
        ReauthTimeout            string                 `json:"reauthTimeout,omitempty"`
        RuleOrder                string                 `json:"ruleOrder"`
        LSSDefaultRule           bool                   `json:"lssDefaultRule"`
        ZpnCbiProfileID          string                 `json:"zpnCbiProfileId,omitempty"`
        ZpnIsolationProfileID    string                 `json:"zpnIsolationProfileId,omitempty"`
        ZpnInspectionProfileID   string                 `json:"zpnInspectionProfileId,omitempty"`
        ZpnInspectionProfileName string                 `json:"zpnInspectionProfileName,omitempty"`
        MicroTenantID            string                 `json:"microtenantId,omitempty"`
        MicroTenantName          string                 `json:"microtenantName,omitempty"`
        Conditions               []Conditions           `json:"conditions"`
        AppServerGroups          []AppServerGroups      `json:"appServerGroups"`
        AppConnectorGroups       []AppConnectorGroups   `json:"appConnectorGroups"`
        ServiceEdgeGroups        []ServiceEdgeGroups    `json:"serviceEdgeGroups"`
        Credential               *Credential            `json:"credential,omitempty"`
        PrivilegedCapabilities   PrivilegedCapabilities `json:"privilegedCapabilities,omitempty"`
}

type Conditions struct {
        CreationTime  string     `json:"creationTime,omitempty"`
        ID            string     `json:"id,omitempty"`
        ModifiedBy    string     `json:"modifiedBy,omitempty"`
        ModifiedTime  string     `json:"modifiedTime,omitempty"`
        Negated       bool       `json:"negated"`
        Operands      []Operands `json:"operands"`
        Operator      string     `json:"operator,omitempty"`
        MicroTenantID string     `json:"microtenantId,omitempty"`
}

type Operands struct {
        CreationTime  string `json:"creationTime,omitempty"`
        ID            string `json:"id,omitempty"`
        IdpID         string `json:"idpId,omitempty"`
        LHS           string `json:"lhs,omitempty"`
        ModifiedBy    string `json:"modifiedBy,omitempty"`
        ModifiedTime  string `json:"modifiedTime,omitempty"`
        Name          string `json:"name,omitempty"`
        ObjectType    string `json:"objectType,omitempty"`
        RHS           string `json:"rhs,omitempty"`
        MicroTenantID string `json:"microtenantId,omitempty"`
}

type AppServerGroups struct {
        ID   string `json:"id,omitempty"`
        Name string `json:"name,omitempty"`
}

type AppConnectorGroups struct {
        ID   string `json:"id,omitempty"`
        Name string `json:"name,omitempty"`
}

type ServiceEdgeGroups struct {
        ID string `json:"id,omitempty"`
}

type Credential struct {
        ID   string `json:"id"`
        Name string `json:"name,omitempty"`
}

type PrivilegedCapabilities struct {
        ID            string   `json:"id"`
        CreationTime  string   `json:"creationTime,omitempty"`
        ModifiedBy    string   `json:"modifiedBy,omitempty"`
        ModifiedTime  string   `json:"modifiedTime,omitempty"`
        MicroTenantID string   `json:"microtenantId,omitempty"`
        Capabilities  []string `json:"capabilities,omitempty"`
}

type Count struct {
        Count string `json:"count"`
}

func (service *Service) GetByPolicyType(policyType string) (*PolicySet, *http.Response, error) <span class="cov6" title="9">{
        v := new(PolicySet)
        relativeURL := fmt.Sprintf(mgmtConfig + service.Client.Config.CustomerID + "/policySet/policyType/" + policyType)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, common.Filter{MicroTenantID: service.microTenantID}, nil, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov6" title="9">return v, resp, nil</span>
}

// GET --&gt; mgmtconfig/v1/admin/customers/{customerId}/policySet/{policySetId}/rule/{ruleId}
func (service *Service) GetPolicyRule(policySetID, ruleId string) (*PolicyRule, *http.Response, error) <span class="cov10" title="37">{
        v := new(PolicyRule)
        url := fmt.Sprintf(mgmtConfig+service.Client.Config.CustomerID+"/policySet/%s/rule/%s", policySetID, ruleId)
        resp, err := service.Client.NewRequestDo("GET", url, common.Filter{MicroTenantID: service.microTenantID}, nil, &amp;v)
        if err != nil </span><span class="cov8" title="21">{
                return nil, nil, err
        }</span>
        <span class="cov7" title="16">return v, resp, nil</span>
}

// POST --&gt; mgmtconfig/v1/admin/customers/{customerId}/policySet/{policySetId}/rule
func (service *Service) CreateRule(rule *PolicyRule) (*PolicyRule, *http.Response, error) <span class="cov6" title="11">{
        v := new(PolicyRule)
        path := fmt.Sprintf(mgmtConfig+service.Client.Config.CustomerID+"/policySet/%s/rule", rule.PolicySetID)
        resp, err := service.Client.NewRequestDo("POST", path, common.Filter{MicroTenantID: service.microTenantID}, &amp;rule, v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov6" title="11">return v, resp, nil</span>
}

// PUT --&gt; mgmtconfig/v1/admin/customers/{customerId}/policySet/{policySetId}/rule/{ruleId}
func (service *Service) UpdateRule(policySetID, ruleId string, policySetRule *PolicyRule) (*http.Response, error) <span class="cov8" title="18">{
        if policySetRule != nil &amp;&amp; len(policySetRule.Conditions) == 0 </span><span class="cov6" title="10">{
                policySetRule.Conditions = []Conditions{}
        }</span> else<span class="cov6" title="8"> {
                for i, condtion := range policySetRule.Conditions </span><span class="cov6" title="8">{
                        if len(condtion.Operands) == 0 </span><span class="cov0" title="0">{
                                policySetRule.Conditions[i].Operands = []Operands{}
                        }</span> else<span class="cov6" title="8"> {
                                for i, operand := range condtion.Operands </span><span class="cov7" title="16">{
                                        if operand.Name != "" </span><span class="cov5" title="7">{
                                                condtion.Operands[i].Name = ""
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov8" title="18">path := fmt.Sprintf(mgmtConfig+service.Client.Config.CustomerID+"/policySet/%s/rule/%s", policySetID, ruleId)
        resp, err := service.Client.NewRequestDo("PUT", path, common.Filter{MicroTenantID: service.microTenantID}, policySetRule, nil)
        if err != nil </span><span class="cov6" title="10">{
                return nil, err
        }</span>
        <span class="cov6" title="8">return resp, err</span>
}

// DELETE --&gt; mgmtconfig/v1/admin/customers/{customerId}/policySet/{policySetId}/rule/{ruleId}
func (service *Service) Delete(policySetID, ruleId string) (*http.Response, error) <span class="cov8" title="21">{
        path := fmt.Sprintf(mgmtConfig+service.Client.Config.CustomerID+"/policySet/%s/rule/%s", policySetID, ruleId)
        resp, err := service.Client.NewRequestDo("DELETE", path, common.Filter{MicroTenantID: service.microTenantID}, nil, nil)
        if err != nil </span><span class="cov6" title="10">{
                return nil, err
        }</span>
        <span class="cov6" title="11">return resp, err</span>
}

func (service *Service) GetByNameAndType(policyType, ruleName string) (*PolicyRule, *http.Response, error) <span class="cov8" title="18">{
        relativeURL := fmt.Sprintf(mgmtConfig+service.Client.Config.CustomerID+"/policySet/rules/policyType/%s", policyType)
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[PolicyRule](service.Client, relativeURL, common.Filter{Search: ruleName, MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="18">for _, p := range list </span><span class="cov6" title="8">{
                if strings.EqualFold(ruleName, p.Name) </span><span class="cov6" title="8">{
                        return &amp;p, resp, nil
                }</span>
        }
        <span class="cov6" title="10">return nil, resp, fmt.Errorf("no policy rule named :%s found", ruleName)</span>
}

func (service *Service) GetByNameAndTypes(policyTypes []string, ruleName string) (p *PolicyRule, resp *http.Response, err error) <span class="cov0" title="0">{
        for _, policyType := range policyTypes </span><span class="cov0" title="0">{
                p, resp, err = service.GetByNameAndType(policyType, ruleName)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                } else<span class="cov0" title="0"> {
                        return
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

// PUT --&gt; /mgmtconfig/v1/admin/customers/{customerId}/policySet/{policySetId}/rule/{ruleId}/reorder/{newOrder}
func (service *Service) Reorder(policySetID, ruleId string, order int) (*http.Response, error) <span class="cov0" title="0">{
        path := fmt.Sprintf(mgmtConfig+service.Client.Config.CustomerID+"/policySet/%s/rule/%s/reorder/%d", policySetID, ruleId, order)
        resp, err := service.Client.NewRequestDo("PUT", path, common.Filter{MicroTenantID: service.microTenantID}, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resp, err</span>
}

// PUT --&gt; /mgmtconfig/v1/admin/customers/{customerId}/policySet/{policySet}/reorder
// ruleIdOrders is a map[ruleID]Order
func (service *Service) BulkReorder(policySetType string, ruleIdToOrder map[string]int) (*http.Response, error) <span class="cov0" title="0">{
        policySet, resp, err := service.GetByPolicyType(policySetType)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov0" title="0">all, resp, err := service.GetAllByType(policySetType)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov0" title="0">sort.SliceStable(all, func(i, j int) bool </span><span class="cov0" title="0">{
                ruleIDi := all[i].ID
                ruleIDj := all[j].ID

                // Check if ruleIDi and ruleIDj exist in the ruleIdToOrder map
                orderi, existsi := ruleIdToOrder[ruleIDi]
                orderj, existsj := ruleIdToOrder[ruleIDj]

                // If both rules exist in the map, compare their orders
                if existsi &amp;&amp; existsj </span><span class="cov0" title="0">{
                        return orderi &lt;= orderj
                }</span>

                // If only one of the rules exists in the map, prioritize it
                <span class="cov0" title="0">if existsi </span><span class="cov0" title="0">{
                        return true
                }</span> else<span class="cov0" title="0"> if existsj </span><span class="cov0" title="0">{
                        return false
                }</span>

                // If neither rule exists in the map, maintain their relative order
                <span class="cov0" title="0">return i &lt;= j</span>
        })
        // Construct the URL path
        <span class="cov0" title="0">path := fmt.Sprintf(mgmtConfig+service.Client.Config.CustomerID+"/policySet/%s/reorder", policySet.ID)
        ruleIdsOrdered := []string{}
        for _, r := range all </span><span class="cov0" title="0">{
                ruleIdsOrdered = append(ruleIdsOrdered, r.ID)
        }</span>

        // Create a new PUT request
        <span class="cov0" title="0">resp, err = service.Client.NewRequestDo("PUT", path, common.Filter{MicroTenantID: service.microTenantID}, ruleIdsOrdered, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check for non-2xx status code and log response body for debugging
        <span class="cov0" title="0">if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                defer resp.Body.Close() // Ensure the body is always closed
                bodyBytes, err := io.ReadAll(resp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        // Handle the error of reading the body (optional)
                        log.Printf("Error reading response body: %s\n", err.Error())
                }</span>
                <span class="cov0" title="0">log.Printf("Error response from API: %s\n", string(bodyBytes))
                return resp, fmt.Errorf("API request failed with status code %d: %s", resp.StatusCode, string(bodyBytes))</span>
        }

        <span class="cov0" title="0">return resp, nil</span>
}

func (service *Service) RulesCount() (int, *http.Response, error) <span class="cov0" title="0">{
        v := new(Count)
        relativeURL := fmt.Sprintf(mgmtConfig+service.Client.Config.CustomerID+"/policySet/rules/policyType/GLOBAL_POLICY/count", service.Client.Config.CustomerID)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, common.Filter{MicroTenantID: service.microTenantID}, nil, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>
        <span class="cov0" title="0">count, err := strconv.Atoi(v.Count)
        return count, resp, err</span>
}

func (service *Service) GetAllByType(policyType string) ([]PolicyRule, *http.Response, error) <span class="cov6" title="8">{
        relativeURL := fmt.Sprintf(mgmtConfig+service.Client.Config.CustomerID+"/policySet/rules/policyType/%s", policyType)
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[PolicyRule](service.Client, relativeURL, common.Filter{MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov6" title="8">return list, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package policysetcontroller

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client        *zpa.Client
        microTenantID *string
}

func New(c *zpa.Client) *Service <span class="cov10" title="10">{
        return &amp;Service{Client: c}
}</span>

func (service *Service) WithMicroTenant(microTenantID string) *Service <span class="cov0" title="0">{
        var mid *string
        if microTenantID != "" </span><span class="cov0" title="0">{
                mid_ := microTenantID
                mid = &amp;mid_
        }</span>
        <span class="cov0" title="0">return &amp;Service{
                Client:        service.Client,
                microTenantID: mid,
        }</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package policysetcontrollerv2

import (
        "fmt"
        "io"
        "log"
        "net/http"
        "sort"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfigV1 = "/mgmtconfig/v1/admin/customers/"
        mgmtConfigV2 = "/mgmtconfig/v2/admin/customers/"
)

type PolicySet struct {
        CreationTime    string       `json:"creationTime,omitempty"`
        Description     string       `json:"description,omitempty"`
        Enabled         bool         `json:"enabled"`
        ID              string       `json:"id,omitempty"`
        ModifiedBy      string       `json:"modifiedBy,omitempty"`
        ModifiedTime    string       `json:"modifiedTime,omitempty"`
        Name            string       `json:"name,omitempty"`
        Sorted          bool         `json:"sorted"`
        PolicyType      string       `json:"policyType,omitempty"`
        MicroTenantID   string       `json:"microtenantId,omitempty"`
        MicroTenantName string       `json:"microtenantName,omitempty"`
        Rules           []PolicyRule `json:"rules"`
}

// ######################################################################################################
// ########################################## API V1 Structure ##########################################
// ################################### Used to process the API Response #################################
// ######################################################################################################
type PolicyRuleResource struct {
        ID                       string                         `json:"id,omitempty"`
        Name                     string                         `json:"name,omitempty"`
        Description              string                         `json:"description,omitempty"`
        Action                   string                         `json:"action,omitempty"`
        ActionID                 string                         `json:"actionId,omitempty"`
        CreationTime             string                         `json:"creationTime,omitempty"`
        ModifiedBy               string                         `json:"modifiedBy,omitempty"`
        ModifiedTime             string                         `json:"modifiedTime,omitempty"`
        AuditMessage             string                         `json:"auditMessage,omitempty"`
        CustomMsg                string                         `json:"customMsg,omitempty"`
        Operator                 string                         `json:"operator,omitempty"`
        PolicySetID              string                         `json:"policySetId,omitempty"`
        PolicyType               string                         `json:"policyType,omitempty"`
        Priority                 string                         `json:"priority,omitempty"`
        ReauthIdleTimeout        string                         `json:"reauthIdleTimeout,omitempty"`
        ReauthTimeout            string                         `json:"reauthTimeout,omitempty"`
        RuleOrder                string                         `json:"ruleOrder,omitempty"`
        ZpnCbiProfileID          string                         `json:"zpnCbiProfileId,omitempty"`
        ZpnIsolationProfileID    string                         `json:"zpnIsolationProfileId,omitempty"`
        ZpnInspectionProfileID   string                         `json:"zpnInspectionProfileId,omitempty"`
        ZpnInspectionProfileName string                         `json:"zpnInspectionProfileName,omitempty"`
        MicroTenantID            string                         `json:"microtenantId,omitempty"`
        MicroTenantName          string                         `json:"microtenantName,omitempty"`
        Conditions               []PolicyRuleResourceConditions `json:"conditions,omitempty"`
        AppConnectorGroups       []AppConnectorGroups           `json:"connectorGroups,omitempty"`
        AppServerGroups          []AppServerGroups              `json:"appServerGroups,omitempty"`
        ServiceEdgeGroups        []ServiceEdgeGroups            `json:"serviceEdgeGroups,omitempty"`
        Credential               *Credential                    `json:"credential,omitempty"`
        PrivilegedCapabilities   PrivilegedCapabilities         `json:"privilegedCapabilities,omitempty"`
}

type Conditions struct {
        CreationTime string     `json:"creationTime,omitempty"`
        ID           string     `json:"id,omitempty"`
        ModifiedBy   string     `json:"modifiedBy,omitempty"`
        ModifiedTime string     `json:"modifiedTime,omitempty"`
        Negated      bool       `json:"negated"`
        Operands     []Operands `json:"operands,omitempty"`
        Operator     string     `json:"operator,omitempty"`
}

type Operands struct {
        ID           string `json:"id,omitempty"`
        Name         string `json:"name,omitempty"`
        CreationTime string `json:"creationTime,omitempty"`
        ModifiedBy   string `json:"modifiedBy,omitempty"`
        ModifiedTime string `json:"modifiedTime,omitempty"`
        IdpID        string `json:"idpId,omitempty"`
        LHS          string `json:"lhs,omitempty"`
        RHS          string `json:"rhs,omitempty"`
        ObjectType   string `json:"objectType,omitempty"`
}

// ######################################################################################################
// ########################################## API V2 Structure ##########################################
// ################################### Used to process the API Request ##################################
// ######################################################################################################

type PolicyRule struct {
        ID                       string                         `json:"id,omitempty"`
        Name                     string                         `json:"name,omitempty"`
        Action                   string                         `json:"action,omitempty"`
        ActionID                 string                         `json:"actionId,omitempty"`
        CustomMsg                string                         `json:"customMsg,omitempty"`
        Description              string                         `json:"description,omitempty"`
        CreationTime             string                         `json:"creationTime,omitempty"`
        ModifiedBy               string                         `json:"modifiedBy,omitempty"`
        ModifiedTime             string                         `json:"modifiedTime,omitempty"`
        Operator                 string                         `json:"operator,omitempty"`
        PolicySetID              string                         `json:"policySetId,omitempty"`
        PolicyType               string                         `json:"policyType,omitempty"`
        Priority                 string                         `json:"priority,omitempty"`
        ReauthIdleTimeout        string                         `json:"reauthIdleTimeout,omitempty"`
        ReauthTimeout            string                         `json:"reauthTimeout,omitempty"`
        RuleOrder                string                         `json:"ruleOrder,omitempty"`
        ZpnIsolationProfileID    string                         `json:"zpnIsolationProfileId,omitempty"`
        ZpnInspectionProfileID   string                         `json:"zpnInspectionProfileId,omitempty"`
        ZpnInspectionProfileName string                         `json:"zpnInspectionProfileName,omitempty"`
        MicroTenantID            string                         `json:"microtenantId,omitempty"`
        MicroTenantName          string                         `json:"microtenantName,omitempty"`
        Version                  string                         `json:"version,omitempty"`
        AppConnectorGroups       []AppConnectorGroups           `json:"connectorGroups,omitempty"`
        AppServerGroups          []AppServerGroups              `json:"appServerGroups,omitempty"`
        ServiceEdgeGroups        []ServiceEdgeGroups            `json:"serviceEdgeGroups,omitempty"`
        Conditions               []PolicyRuleResourceConditions `json:"conditions,omitempty"`
        Credential               *Credential                    `json:"credential,omitempty"`
        PrivilegedCapabilities   PrivilegedCapabilities         `json:"privilegedCapabilities,omitempty"`
}

type PolicyRuleResourceConditions struct {
        ID           string                       `json:"id,omitempty"`
        CreationTime string                       `json:"creationTime,omitempty"`
        ModifiedBy   string                       `json:"modifiedBy,omitempty"`
        ModifiedTime string                       `json:"modifiedTime,omitempty"`
        Negated      bool                         `json:"negated"`
        Operator     string                       `json:"operator,omitempty"`
        Operands     []PolicyRuleResourceOperands `json:"operands,omitempty"`
}

type PolicyRuleResourceOperands struct {
        ID                string                        `json:"id,omitempty"`
        CreationTime      string                        `json:"creationTime,omitempty"`
        ModifiedBy        string                        `json:"modifiedBy,omitempty"`
        ModifiedTime      string                        `json:"modifiedTime,omitempty"`
        ObjectType        string                        `json:"objectType,omitempty"`
        Values            []string                      `json:"values,omitempty"`
        IDPID             string                        `json:"idpId,omitempty"`
        LHS               string                        `json:"lhs,omitempty"`
        RHS               string                        `json:"rhs,omitempty"`
        EntryValuesLHSRHS []OperandsResourceLHSRHSValue `json:"entryValues,omitempty"`
}

type OperandsResourceLHSRHSValue struct {
        RHS string `json:"rhs,omitempty"`
        LHS string `json:"lhs,omitempty"`
}

type AppServerGroups struct {
        ID   string `json:"id,omitempty"`
        Name string `json:"name,omitempty"`
}

type AppConnectorGroups struct {
        ID   string `json:"id,omitempty"`
        Name string `json:"name,omitempty"`
}

type ServiceEdgeGroups struct {
        ID   string `json:"id,omitempty"`
        Name string `json:"name,omitempty"`
}

type Credential struct {
        ID   string `json:"id"`
        Name string `json:"name,omitempty"`
}

type PrivilegedCapabilities struct {
        ID            string   `json:"id"`
        CreationTime  string   `json:"creationTime,omitempty"`
        ModifiedBy    string   `json:"modifiedBy,omitempty"`
        ModifiedTime  string   `json:"modifiedTime,omitempty"`
        MicroTenantID string   `json:"microtenantId,omitempty"`
        Capabilities  []string `json:"capabilities,omitempty"`
}

func (service *Service) GetByPolicyType(policyType string) (*PolicySet, *http.Response, error) <span class="cov0" title="0">{
        v := new(PolicySet)
        relativeURL := fmt.Sprintf(mgmtConfigV1 + service.Client.Config.CustomerID + "/policySet/policyType/" + policyType)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, common.Filter{MicroTenantID: service.microTenantID}, nil, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">return v, resp, nil</span>
}

// GET --&gt; mgmtconfig/v1/admin/customers/{customerId}/policySet/{policySetId}/rule/{ruleId}
func (service *Service) GetPolicyRule(policySetID, ruleId string) (*PolicyRuleResource, *http.Response, error) <span class="cov7" title="10">{
        v := new(PolicyRuleResource)
        url := fmt.Sprintf(mgmtConfigV1+service.Client.Config.CustomerID+"/policySet/%s/rule/%s", policySetID, ruleId)
        resp, err := service.Client.NewRequestDo("GET", url, common.Filter{MicroTenantID: service.microTenantID}, nil, &amp;v)
        if err != nil </span><span class="cov7" title="10">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return v, resp, nil</span>
}

// POST --&gt; mgmtconfig/v2/admin/customers/{customerId}/policySet/{policySetId}/rule
func (service *Service) CreateRule(rule *PolicyRule) (*PolicyRule, *http.Response, error) <span class="cov5" title="5">{
        v := new(PolicyRule)
        path := fmt.Sprintf(mgmtConfigV2+service.Client.Config.CustomerID+"/policySet/%s/rule", rule.PolicySetID)
        resp, err := service.Client.NewRequestDo("POST", path, common.Filter{MicroTenantID: service.microTenantID}, &amp;rule, v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov5" title="5">return v, resp, nil</span>
}

// PUT --&gt; mgmtconfig/v1/admin/customers/{customerId}/policySet/{policySetId}/rule/{ruleId}
func (service *Service) UpdateRule(policySetID, ruleId string, policySetRule *PolicyRule) (*http.Response, error) <span class="cov8" title="15">{
        // Correct the initialization of Conditions slice with the correct type
        if policySetRule != nil &amp;&amp; len(policySetRule.Conditions) == 0 </span><span class="cov7" title="10">{
                policySetRule.Conditions = []PolicyRuleResourceConditions{}
        }</span> else<span class="cov5" title="5"> {
                for i, condition := range policySetRule.Conditions </span><span class="cov9" title="25">{
                        if len(condition.Operands) == 0 </span><span class="cov0" title="0">{
                                policySetRule.Conditions[i].Operands = []PolicyRuleResourceOperands{}
                        }</span> else<span class="cov9" title="25"> {
                                for j, operand := range condition.Operands </span><span class="cov10" title="30">{
                                        // Clearing the ID if present, assuming you want to ensure IDs are not sent in updates
                                        if operand.ID != "" </span><span class="cov0" title="0">{
                                                condition.Operands[j].ID = ""
                                        }</span>
                                        // If there's more logic to be added for handling Operands, do so here
                                }
                        }
                }
        }

        <span class="cov8" title="15">path := fmt.Sprintf(mgmtConfigV2+service.Client.Config.CustomerID+"/policySet/%s/rule/%s", policySetID, ruleId)
        resp, err := service.Client.NewRequestDo("PUT", path, common.Filter{MicroTenantID: service.microTenantID}, policySetRule, nil)
        if err != nil </span><span class="cov7" title="10">{
                return nil, err
        }</span>
        <span class="cov5" title="5">return resp, err</span>
}

// DELETE --&gt; mgmtconfig/v1/admin/customers/{customerId}/policySet/{policySetId}/rule/{ruleId}
func (service *Service) Delete(policySetID, ruleId string) (*http.Response, error) <span class="cov7" title="10">{
        path := fmt.Sprintf(mgmtConfigV1+service.Client.Config.CustomerID+"/policySet/%s/rule/%s", policySetID, ruleId)
        resp, err := service.Client.NewRequestDo("DELETE", path, common.Filter{MicroTenantID: service.microTenantID}, nil, nil)
        if err != nil </span><span class="cov7" title="10">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resp, err</span>
}

func (service *Service) GetByNameAndType(policyType, ruleName string) (*PolicyRuleResource, *http.Response, error) <span class="cov7" title="10">{
        relativeURL := fmt.Sprintf(mgmtConfigV1+service.Client.Config.CustomerID+"/policySet/rules/policyType/%s", policyType)
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[PolicyRuleResource](service.Client, relativeURL, common.Filter{Search: ruleName, MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov7" title="10">for _, p := range list </span><span class="cov0" title="0">{
                if strings.EqualFold(ruleName, p.Name) </span><span class="cov0" title="0">{
                        return &amp;p, resp, nil
                }</span>
        }
        <span class="cov7" title="10">return nil, resp, fmt.Errorf("no policy rule named :%s found", ruleName)</span>
}

func (service *Service) GetByNameAndTypes(policyTypes []string, ruleName string) (p *PolicyRuleResource, resp *http.Response, err error) <span class="cov0" title="0">{
        for _, policyType := range policyTypes </span><span class="cov0" title="0">{
                p, resp, err = service.GetByNameAndType(policyType, ruleName)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                } else<span class="cov0" title="0"> {
                        return
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

// PUT --&gt; /mgmtconfig/v1/admin/customers/{customerId}/policySet/{policySetId}/rule/{ruleId}/reorder/{newOrder}
func (service *Service) Reorder(policySetID, ruleId string, order int) (*http.Response, error) <span class="cov0" title="0">{
        path := fmt.Sprintf(mgmtConfigV1+service.Client.Config.CustomerID+"/policySet/%s/rule/%s/reorder/%d", policySetID, ruleId, order)
        resp, err := service.Client.NewRequestDo("PUT", path, common.Filter{MicroTenantID: service.microTenantID}, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resp, err</span>
}

// PUT --&gt; /mgmtconfig/v1/admin/customers/{customerId}/policySet/{policySet}/reorder
// ruleIdOrders is a map[ruleID]Order
func (service *Service) BulkReorder(policySetType string, ruleIdToOrder map[string]int) (*http.Response, error) <span class="cov0" title="0">{
        policySet, resp, err := service.GetByPolicyType(policySetType)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov0" title="0">all, resp, err := service.GetAllByType(policySetType)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov0" title="0">sort.SliceStable(all, func(i, j int) bool </span><span class="cov0" title="0">{
                ruleIDi := all[i].ID
                ruleIDj := all[j].ID

                // Check if ruleIDi and ruleIDj exist in the ruleIdToOrder map
                orderi, existsi := ruleIdToOrder[ruleIDi]
                orderj, existsj := ruleIdToOrder[ruleIDj]

                // If both rules exist in the map, compare their orders
                if existsi &amp;&amp; existsj </span><span class="cov0" title="0">{
                        return orderi &lt;= orderj
                }</span>

                // If only one of the rules exists in the map, prioritize it
                <span class="cov0" title="0">if existsi </span><span class="cov0" title="0">{
                        return true
                }</span> else<span class="cov0" title="0"> if existsj </span><span class="cov0" title="0">{
                        return false
                }</span>

                // If neither rule exists in the map, maintain their relative order
                <span class="cov0" title="0">return i &lt;= j</span>
        })
        // Construct the URL path
        <span class="cov0" title="0">path := fmt.Sprintf(mgmtConfigV1+service.Client.Config.CustomerID+"/policySet/%s/reorder", policySet.ID)
        ruleIdsOrdered := []string{}
        for _, r := range all </span><span class="cov0" title="0">{
                ruleIdsOrdered = append(ruleIdsOrdered, r.ID)
        }</span>

        // Create a new PUT request
        <span class="cov0" title="0">resp, err = service.Client.NewRequestDo("PUT", path, common.Filter{MicroTenantID: service.microTenantID}, ruleIdsOrdered, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check for non-2xx status code and log response body for debugging
        <span class="cov0" title="0">if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                defer resp.Body.Close() // Ensure the body is always closed
                bodyBytes, err := io.ReadAll(resp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        // Handle the error of reading the body (optional)
                        log.Printf("Error reading response body: %s\n", err.Error())
                }</span>
                <span class="cov0" title="0">log.Printf("Error response from API: %s\n", string(bodyBytes))
                return resp, fmt.Errorf("API request failed with status code %d: %s", resp.StatusCode, string(bodyBytes))</span>
        }

        <span class="cov0" title="0">return resp, nil</span>
}

func (service *Service) GetAllByType(policyType string) ([]PolicyRuleResource, *http.Response, error) <span class="cov0" title="0">{
        relativeURL := fmt.Sprintf(mgmtConfigV1+service.Client.Config.CustomerID+"/policySet/rules/policyType/%s", policyType)
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[PolicyRuleResource](service.Client, relativeURL, common.Filter{MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return list, resp, nil</span>
}

// ConvertV1ResponseToV2Request converts a PolicyRuleResource (API v1 response) to a PolicyRule (API v2 request) with aggregated values.
func ConvertV1ResponseToV2Request(v1Response PolicyRuleResource) PolicyRule <span class="cov0" title="0">{
        v2Request := PolicyRule{
                ID:                    v1Response.ID,
                Name:                  v1Response.Name,
                Description:           v1Response.Description,
                Action:                v1Response.Action,
                PolicySetID:           v1Response.PolicySetID,
                Operator:              v1Response.Operator,
                CustomMsg:             v1Response.CustomMsg,
                ZpnIsolationProfileID: v1Response.ZpnIsolationProfileID,
                Conditions:            make([]PolicyRuleResourceConditions, 0),
        }

        for _, condition := range v1Response.Conditions </span><span class="cov0" title="0">{
                newCondition := PolicyRuleResourceConditions{
                        Operator: condition.Operator,
                        Operands: make([]PolicyRuleResourceOperands, 0),
                }

                // Use a map to aggregate RHS values by ObjectType
                operandMap := make(map[string][]string)
                entryValuesMap := make(map[string][]OperandsResourceLHSRHSValue)

                for _, operand := range condition.Operands </span><span class="cov0" title="0">{
                        switch operand.ObjectType </span>{
                        case "APP", "APP_GROUP", "CONSOLE", "MACHINE_GRP", "LOCATION", "BRANCH_CONNECTOR_GROUP", "EDGE_CONNECTOR_GROUP", "CLIENT_TYPE":<span class="cov0" title="0">
                                operandMap[operand.ObjectType] = append(operandMap[operand.ObjectType], operand.RHS)</span>
                        case "PLATFORM", "POSTURE", "TRUSTED_NETWORK", "SAML", "SCIM", "SCIM_GROUP", "COUNTRY_CODE":<span class="cov0" title="0">
                                entryValuesMap[operand.ObjectType] = append(entryValuesMap[operand.ObjectType], OperandsResourceLHSRHSValue{
                                        LHS: operand.LHS,
                                        RHS: operand.RHS,
                                })</span>
                        }
                }

                // Create operand blocks from the aggregated data
                <span class="cov0" title="0">for objectType, values := range operandMap </span><span class="cov0" title="0">{
                        newCondition.Operands = append(newCondition.Operands, PolicyRuleResourceOperands{
                                ObjectType: objectType,
                                Values:     values,
                        })
                }</span>

                <span class="cov0" title="0">for objectType, entryValues := range entryValuesMap </span><span class="cov0" title="0">{
                        newCondition.Operands = append(newCondition.Operands, PolicyRuleResourceOperands{
                                ObjectType:        objectType,
                                EntryValuesLHSRHS: entryValues,
                        })
                }</span>
                <span class="cov0" title="0">v2Request.Conditions = append(v2Request.Conditions, newCondition)</span>
        }
        <span class="cov0" title="0">return v2Request</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package policysetcontrollerv2

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client        *zpa.Client
        microTenantID *string
}

func New(c *zpa.Client) *Service <span class="cov10" title="2">{
        return &amp;Service{Client: c}
}</span>

func (service *Service) WithMicroTenant(microTenantID string) *Service <span class="cov0" title="0">{
        var mid *string
        if microTenantID != "" </span><span class="cov0" title="0">{
                mid_ := microTenantID
                mid = &amp;mid_
        }</span>
        <span class="cov0" title="0">return &amp;Service{
                Client:        service.Client,
                microTenantID: mid,
        }</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package postureprofile

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client *zpa.Client
}

func New(c *zpa.Client) *Service <span class="cov10" title="5">{
        return &amp;Service{Client: c}
}</span>
</pre>
		
		<pre class="file" id="file68" style="display: none">package postureprofile

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfigV1           = "/mgmtconfig/v1/admin/customers/"
        mgmtConfigV2           = "/mgmtconfig/v2/admin/customers/"
        postureProfileEndpoint = "/posture"
)

// PostureProfile ...
type PostureProfile struct {
        ID                             string `json:"id,omitempty"`
        Name                           string `json:"name,omitempty"`
        ApplyToMachineTunnelEnabled    bool   `json:"applyToMachineTunnelEnabled"`
        CRLCheckEnabled                bool   `json:"crlCheckEnabled"`
        NonExportablePrivateKeyEnabled bool   `json:"nonExportablePrivateKeyEnabled"`
        Platform                       string `json:"platform,omitempty"`
        CreationTime                   string `json:"creationTime,omitempty"`
        Domain                         string `json:"domain,omitempty"`
        MasterCustomerID               string `json:"masterCustomerId,omitempty"`
        ModifiedBy                     string `json:"modifiedBy,omitempty"`
        ModifiedTime                   string `json:"modifiedTime,omitempty"`
        PostureType                    string `json:"postureType,omitempty"`
        PostureudID                    string `json:"postureUdid,omitempty"`
        RootCert                       string `json:"rootCert,omitempty"`
        ZscalerCloud                   string `json:"zscalerCloud,omitempty"`
        ZscalerCustomerID              string `json:"zscalerCustomerId,omitempty"`
}

func (service *Service) Get(id string) (*PostureProfile, *http.Response, error) <span class="cov1" title="1">{
        v := new(PostureProfile)
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfigV1+service.Client.Config.CustomerID+postureProfileEndpoint, id)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, nil, nil, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return v, resp, nil</span>
}

func (service *Service) GetByPostureUDID(postureUDID string) (*PostureProfile, *http.Response, error) <span class="cov1" title="1">{
        relativeURL := fmt.Sprintf(mgmtConfigV2 + service.Client.Config.CustomerID + postureProfileEndpoint)
        list, resp, err := common.GetAllPagesGeneric[PostureProfile](service.Client, relativeURL, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">for _, postureProfile := range list </span><span class="cov10" title="9">{
                if postureProfile.PostureudID == postureUDID </span><span class="cov1" title="1">{
                        return &amp;postureProfile, resp, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, resp, fmt.Errorf("no posture profile with postureUDID '%s' was found", postureUDID)</span>
}

func (service *Service) GetByName(postureName string) (*PostureProfile, *http.Response, error) <span class="cov8" title="7">{
        adaptedPostureName := common.RemoveCloudSuffix(postureName)
        relativeURL := mgmtConfigV2 + service.Client.Config.CustomerID + postureProfileEndpoint

        // Set up custom filters for pagination
        filters := common.Filter{Search: adaptedPostureName} // Using the adapted posture name for searching

        // Use the custom pagination function with custom filters
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[PostureProfile](service.Client, relativeURL, filters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // Iterate through the list and find the posture profile by its name
        <span class="cov8" title="7">for _, postureProfile := range list </span><span class="cov10" title="9">{
                if strings.EqualFold(common.RemoveCloudSuffix(postureProfile.Name), adaptedPostureName) </span><span class="cov7" title="5">{
                        return &amp;postureProfile, resp, nil
                }</span>
        }
        <span class="cov3" title="2">return nil, resp, fmt.Errorf("no posture profile named '%s' was found", postureName)</span>
}

func (service *Service) GetAll() ([]PostureProfile, *http.Response, error) <span class="cov3" title="2">{
        relativeURL := mgmtConfigV2 + service.Client.Config.CustomerID + postureProfileEndpoint
        list, resp, err := common.GetAllPagesGeneric[PostureProfile](service.Client, relativeURL, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov3" title="2">return list, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package praapproval

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfig                 = "/mgmtconfig/v1/admin/customers/"
        privilegedApprovalEndpoint = "/approval"
)

type PrivilegedApproval struct {
        // The unique identifier of the privileged approval.
        ID string `json:"id,omitempty"`

        // The email address of the user that you are assigning the privileged approval to.
        EmailIDs []string `json:"emailIds,omitempty"`

        // The start date that the user has access to the privileged approval.
        StartTime string `json:"startTime,omitempty"`

        // StartTime    time.Time      `json:"startTime,omitempty"`
        // EndTime      time.Time      `json:"endTime,omitempty"`
        // The end date that the user no longer has access to the privileged approval.
        EndTime string `json:"endTime,omitempty"`

        // The status of the privileged approval. The supported values are:
        // INVALID: The privileged approval is invalid.
        // ACTIVE: The privileged approval is currently available for the user.
        // FUTURE: The privileged approval is available for a user at a set time in the future.
        // EXPIRED: The privileged approval is no longer available for the user.
        Status string `json:"status,omitempty"`

        // The time the privileged approval is created.
        CreationTime string `json:"creationTime,omitempty"`

        // The unique identifier of the tenant who modified the privileged approval.
        ModifiedBy string `json:"modifiedBy,omitempty"`

        // The time the privileged approval is modified.
        ModifiedTime string `json:"modifiedTime,omitempty"`

        // The unique identifier of the Microtenant for the ZPA tenant.
        // If you are within the Default Microtenant, pass microtenantId as 0 when making requests to retrieve data from the Default Microtenant.
        // Pass microtenantId as null to retrieve data from all customers associated with the tenant.
        MicroTenantID string `json:"microtenantId,omitempty"`

        // The name of the Microtenant.
        MicroTenantName string `json:"microtenantName,omitempty"`

        WorkingHours *WorkingHours `json:"workingHours"`
        // The List of application segments
        Applications []Applications `json:"applications"`
}

// The List of application segments
type Applications struct {
        ID   string `json:"id,omitempty"`
        Name string `json:"name,omitempty"`
}

type WorkingHours struct {
        // The days of the week that you want to enable the privileged approval.
        Days []string `json:"days,omitempty"`
        // EndTime       time.Time `json:"endTime,omitempty"`
        // StartTime     time.Time `json:"startTime,omitempty"`

        // The start time that the user has access to the privileged approval.
        StartTime string `json:"startTime,omitempty"`

        // The end time that the user no longer has access to the privileged approval.
        EndTime string `json:"endTime,omitempty"`

        //The cron expression provided to configure the privileged approval start time working hours.
        // The standard cron expression format is [Seconds][Minutes][Hours][Day of the Month][Month][Day of the Week][Year].
        // For example, 0 15 10 ? * MON-FRI represents the start time working hours for 10:15 AM every Monday, Tuesday, Wednesday, Thursday and Friday.
        StartTimeCron string `json:"startTimeCron,omitempty"`

        // The cron expression provided to configure the privileged approval end time working hours.
        // The standard cron expression format is [Seconds][Minutes][Hours][Day of the Month][Month][Day of the Week][Year].
        // For example, 0 15 10 ? * MON-FRI represents the end time working hours for 10:15 AM every Monday, Tuesday, Wednesday, Thursday and Friday.
        EndTimeCron string `json:"endTimeCron,omitempty"`

        // The time zone for the time window of a privileged approval.
        TimeZone string `json:"timeZone,omitempty"`
        // TimeZone *time.Location `json:"timeZone,omitempty"`
}

func (service *Service) Get(approvalID string) (*PrivilegedApproval, *http.Response, error) <span class="cov10" title="4">{
        v := new(PrivilegedApproval)
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+privilegedApprovalEndpoint, approvalID)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, common.Filter{MicroTenantID: service.microTenantID}, nil, v)
        if err != nil </span><span class="cov5" title="2">{
                return nil, nil, err
        }</span>
        <span class="cov5" title="2">return v, resp, nil</span>
}

func (service *Service) GetByEmailID(emailID string) (*PrivilegedApproval, *http.Response, error) <span class="cov0" title="0">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + privilegedApprovalEndpoint
        list, resp, err := common.GetAllPagesGeneric[PrivilegedApproval](service.Client, relativeURL, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">for _, app := range list </span><span class="cov0" title="0">{
                for _, appEmailID := range app.EmailIDs </span><span class="cov0" title="0">{
                        if strings.EqualFold(appEmailID, emailID) </span><span class="cov0" title="0">{
                                return &amp;app, resp, nil
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil, resp, fmt.Errorf("no privileged approval with emailID '%s' was found", emailID)</span>
}

func (service *Service) Create(privilegedApproval *PrivilegedApproval) (*PrivilegedApproval, *http.Response, error) <span class="cov1" title="1">{
        v := new(PrivilegedApproval)
        resp, err := service.Client.NewRequestDo("POST", mgmtConfig+service.Client.Config.CustomerID+privilegedApprovalEndpoint, common.Filter{MicroTenantID: service.microTenantID}, privilegedApproval, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return v, resp, nil</span>
}

func (service *Service) Update(approvalID string, privilegedApproval *PrivilegedApproval) (*http.Response, error) <span class="cov5" title="2">{
        relativeURL := fmt.Sprintf("%v/%v", mgmtConfig+service.Client.Config.CustomerID+privilegedApprovalEndpoint, approvalID)
        resp, err := service.Client.NewRequestDo("PUT", relativeURL, common.Filter{MicroTenantID: service.microTenantID}, privilegedApproval, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return resp, err</span>
}

func (service *Service) Delete(approvalID string) (*http.Response, error) <span class="cov5" title="2">{
        relativeURL := fmt.Sprintf("%v/%v", mgmtConfig+service.Client.Config.CustomerID+privilegedApprovalEndpoint, approvalID)
        resp, err := service.Client.NewRequestDo("DELETE", relativeURL, common.Filter{MicroTenantID: service.microTenantID}, nil, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return resp, err</span>
}

func (service *Service) DeleteExpired() (*http.Response, error) <span class="cov1" title="1">{
        path := fmt.Sprintf("%s%s%s/expired", mgmtConfig, service.Client.Config.CustomerID, privilegedApprovalEndpoint)
        resp, err := service.Client.NewRequestDo("DELETE", path, common.Filter{MicroTenantID: service.microTenantID}, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return resp, nil</span>
}

func (service *Service) GetAll() ([]PrivilegedApproval, *http.Response, error) <span class="cov1" title="1">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + privilegedApprovalEndpoint
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[PrivilegedApproval](service.Client, relativeURL, common.Filter{MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return list, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package praapproval

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client        *zpa.Client
        microTenantID *string
}

func New(c *zpa.Client) *Service <span class="cov10" title="5">{
        return &amp;Service{Client: c}
}</span>

func (service *Service) WithMicroTenant(microTenantID string) *Service <span class="cov0" title="0">{
        var mid *string
        if microTenantID != "" </span><span class="cov0" title="0">{
                mid_ := microTenantID
                mid = &amp;mid_
        }</span>
        <span class="cov0" title="0">return &amp;Service{
                Client:        service.Client,
                microTenantID: mid,
        }</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package praconsole

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfig             = "/mgmtconfig/v1/admin/customers/"
        praConsoleEndpoint     = "/praConsole"
        praConsoleBulkEndpoint = "/praConsole/bulk"
)

type PRAConsole struct {
        // The unique identifier of the privileged console
        ID string `json:"id,omitempty"`

        // The name of the privileged console.
        Name string `json:"name,omitempty"`

        // The description of the privileged console.
        Description string `json:"description,omitempty"`

        // Whether or not the privileged console is enabled.
        Enabled bool `json:"enabled"`

        // The privileged console icon. The icon image is converted to base64 encoded text format.
        IconText string `json:"iconText,omitempty"`

        // The time the privileged console is created.
        CreationTime string `json:"creationTime,omitempty"`

        // The tenant who modified the privileged console.
        ModifiedBy string `json:"modifiedBy,omitempty"`

        // The time the privileged console is modified.
        ModifiedTime    string         `json:"modifiedTime,omitempty"`
        MicroTenantID   string         `json:"microtenantId,omitempty"`
        MicroTenantName string         `json:"microtenantName,omitempty"`
        PRAApplication  PRAApplication `json:"praApplication,omitempty"`
        PRAPortals      []PRAPortals   `json:"praPortals"`
}

type PRAApplication struct {
        // The unique identifier of the Privileged Remote Access-enabled application.
        ID string `json:"id,omitempty"`
        // The name of the Privileged Remote Access-enabled application.
        Name string `json:"name,omitempty"`
}

type PRAPortals struct {
        // The unique identifier of the privileged portal.
        ID string `json:"id,omitempty"`
        // The name of the privileged portal.
        Name string `json:"name,omitempty"`
}

func (service *Service) Get(consoleID string) (*PRAConsole, *http.Response, error) <span class="cov1" title="1">{
        v := new(PRAConsole)
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+praConsoleEndpoint, consoleID)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, common.Filter{MicroTenantID: service.microTenantID}, nil, v)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">return v, resp, nil</span>
}

func (service *Service) GetPraPortal(portalID string) (*PRAConsole, *http.Response, error) <span class="cov0" title="0">{
        v := new(PRAConsole)
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+praConsoleEndpoint+"/praPortal", portalID)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, common.Filter{MicroTenantID: service.microTenantID}, nil, v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">return v, resp, nil</span>
}

func (service *Service) GetByName(consoleName string) (*PRAConsole, *http.Response, error) <span class="cov1" title="1">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + praConsoleEndpoint
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[PRAConsole](service.Client, relativeURL, common.Filter{Search: consoleName, MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">for _, cred := range list </span><span class="cov0" title="0">{
                if strings.EqualFold(cred.Name, consoleName) </span><span class="cov0" title="0">{
                        return &amp;cred, resp, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, resp, fmt.Errorf("no pra  console named '%s' was found", consoleName)</span>
}

func (service *Service) Create(praConsole *PRAConsole) (*PRAConsole, *http.Response, error) <span class="cov0" title="0">{
        v := new(PRAConsole)
        resp, err := service.Client.NewRequestDo("POST", mgmtConfig+service.Client.Config.CustomerID+praConsoleEndpoint, common.Filter{MicroTenantID: service.microTenantID}, praConsole, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return v, resp, nil</span>
}

func (service *Service) CreatePraBulk(praConsoles []PRAConsole) ([]PRAConsole, *http.Response, error) <span class="cov1" title="1">{
        var responseConsoles []PRAConsole
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + praConsoleBulkEndpoint
        resp, err := service.Client.NewRequestDo("POST", relativeURL, common.Filter{MicroTenantID: service.microTenantID}, praConsoles, &amp;responseConsoles)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return responseConsoles, resp, nil</span>
}

func (service *Service) Update(consoleID string, praConsole *PRAConsole) (*http.Response, error) <span class="cov10" title="3">{
        relativeURL := fmt.Sprintf("%v/%v", mgmtConfig+service.Client.Config.CustomerID+praConsoleEndpoint, consoleID)
        resp, err := service.Client.NewRequestDo("PUT", relativeURL, common.Filter{MicroTenantID: service.microTenantID}, praConsole, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov6" title="2">return resp, err</span>
}

func (service *Service) Delete(consoleID string) (*http.Response, error) <span class="cov10" title="3">{
        relativeURL := fmt.Sprintf("%v/%v", mgmtConfig+service.Client.Config.CustomerID+praConsoleEndpoint, consoleID)
        resp, err := service.Client.NewRequestDo("DELETE", relativeURL, common.Filter{MicroTenantID: service.microTenantID}, nil, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov6" title="2">return resp, err</span>
}

func (service *Service) GetAll() ([]PRAConsole, *http.Response, error) <span class="cov1" title="1">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + praConsoleEndpoint
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[PRAConsole](service.Client, relativeURL, common.Filter{MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return list, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package praconsole

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client        *zpa.Client
        microTenantID *string
}

func New(c *zpa.Client) *Service <span class="cov10" title="5">{
        return &amp;Service{Client: c}
}</span>

func (service *Service) WithMicroTenant(microTenantID string) *Service <span class="cov0" title="0">{
        var mid *string
        if microTenantID != "" </span><span class="cov0" title="0">{
                mid_ := microTenantID
                mid = &amp;mid_
        }</span>
        <span class="cov0" title="0">return &amp;Service{
                Client:        service.Client,
                microTenantID: mid,
        }</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package pracredential

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfig         = "/mgmtconfig/v1/admin/customers/"
        credentialEndpoint = "/credential"
)

type Credential struct {
        // The unique identifier of the privileged credential
        ID string `json:"id,omitempty"`

        //The name of the privileged credential.
        Name string `json:"name,omitempty"`

        // The description of the privileged credential.
        Description string `json:"description,omitempty"`

        // The time the privileged credential was last reset.
        LastCredentialResetTime string `json:"lastCredentialResetTime,omitempty"`

        // The protocol type that was designated for that particular privileged credential.
        // The protocol type options are SSH, RDP, and VNC. Each protocol type has its own credential requirements.
        CredentialType string `json:"credentialType,omitempty"`

        // The password that is used to protect the SSH private key. This field is optional.
        Passphrase string `json:"passphrase,omitempty"`

        // The password associated with the username for the login you want to use for the privileged credential.
        Password string `json:"password,omitempty"`

        // The SSH private key associated with the username for the login you want to use for the privileged credential.
        PrivateKey string `json:"privateKey,omitempty"`

        // The domain name associated with the username.
        // You can also include the domain name as part of the username.
        // The domain name only needs to be specified with logging in to an RDP console that is connected to an Active Directory Domain.
        UserDomain string `json:"userDomain,omitempty"`

        // The username for the login you want to use for the privileged credential.
        UserName string `json:"userName,omitempty"`

        // The time the privileged credential is created.
        CreationTime string `json:"creationTime,omitempty"`

        // The unique identifier of the tenant who modified the privileged credential.
        ModifiedBy string `json:"modifiedBy,omitempty"`

        // The time the privileged credential is modified.
        ModifiedTime string `json:"modifiedTime,omitempty"`

        // The unique identifier of the Microtenant for the ZPA tenant.
        // If you are within the Default Microtenant, pass microtenantId as 0 when making requests to retrieve data from the Default Microtenant.
        // Pass microtenantId as null to retrieve data from all customers associated with the tenant.
        MicroTenantID string `json:"microtenantId,omitempty"`

        // The name of the Microtenant.
        MicroTenantName string `json:"microtenantName,omitempty"`

        // The unique identifier of the target Microtenant that the privileged credential is being moved to.
        TargetMicrotenantId string `json:"targetMicrotenantId,omitempty"`
}

func (service *Service) Get(credentialID string) (*Credential, *http.Response, error) <span class="cov10" title="4">{
        v := new(Credential)
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+credentialEndpoint, credentialID)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, common.Filter{MicroTenantID: service.microTenantID}, nil, v)
        if err != nil </span><span class="cov5" title="2">{
                return nil, nil, err
        }</span>

        <span class="cov5" title="2">return v, resp, nil</span>
}

func (service *Service) GetByName(credentialName string) (*Credential, *http.Response, error) <span class="cov5" title="2">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + credentialEndpoint
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[Credential](service.Client, relativeURL, common.Filter{Search: credentialName, MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov5" title="2">for _, cred := range list </span><span class="cov1" title="1">{
                if strings.EqualFold(cred.Name, credentialName) </span><span class="cov1" title="1">{
                        return &amp;cred, resp, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, resp, fmt.Errorf("no credential controller named '%s' was found", credentialName)</span>
}

func (service *Service) Create(credential *Credential) (*Credential, *http.Response, error) <span class="cov1" title="1">{
        v := new(Credential)
        resp, err := service.Client.NewRequestDo("POST", mgmtConfig+service.Client.Config.CustomerID+credentialEndpoint, common.Filter{MicroTenantID: service.microTenantID}, credential, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return v, resp, nil</span>
}

func (service *Service) Update(credentialID string, credentialRequest *Credential) (*http.Response, error) <span class="cov5" title="2">{
        relativeURL := fmt.Sprintf("%v/%v", mgmtConfig+service.Client.Config.CustomerID+credentialEndpoint, credentialID)
        resp, err := service.Client.NewRequestDo("PUT", relativeURL, common.Filter{MicroTenantID: service.microTenantID}, credentialRequest, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp, err</span>
}

func (service *Service) Delete(credentialID string) (*http.Response, error) <span class="cov5" title="2">{
        relativeURL := fmt.Sprintf("%v/%v", mgmtConfig+service.Client.Config.CustomerID+credentialEndpoint, credentialID)
        resp, err := service.Client.NewRequestDo("DELETE", relativeURL, common.Filter{MicroTenantID: service.microTenantID}, nil, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return resp, err</span>
}

func (service *Service) CredentialMove(credentialID string, targetMicrotenantId string) (*http.Response, error) <span class="cov0" title="0">{
        // Construct the URL using the credentialEndpoint const and append "/move"
        relativeURL := fmt.Sprintf("%s%s%s/%s/move", mgmtConfig, service.Client.Config.CustomerID, credentialEndpoint, credentialID)

        // Append the targetMicrotenantId as a query parameter
        if targetMicrotenantId != "" </span><span class="cov0" title="0">{
                relativeURL += "?targetMicrotenantId=" + targetMicrotenantId
        }</span>

        // Make the POST request with an empty body since the API expects an empty body for this operation
        <span class="cov0" title="0">resp, err := service.Client.NewRequestDo("POST", relativeURL, nil, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}

func (service *Service) GetAll() ([]Credential, *http.Response, error) <span class="cov1" title="1">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + credentialEndpoint
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[Credential](service.Client, relativeURL, common.Filter{MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return list, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package pracredential

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client        *zpa.Client
        microTenantID *string
}

func New(c *zpa.Client) *Service <span class="cov10" title="5">{
        return &amp;Service{Client: c}
}</span>

func (service *Service) WithMicroTenant(microTenantID string) *Service <span class="cov0" title="0">{
        var mid *string
        if microTenantID != "" </span><span class="cov0" title="0">{
                mid_ := microTenantID
                mid = &amp;mid_
        }</span>
        <span class="cov0" title="0">return &amp;Service{
                Client:        service.Client,
                microTenantID: mid,
        }</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package praportal

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfig        = "/mgmtconfig/v1/admin/customers/"
        praPortalEndpoint = "/praPortal"
)

type PRAPortal struct {
        // The unique identifier of the privileged portal.
        ID string `json:"id,omitempty"`

        // The name of the privileged portal.
        Name string `json:"name,omitempty"`

        // The description of the privileged portal.
        Description string `json:"description,omitempty"`

        // Whether or not the privileged portal is enabled.
        Enabled bool `json:"enabled"`

        // The canonical name (CNAME DNS records) associated with the privileged portal.
        CName string `json:"cName,omitempty"`

        // The domain of the privileged portal.
        Domain string `json:"domain,omitempty"`

        // The unique identifier of the certificate.
        CertificateID string `json:"certificateId,omitempty"`

        // The name of the certificate.
        CertificateName string `json:"certificateName,omitempty"`

        // The time the privileged portal is created.
        CreationTime string `json:"creationTime,omitempty"`

        // The unique identifier of the tenant who modified the privileged portal.
        ModifiedBy string `json:"modifiedBy,omitempty"`

        // The time the privileged portal is modified.
        ModifiedTime string `json:"modifiedTime,omitempty"`

        // The notification message displayed in the banner of the privileged portallink, if enabled.
        UserNotification string `json:"userNotification"`

        // Indicates if the Notification Banner is enabled (true) or disabled (false).
        UserNotificationEnabled bool `json:"userNotificationEnabled"`

        MicroTenantID string `json:"microtenantId,omitempty"`

        // The name of the Microtenant.
        MicroTenantName string `json:"microtenantName,omitempty"`
}

func (service *Service) Get(portalID string) (*PRAPortal, *http.Response, error) <span class="cov10" title="4">{
        v := new(PRAPortal)
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+praPortalEndpoint, portalID)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, nil, nil, v)
        if err != nil </span><span class="cov5" title="2">{
                return nil, nil, err
        }</span>
        <span class="cov5" title="2">return v, resp, nil</span>
}

func (service *Service) GetByName(portalName string) (*PRAPortal, *http.Response, error) <span class="cov5" title="2">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + praPortalEndpoint
        list, resp, err := common.GetAllPagesGeneric[PRAPortal](service.Client, relativeURL, portalName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov5" title="2">for _, sra := range list </span><span class="cov1" title="1">{
                if strings.EqualFold(sra.Name, portalName) </span><span class="cov1" title="1">{
                        return &amp;sra, resp, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, resp, fmt.Errorf("no sra portal '%s' was found", portalName)</span>
}

func (service *Service) Create(sraPortal *PRAPortal) (*PRAPortal, *http.Response, error) <span class="cov1" title="1">{
        v := new(PRAPortal)
        resp, err := service.Client.NewRequestDo("POST", mgmtConfig+service.Client.Config.CustomerID+praPortalEndpoint, nil, sraPortal, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return v, resp, nil</span>
}

func (service *Service) Update(portalID string, sraPortal *PRAPortal) (*http.Response, error) <span class="cov5" title="2">{
        path := fmt.Sprintf("%v/%v", mgmtConfig+service.Client.Config.CustomerID+praPortalEndpoint, portalID)
        resp, err := service.Client.NewRequestDo("PUT", path, nil, sraPortal, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return resp, err</span>
}

func (service *Service) Delete(portalID string) (*http.Response, error) <span class="cov5" title="2">{
        path := fmt.Sprintf("%v/%v", mgmtConfig+service.Client.Config.CustomerID+praPortalEndpoint, portalID)
        resp, err := service.Client.NewRequestDo("DELETE", path, common.Filter{MicroTenantID: service.microTenantID}, nil, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return resp, err</span>
}

func (service *Service) GetAll() ([]PRAPortal, *http.Response, error) <span class="cov1" title="1">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + praPortalEndpoint
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[PRAPortal](service.Client, relativeURL, common.Filter{MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return list, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package praportal

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client        *zpa.Client
        microTenantID *string
}

func New(c *zpa.Client) *Service <span class="cov10" title="5">{
        return &amp;Service{Client: c}
}</span>

func (service *Service) WithMicroTenant(microTenantID string) *Service <span class="cov0" title="0">{
        var mid *string
        if microTenantID != "" </span><span class="cov0" title="0">{
                mid_ := microTenantID
                mid = &amp;mid_
        }</span>
        <span class="cov0" title="0">return &amp;Service{
                Client:        service.Client,
                microTenantID: mid,
        }</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package provisioningkey

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client        *zpa.Client
        microTenantID *string
}

func New(c *zpa.Client) *Service <span class="cov8" title="1">{
        return &amp;Service{Client: c}
}</span>

func (service *Service) WithMicroTenant(microTenantID string) *Service <span class="cov0" title="0">{
        var mid *string
        if microTenantID != "" </span><span class="cov0" title="0">{
                mid_ := microTenantID
                mid = &amp;mid_
        }</span>
        <span class="cov0" title="0">return &amp;Service{
                Client:        service.Client,
                microTenantID: mid,
        }</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package provisioningkey

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfig = "/mgmtconfig/v1/admin/customers/"
)

// TODO: because there isn't an endpoint to get all provisionning keys, we need to have all association type here
var ProvisioningKeyAssociationTypes []string = []string{
        "CONNECTOR_GRP",
        "SERVICE_EDGE_GRP",
}

type ProvisioningKey struct {
        AppConnectorGroupID   string   `json:"appConnectorGroupId,omitempty"`
        AppConnectorGroupName string   `json:"appConnectorGroupName,omitempty"`
        CreationTime          string   `json:"creationTime,omitempty"`
        Enabled               bool     `json:"enabled,omitempty"`
        ExpirationInEpochSec  string   `json:"expirationInEpochSec,omitempty"`
        ID                    string   `json:"id,omitempty"`
        IPACL                 []string `json:"ipAcl,omitempty"`
        MaxUsage              string   `json:"maxUsage,omitempty"`
        ModifiedBy            string   `json:"modifiedBy,omitempty"`
        ModifiedTime          string   `json:"modifiedTime,omitempty"`
        Name                  string   `json:"name,omitempty"`
        ProvisioningKey       string   `json:"provisioningKey,omitempty"`
        EnrollmentCertID      string   `json:"enrollmentCertId,omitempty"`
        EnrollmentCertName    string   `json:"enrollmentCertName,omitempty"`
        UIConfig              string   `json:"uiConfig,omitempty"`
        UsageCount            string   `json:"usageCount,omitempty"`
        ZcomponentID          string   `json:"zcomponentId,omitempty"`
        ZcomponentName        string   `json:"zcomponentName,omitempty"`
        AssociationType       string   `json:"associationType"`
        MicroTenantID         string   `json:"microtenantId,omitempty"`
        MicroTenantName       string   `json:"microtenantName,omitempty"`
}

// GET --&gt; mgmtconfig/v1/admin/customers/{customerId}/associationType/{associationType}/provisioningKey
func (service *Service) Get(associationType, provisioningKeyID string) (*ProvisioningKey, *http.Response, error) <span class="cov10" title="3">{
        v := new(ProvisioningKey)
        url := fmt.Sprintf(mgmtConfig+service.Client.Config.CustomerID+"/associationType/%s/provisioningKey/%s", associationType, provisioningKeyID)
        resp, err := service.Client.NewRequestDo("GET", url, common.Filter{MicroTenantID: service.microTenantID}, nil, v)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov6" title="2">v.AssociationType = associationType
        return v, resp, nil</span>
}

// GET --&gt; mgmtconfig/v1/admin/customers/{customerId}/associationType/{associationType}/provisioningKey
func (service *Service) GetByName(associationType, name string) (*ProvisioningKey, *http.Response, error) <span class="cov1" title="1">{
        relativeURL := fmt.Sprintf(mgmtConfig+service.Client.Config.CustomerID+"/associationType/%s/provisioningKey", associationType)
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[ProvisioningKey](service.Client, relativeURL, common.Filter{Search: name, MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">for _, provisioningKey := range list </span><span class="cov1" title="1">{
                if strings.EqualFold(provisioningKey.Name, name) </span><span class="cov1" title="1">{
                        provisioningKey.AssociationType = associationType
                        return &amp;provisioningKey, resp, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, resp, fmt.Errorf("no Provisioning Key named '%s' was found", name)</span>
}

// POST --&gt; /mgmtconfig/v1/admin/customers/{customerId}/associationType/{associationType}/provisioningKey
func (service *Service) Create(associationType string, provisioningKey *ProvisioningKey) (*ProvisioningKey, *http.Response, error) <span class="cov1" title="1">{
        v := new(ProvisioningKey)
        path := fmt.Sprintf(mgmtConfig+service.Client.Config.CustomerID+"/associationType/%s/provisioningKey", associationType)
        resp, err := service.Client.NewRequestDo("POST", path, common.Filter{MicroTenantID: service.microTenantID}, provisioningKey, v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return v, resp, nil</span>
}

// PUT --&gt; /mgmtconfig/v1/admin/customers/{customerId}/associationType/{associationType}/provisioningKey/{provisioningKeyId}
func (service *Service) Update(associationType, provisioningKeyID string, provisioningKey *ProvisioningKey) (*http.Response, error) <span class="cov1" title="1">{
        path := fmt.Sprintf(mgmtConfig+service.Client.Config.CustomerID+"/associationType/%s/provisioningKey/%s", associationType, provisioningKeyID)
        resp, err := service.Client.NewRequestDo("PUT", path, common.Filter{MicroTenantID: service.microTenantID}, provisioningKey, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return resp, err</span>
}

// DELETE --&gt; /mgmtconfig/v1/admin/customers/{customerId}/associationType/{associationType}/provisioningKey/{provisioningKeyId}
func (service *Service) Delete(associationType, provisioningKeyID string) (*http.Response, error) <span class="cov1" title="1">{
        path := fmt.Sprintf(mgmtConfig+service.Client.Config.CustomerID+"/associationType/%s/provisioningKey/%s", associationType, provisioningKeyID)
        resp, err := service.Client.NewRequestDo("DELETE", path, common.Filter{MicroTenantID: service.microTenantID}, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return resp, err</span>
}

func (service *Service) GetByNameAllAssociations(name string) (p *ProvisioningKey, assoc_type string, resp *http.Response, err error) <span class="cov0" title="0">{
        for _, assassociation_type := range ProvisioningKeyAssociationTypes </span><span class="cov0" title="0">{
                p, resp, err = service.GetByName(assassociation_type, name)
                if err == nil </span><span class="cov0" title="0">{
                        assoc_type = assassociation_type
                        break</span>
                }
        }
        <span class="cov0" title="0">p.AssociationType = assoc_type
        return p, assoc_type, resp, err</span>
}

func (service *Service) GetByIDAllAssociations(id string) (p *ProvisioningKey, assoc_type string, resp *http.Response, err error) <span class="cov0" title="0">{
        for _, assassociation_type := range ProvisioningKeyAssociationTypes </span><span class="cov0" title="0">{
                p, resp, err = service.Get(assassociation_type, id)
                if err == nil </span><span class="cov0" title="0">{
                        assoc_type = assassociation_type
                        break</span>
                }
        }
        <span class="cov0" title="0">p.AssociationType = assoc_type
        return p, assoc_type, resp, err</span>
}

func (service *Service) GetAllByAssociationType(associationType string) ([]ProvisioningKey, error) <span class="cov6" title="2">{
        relativeURL := fmt.Sprintf(mgmtConfig+service.Client.Config.CustomerID+"/associationType/%s/provisioningKey", associationType)
        list, _, err := common.GetAllPagesGenericWithCustomFilters[ProvisioningKey](service.Client, relativeURL, common.Filter{MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="2">for i := range list </span><span class="cov6" title="2">{
                list[i].AssociationType = associationType
        }</span>
        <span class="cov6" title="2">return list, nil</span>
}

func (service *Service) GetAll() (list []ProvisioningKey, err error) <span class="cov1" title="1">{
        for _, assassociation_type := range ProvisioningKeyAssociationTypes </span><span class="cov6" title="2">{
                items, _ := service.GetAllByAssociationType(assassociation_type)
                if len(items) &gt; 0 </span><span class="cov1" title="1">{
                        list = append(list, items...)
                }</span>
        }
        <span class="cov1" title="1">return list, nil</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package samlattribute

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client *zpa.Client
}

func New(c *zpa.Client) *Service <span class="cov10" title="7">{
        return &amp;Service{Client: c}
}</span>
</pre>
		
		<pre class="file" id="file80" style="display: none">package samlattribute

import (
        "fmt"
        "net/http"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfig            = "/mgmtconfig/v2/admin/customers/"
        mgmtConfigV1          = "/mgmtconfig/v1/admin/customers/"
        samlAttributeEndpoint = "/samlAttribute"
)

type SamlAttribute struct {
        CreationTime  string `json:"creationTime,omitempty"`
        ID            string `json:"id,omitempty"`
        IdpID         string `json:"idpId,omitempty"`
        IdpName       string `json:"idpName,omitempty"`
        ModifiedBy    string `json:"modifiedBy,omitempty"`
        ModifiedTime  string `json:"modifiedTime,omitempty"`
        Name          string `json:"name,omitempty"`
        SamlName      string `json:"samlName,omitempty"`
        UserAttribute bool   `json:"userAttribute,omitempty"`
}

func (service *Service) Get(samlAttributeID string) (*SamlAttribute, *http.Response, error) <span class="cov4" title="2">{
        v := new(SamlAttribute)
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfigV1+service.Client.Config.CustomerID+samlAttributeEndpoint, samlAttributeID)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, nil, nil, v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov4" title="2">return v, resp, nil</span>
}

func (service *Service) GetByName(samlAttrName string) (*SamlAttribute, *http.Response, error) <span class="cov4" title="2">{
        relativeURL := fmt.Sprintf(mgmtConfig + service.Client.Config.CustomerID + samlAttributeEndpoint)
        list, resp, err := common.GetAllPagesGeneric[SamlAttribute](service.Client, relativeURL, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov4" title="2">for _, samlAttribute := range list </span><span class="cov10" title="6">{
                if samlAttribute.Name == samlAttrName </span><span class="cov1" title="1">{
                        return &amp;samlAttribute, resp, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, resp, fmt.Errorf("no saml attribute named '%s' was found", samlAttrName)</span>
}

func (service *Service) GetAll() ([]SamlAttribute, *http.Response, error) <span class="cov10" title="6">{
        relativeURL := fmt.Sprintf(mgmtConfig + service.Client.Config.CustomerID + samlAttributeEndpoint)
        list, resp, err := common.GetAllPagesGeneric[SamlAttribute](service.Client, relativeURL, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov10" title="6">return list, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package scimattributeheader

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client *zpa.Client
}

func New(c *zpa.Client) *Service <span class="cov10" title="8">{
        return &amp;Service{Client: c}
}</span>
</pre>
		
		<pre class="file" id="file82" style="display: none">package scimattributeheader

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfig       = "/mgmtconfig/v1/admin/customers/"
        userConfig       = "/userconfig/v1/customers"
        idpId            = "/idp"
        scimAttrEndpoint = "/scimattribute"
)

type ScimAttributeHeader struct {
        CanonicalValues []string `json:"canonicalValues,omitempty"`
        CaseSensitive   bool     `json:"caseSensitive,omitempty"`
        CreationTime    string   `json:"creationTime,omitempty,"`
        DataType        string   `json:"dataType,omitempty"`
        Description     string   `json:"description,omitempty"`
        ID              string   `json:"id,omitempty"`
        IdpID           string   `json:"idpId,omitempty"`
        ModifiedBy      string   `json:"modifiedBy,omitempty"`
        ModifiedTime    string   `json:"modifiedTime,omitempty"`
        MultiValued     bool     `json:"multivalued,omitempty"`
        Mutability      string   `json:"mutability,omitempty"`
        Name            string   `json:"name,omitempty"`
        Required        bool     `json:"required,omitempty"`
        Returned        string   `json:"returned,omitempty"`
        SchemaURI       string   `json:"schemaURI,omitempty"`
        Uniqueness      bool     `json:"uniqueness,omitempty"`
}

func (service *Service) Get(idpId, scimAttrHeaderID string) (*ScimAttributeHeader, *http.Response, error) <span class="cov3" title="2">{
        v := new(ScimAttributeHeader)
        relativeURL := fmt.Sprintf("%s/idp/%s/scimattribute/%s", mgmtConfig+service.Client.Config.CustomerID, idpId, scimAttrHeaderID)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, nil, nil, v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov3" title="2">return v, resp, nil</span>
}

// SearchValues searchs by features and fields for the API.
func (service *Service) SearchValues(idpId, ScimAttrHeaderID, searchQuery string) ([]string, error) <span class="cov0" title="0">{
        searchQuery = strings.Split(searchQuery, "@")[0]
        relativeURL := fmt.Sprintf("%s/%s/scimattribute/idpId/%s/attributeId/%s", userConfig, service.Client.Config.CustomerID, idpId, ScimAttrHeaderID)
        l, _, err := common.GetAllPagesGeneric[string](service.Client, relativeURL, searchQuery)
        return l, err
}</span>

func (service *Service) GetValues(idpId, ScimAttrHeaderID string) ([]string, error) <span class="cov1" title="1">{
        relativeURL := fmt.Sprintf("%s/%s/scimattribute/idpId/%s/attributeId/%s", userConfig, service.Client.Config.CustomerID, idpId, ScimAttrHeaderID)
        l, _, err := common.GetAllPagesGeneric[string](service.Client, relativeURL, "")
        return l, err
}</span>

func (service *Service) GetByName(scimAttributeName, IdpId string) (*ScimAttributeHeader, *http.Response, error) <span class="cov3" title="2">{
        relativeURL := fmt.Sprintf("%s/%s%s", mgmtConfig+service.Client.Config.CustomerID+idpId, IdpId, scimAttrEndpoint)
        list, resp, err := common.GetAllPagesGeneric[ScimAttributeHeader](service.Client, relativeURL, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov3" title="2">for _, scimAttribute := range list </span><span class="cov10" title="15">{
                if strings.EqualFold(scimAttribute.Name, scimAttributeName) </span><span class="cov1" title="1">{
                        return &amp;scimAttribute, resp, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, resp, fmt.Errorf("no scim named '%s' was found", scimAttributeName)</span>
}

func (service *Service) GetAllByIdpId(IdpId string) ([]ScimAttributeHeader, *http.Response, error) <span class="cov7" title="7">{
        relativeURL := fmt.Sprintf("%s/%s%s", mgmtConfig+service.Client.Config.CustomerID+idpId, IdpId, scimAttrEndpoint)
        list, resp, err := common.GetAllPagesGeneric[ScimAttributeHeader](service.Client, relativeURL, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov7" title="7">return list, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">package scimgroup

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type (
        SortOrder string
        SortField string
)

const (
        ASCSortOrder          SortOrder = "ASC"
        DESCSortOrder                   = "DESC"
        IDSortField           SortField = "id"
        NameSortField                   = "name"
        CreationTimeSortField           = "creationTime"
        ModifiedTimeSortField           = "modifiedTime"
)

type Service struct {
        Client    *zpa.Client
        sortOrder SortOrder
        sortBy    SortField
}

func New(c *zpa.Client) *Service <span class="cov10" title="8">{
        return &amp;Service{
                Client:    c,
                sortOrder: ASCSortOrder,
                sortBy:    NameSortField,
        }
}</span>

func (service *Service) WithSort(sortBy SortField, sortOrder SortOrder) *Service <span class="cov4" title="2">{
        c := Service{
                Client:    service.Client,
                sortOrder: service.sortOrder,
                sortBy:    service.sortBy,
        }
        if sortBy == IDSortField || sortBy == NameSortField || sortBy == CreationTimeSortField || sortBy == ModifiedTimeSortField </span><span class="cov4" title="2">{
                c.sortBy = sortBy
        }</span>

        <span class="cov4" title="2">if sortOrder == ASCSortOrder || sortOrder == DESCSortOrder </span><span class="cov4" title="2">{
                c.sortOrder = sortOrder
        }</span>
        <span class="cov4" title="2">return &amp;c</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">package scimgroup

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        userConfig        = "/userconfig/v1/customers/"
        scimGroupEndpoint = "/scimgroup"
        idpIdPath         = "/idpId"
)

type ScimGroup struct {
        CreationTime int64  `json:"creationTime,omitempty"`
        ID           int64  `json:"id,omitempty"`
        IdpGroupID   string `json:"idpGroupId,omitempty"`
        IdpID        int64  `json:"idpId,omitempty"`
        IdpName      string `json:"idpName,omitempty"`
        ModifiedTime int64  `json:"modifiedTime,omitempty"`
        Name         string `json:"name,omitempty"`
        InternalID   string `json:"internalId,omitempty"`
}

func (service *Service) Get(scimGroupID string) (*ScimGroup, *http.Response, error) <span class="cov4" title="2">{
        v := new(ScimGroup)
        relativeURL := fmt.Sprintf("%s/%s", userConfig+service.Client.Config.CustomerID+scimGroupEndpoint, scimGroupID)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, nil, nil, v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov4" title="2">return v, resp, nil</span>
}

func (service *Service) GetByName(scimName, idpId string) (*ScimGroup, *http.Response, error) <span class="cov7" title="4">{
        // Construct the API endpoint URL with query parameters
        relativeURL := fmt.Sprintf("%s/%s", userConfig+service.Client.Config.CustomerID+scimGroupEndpoint+idpIdPath, idpId)
        // Fetch the pages
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[ScimGroup](service.Client, relativeURL, common.Filter{
                Search:    scimName,
                SortBy:    string(service.sortBy),
                SortOrder: string(service.sortOrder),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, resp, err
        }</span>

        // Look for the group with the specified name
        <span class="cov7" title="4">for _, scim := range list </span><span class="cov6" title="3">{
                if strings.EqualFold(scim.Name, scimName) </span><span class="cov6" title="3">{
                        return &amp;scim, resp, nil
                }</span>
        }

        <span class="cov1" title="1">return nil, resp, fmt.Errorf("no SCIM group named '%s' was found", scimName)</span>
}

func (service *Service) GetAllByIdpId(idpId string) ([]ScimGroup, *http.Response, error) <span class="cov10" title="7">{
        relativeURL := fmt.Sprintf("%s/%s", userConfig+service.Client.Config.CustomerID+scimGroupEndpoint+idpIdPath, idpId)
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[ScimGroup](service.Client, relativeURL, common.Filter{
                SortBy:    string(service.sortBy),
                SortOrder: string(service.sortOrder),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov10" title="7">return list, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package segmentgroup

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client        *zpa.Client
        microTenantID *string
}

func New(c *zpa.Client) *Service <span class="cov10" title="5">{
        return &amp;Service{Client: c}
}</span>

func (service *Service) WithMicroTenant(microTenantID string) *Service <span class="cov0" title="0">{
        var mid *string
        if microTenantID != "" </span><span class="cov0" title="0">{
                mid_ := microTenantID
                mid = &amp;mid_
        }</span>
        <span class="cov0" title="0">return &amp;Service{
                Client:        service.Client,
                microTenantID: mid,
        }</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">package segmentgroup

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfig           = "/mgmtconfig/v1/admin/customers/"
        segmentGroupEndpoint = "/segmentGroup"
)

type SegmentGroup struct {
        Applications        []Application `json:"applications"`
        ConfigSpace         string        `json:"configSpace,omitempty"`
        CreationTime        string        `json:"creationTime,omitempty"`
        Description         string        `json:"description,omitempty"`
        Enabled             bool          `json:"enabled"`
        ID                  string        `json:"id,omitempty"`
        ModifiedBy          string        `json:"modifiedBy,omitempty"`
        ModifiedTime        string        `json:"modifiedTime,omitempty"`
        Name                string        `json:"name"`
        PolicyMigrated      bool          `json:"policyMigrated"`
        TcpKeepAliveEnabled string        `json:"tcpKeepAliveEnabled,omitempty"`
        MicroTenantID       string        `json:"microtenantId,omitempty"`
        MicroTenantName     string        `json:"microtenantName,omitempty"`
}

type Application struct {
        BypassType           string           `json:"bypassType,omitempty"`
        ConfigSpace          string           `json:"configSpace,omitempty"`
        CreationTime         string           `json:"creationTime,omitempty"`
        DefaultIdleTimeout   string           `json:"defaultIdleTimeout,omitempty"`
        DefaultMaxAge        string           `json:"defaultMaxAge,omitempty"`
        Description          string           `json:"description,omitempty"`
        DomainName           string           `json:"domainName,omitempty"`
        DomainNames          []string         `json:"domainNames,omitempty"`
        DoubleEncrypt        bool             `json:"doubleEncrypt"`
        Enabled              bool             `json:"enabled"`
        HealthCheckType      string           `json:"healthCheckType,omitempty"`
        ID                   string           `json:"id,omitempty"`
        IPAnchored           bool             `json:"ipAnchored"`
        LogFeatures          []string         `json:"logFeatures,omitempty"`
        ModifiedBy           string           `json:"modifiedBy,omitempty"`
        ModifiedTime         string           `json:"modifiedTime,omitempty"`
        Name                 string           `json:"name"`
        PassiveHealthEnabled bool             `json:"passiveHealthEnabled"`
        ServerGroup          []AppServerGroup `json:"serverGroups,omitempty"`
        TCPPortRanges        interface{}      `json:"tcpPortRanges,omitempty"`
        TCPPortsIn           interface{}      `json:"tcpPortsIn,omitempty"`
        TCPPortsOut          interface{}      `json:"tcpPortsOut,omitempty"`
        UDPPortRanges        interface{}      `json:"udpPortRangesg,omitempty"`
}

type AppServerGroup struct {
        ConfigSpace      string `json:"configSpace,omitempty"`
        CreationTime     string `json:"creationTime,omitempty"`
        Description      string `json:"description,omitempty"`
        Enabled          bool   `json:"enabled"`
        ID               string `json:"id,omitempty"`
        DynamicDiscovery bool   `json:"dynamicDiscovery"`
        ModifiedBy       string `json:"modifiedBy,omitempty"`
        ModifiedTime     string `json:"modifiedTime,omitempty"`
        Name             string `json:"name"`
}

func (service *Service) Get(segmentGroupID string) (*SegmentGroup, *http.Response, error) <span class="cov10" title="2">{
        v := new(SegmentGroup)
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+segmentGroupEndpoint, segmentGroupID)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, common.Filter{MicroTenantID: service.microTenantID}, nil, v)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return v, resp, nil</span>
}

func (service *Service) GetByName(segmentName string) (*SegmentGroup, *http.Response, error) <span class="cov10" title="2">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + segmentGroupEndpoint
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[SegmentGroup](service.Client, relativeURL, common.Filter{Search: segmentName, MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov10" title="2">for _, app := range list </span><span class="cov1" title="1">{
                if strings.EqualFold(app.Name, segmentName) </span><span class="cov1" title="1">{
                        return &amp;app, resp, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, resp, fmt.Errorf("no application named '%s' was found", segmentName)</span>
}

func (service *Service) Create(segmentGroup *SegmentGroup) (*SegmentGroup, *http.Response, error) <span class="cov1" title="1">{
        v := new(SegmentGroup)
        resp, err := service.Client.NewRequestDo("POST", mgmtConfig+service.Client.Config.CustomerID+segmentGroupEndpoint, common.Filter{MicroTenantID: service.microTenantID}, segmentGroup, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return v, resp, nil</span>
}

func (service *Service) Update(segmentGroupId string, segmentGroupRequest *SegmentGroup) (*http.Response, error) <span class="cov10" title="2">{
        path := fmt.Sprintf("%v/%v", mgmtConfig+service.Client.Config.CustomerID+segmentGroupEndpoint, segmentGroupId)
        resp, err := service.Client.NewRequestDo("PUT", path, common.Filter{MicroTenantID: service.microTenantID}, segmentGroupRequest, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return resp, err</span>
}

func (service *Service) Delete(segmentGroupId string) (*http.Response, error) <span class="cov10" title="2">{
        path := fmt.Sprintf("%v/%v", mgmtConfig+service.Client.Config.CustomerID+segmentGroupEndpoint, segmentGroupId)
        resp, err := service.Client.NewRequestDo("DELETE", path, common.Filter{MicroTenantID: service.microTenantID}, nil, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return resp, err</span>
}

func (service *Service) GetAll() ([]SegmentGroup, *http.Response, error) <span class="cov1" title="1">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + segmentGroupEndpoint
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[SegmentGroup](service.Client, relativeURL, common.Filter{MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return list, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package servergroup

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client        *zpa.Client
        microTenantID *string
}

func New(c *zpa.Client) *Service <span class="cov10" title="5">{
        return &amp;Service{Client: c}
}</span>

func (service *Service) WithMicroTenant(microTenantID string) *Service <span class="cov0" title="0">{
        var mid *string
        if microTenantID != "" </span><span class="cov0" title="0">{
                mid_ := microTenantID
                mid = &amp;mid_
        }</span>
        <span class="cov0" title="0">return &amp;Service{
                Client:        service.Client,
                microTenantID: mid,
        }</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package servergroup

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfig          = "/mgmtconfig/v1/admin/customers/"
        serverGroupEndpoint = "/serverGroup"
)

type ServerGroup struct {
        ID                 string               `json:"id,omitempty"`
        Enabled            bool                 `json:"enabled"`
        Name               string               `json:"name,omitempty"`
        Description        string               `json:"description,omitempty"`
        IpAnchored         bool                 `json:"ipAnchored"`
        ConfigSpace        string               `json:"configSpace,omitempty"`
        DynamicDiscovery   bool                 `json:"dynamicDiscovery"`
        CreationTime       string               `json:"creationTime,omitempty"`
        ModifiedBy         string               `json:"modifiedBy,omitempty"`
        ModifiedTime       string               `json:"modifiedTime,omitempty"`
        MicroTenantID      string               `json:"microtenantId,omitempty"`
        MicroTenantName    string               `json:"microtenantName,omitempty"`
        AppConnectorGroups []AppConnectorGroups `json:"appConnectorGroups"`
        Servers            []ApplicationServer  `json:"servers"`
        Applications       []Applications       `json:"applications"`
}

type Applications struct {
        ID   string `json:"id,omitempty"`
        Name string `json:"name,omitempty"`
}

type AppConnectorGroups struct {
        Citycountry           string            `json:"cityCountry,omitempty"`
        CountryCode           string            `json:"countryCode,omitempty"`
        CreationTime          string            `json:"creationTime,omitempty"`
        Description           string            `json:"description,omitempty"`
        DnsqueryType          string            `json:"dnsQueryType,omitempty"`
        Enabled               bool              `json:"enabled"`
        GeolocationID         string            `json:"geoLocationId,omitempty"`
        ID                    string            `json:"id,omitempty"`
        Latitude              string            `json:"latitude,omitempty"`
        Location              string            `json:"location,omitempty"`
        Longitude             string            `json:"longitude,omitempty"`
        ModifiedBy            string            `json:"modifiedBy,omitempty"`
        ModifiedTime          string            `json:"modifiedTime,omitempty"`
        Name                  string            `json:"name"`
        SiemAppconnectorGroup bool              `json:"siemAppConnectorGroup"`
        UpgradeDay            string            `json:"upgradeDay,omitempty"`
        UpgradeTimeinSecs     string            `json:"upgradeTimeInSecs,omitempty"`
        VersionProfileID      string            `json:"versionProfileId,omitempty"`
        AppServerGroups       []AppServerGroups `json:"serverGroups,omitempty"`
        Connectors            []Connectors      `json:"connectors,omitempty"`
}

type Connectors struct {
        ApplicationStartTime     string                 `json:"applicationStartTime,omitempty"`
        AppConnectorGroupID      string                 `json:"appConnectorGroupId,omitempty"`
        AppConnectorGroupName    string                 `json:"appConnectorGroupName,omitempty"`
        ControlChannelStatus     string                 `json:"controlChannelStatus,omitempty"`
        CreationTime             string                 `json:"creationTime,omitempty"`
        CtrlBrokerName           string                 `json:"ctrlBrokerName,omitempty"`
        CurrentVersion           string                 `json:"currentVersion,omitempty"`
        Description              string                 `json:"description,omitempty"`
        Enabled                  bool                   `json:"enabled"`
        ExpectedUpgradeTime      string                 `json:"expectedUpgradeTime,omitempty"`
        ExpectedVersion          string                 `json:"expectedVersion,omitempty"`
        Fingerprint              string                 `json:"fingerprint,omitempty"`
        ID                       string                 `json:"id,omitempty"`
        IPACL                    []string               `json:"ipAcl,omitempty"`
        IssuedCertID             string                 `json:"issuedCertId,omitempty"`
        LastBrokerConnecttime    string                 `json:"lastBrokerConnectTime,omitempty"`
        LastBrokerDisconnectTime string                 `json:"lastBrokerDisconnectTime,omitempty"`
        LastUpgradeTime          string                 `json:"lastUpgradeTime,omitempty"`
        Latitude                 float64                `json:"latitude,omitempty"`
        Location                 string                 `json:"location,omitempty"`
        Longitude                float64                `json:"longitude,omitempty"`
        ModifiedBy               string                 `json:"modifiedBy,omitempty"`
        ModifiedTime             string                 `json:"modifiedTime,omitempty"`
        Name                     string                 `json:"name"`
        Platform                 string                 `json:"platform,omitempty"`
        PreviousVersion          string                 `json:"previousVersion,omitempty"`
        PrivateIP                string                 `json:"privateIp,omitempty"`
        PublicIP                 string                 `json:"publicIp,omitempty"`
        SigningCert              map[string]interface{} `json:"signingCert,omitempty"`
        UpgradeAttempt           string                 `json:"upgradeAttempt,omitempty"`
        UpgradeStatus            string                 `json:"upgradeStatus,omitempty"`
}

type AppServerGroups struct {
        ConfigSpace      string `json:"configSpace,omitempty"`
        CreationTime     string `json:"creationTime,omitempty"`
        Description      string `json:"description,omitempty"`
        Enabled          bool   `json:"enabled"`
        ID               string `json:"id,omitempty"`
        DynamicDiscovery bool   `json:"dynamicDiscovery"`
        ModifiedBy       string `json:"modifiedBy,omitempty"`
        ModifiedTime     string `json:"modifiedTime,omitempty"`
        Name             string `json:"name"`
}

type ApplicationServer struct {
        Address           string   `json:"address,omitempty"`
        AppServerGroupIds []string `json:"appServerGroupIds,omitempty"`
        ConfigSpace       string   `json:"configSpace,omitempty"`
        CreationTime      string   `json:"creationTime,omitempty"`
        Description       string   `json:"description,omitempty"`
        Enabled           bool     `json:"enabled"`
        ID                string   `json:"id,omitempty"`
        ModifiedBy        string   `json:"modifiedBy,omitempty"`
        ModifiedTime      string   `json:"modifiedTime,omitempty"`
        Name              string   `json:"name"`
}

func (service *Service) Get(groupID string) (*ServerGroup, *http.Response, error) <span class="cov10" title="4">{
        v := new(ServerGroup)
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+serverGroupEndpoint, groupID)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, common.Filter{MicroTenantID: service.microTenantID}, nil, v)
        if err != nil </span><span class="cov5" title="2">{
                return nil, nil, err
        }</span>
        <span class="cov5" title="2">return v, resp, nil</span>
}

func (service *Service) GetByName(serverGroupName string) (*ServerGroup, *http.Response, error) <span class="cov5" title="2">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + serverGroupEndpoint
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[ServerGroup](service.Client, relativeURL, common.Filter{Search: serverGroupName, MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov5" title="2">for _, app := range list </span><span class="cov1" title="1">{
                if strings.EqualFold(app.Name, serverGroupName) </span><span class="cov1" title="1">{
                        return &amp;app, resp, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, resp, fmt.Errorf("no server group named '%s' was found", serverGroupName)</span>
}

func (service *Service) Create(serverGroup *ServerGroup) (*ServerGroup, *http.Response, error) <span class="cov1" title="1">{
        v := new(ServerGroup)
        resp, err := service.Client.NewRequestDo("POST", mgmtConfig+service.Client.Config.CustomerID+serverGroupEndpoint, common.Filter{MicroTenantID: service.microTenantID}, serverGroup, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return v, resp, nil</span>
}

func (service *Service) Update(groupId string, serverGroup *ServerGroup) (*http.Response, error) <span class="cov5" title="2">{
        path := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+serverGroupEndpoint, groupId)
        resp, err := service.Client.NewRequestDo("PUT", path, common.Filter{MicroTenantID: service.microTenantID}, serverGroup, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return resp, err</span>
}

func (service *Service) Delete(groupId string) (*http.Response, error) <span class="cov5" title="2">{
        path := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+serverGroupEndpoint, groupId)
        resp, err := service.Client.NewRequestDo("DELETE", path, common.Filter{MicroTenantID: service.microTenantID}, nil, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return resp, err</span>
}

func (service *Service) GetAll() ([]ServerGroup, *http.Response, error) <span class="cov1" title="1">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + serverGroupEndpoint
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[ServerGroup](service.Client, relativeURL, common.Filter{MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return list, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file89" style="display: none">package serviceedgecontroller

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client        *zpa.Client
        microTenantID *string
}

func New(c *zpa.Client) *Service <span class="cov0" title="0">{
        return &amp;Service{Client: c}
}</span>

func (service *Service) WithMicroTenant(microTenantID string) *Service <span class="cov0" title="0">{
        var mid *string
        if microTenantID != "" </span><span class="cov0" title="0">{
                mid_ := microTenantID
                mid = &amp;mid_
        }</span>
        <span class="cov0" title="0">return &amp;Service{
                Client:        service.Client,
                microTenantID: mid,
        }</span>
}
</pre>
		
		<pre class="file" id="file90" style="display: none">package serviceedgecontroller

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfig                    = "/mgmtconfig/v1/admin/customers/"
        serviceEdgeControllerEndpoint = "/serviceEdge"
)

type ServiceEdgeController struct {
        ApplicationStartTime             string                    `json:"applicationStartTime,omitempty"`
        ServiceEdgeGroupID               string                    `json:"serviceEdgeGroupId,omitempty"`
        ServiceEdgeGroupName             string                    `json:"serviceEdgeGroupName,omitempty"`
        ControlChannelStatus             string                    `json:"controlChannelStatus,omitempty"`
        CreationTime                     string                    `json:"creationTime,omitempty"`
        CtrlBrokerName                   string                    `json:"ctrlBrokerName,omitempty"`
        CurrentVersion                   string                    `json:"currentVersion,omitempty"`
        Description                      string                    `json:"description,omitempty"`
        Enabled                          bool                      `json:"enabled,omitempty"`
        ExpectedUpgradeTime              string                    `json:"expectedUpgradeTime,omitempty"`
        ExpectedVersion                  string                    `json:"expectedVersion,omitempty"`
        Fingerprint                      string                    `json:"fingerprint,omitempty"`
        ID                               string                    `json:"id,omitempty"`
        IPACL                            string                    `json:"ipAcl,omitempty"`
        IssuedCertID                     string                    `json:"issuedCertId,omitempty"`
        LastBrokerConnectTime            string                    `json:"lastBrokerConnectTime,omitempty"`
        LastBrokerConnectTimeDuration    string                    `json:"lastBrokerConnectTimeDuration,omitempty"`
        LastBrokerDisconnectTime         string                    `json:"lastBrokerDisconnectTime,omitempty"`
        LastBrokerDisconnectTimeDuration string                    `json:"lastBrokerDisconnectTimeDuration,omitempty"`
        LastUpgradeTime                  string                    `json:"lastUpgradeTime,omitempty"`
        Latitude                         string                    `json:"latitude,omitempty"`
        Location                         string                    `json:"location,omitempty"`
        Longitude                        string                    `json:"longitude,omitempty"`
        ListenIPs                        string                    `json:"listenIps,omitempty"`
        ModifiedBy                       string                    `json:"modifiedBy,omitempty"`
        ModifiedTime                     string                    `json:"modifiedTime,omitempty"`
        Name                             string                    `json:"name,omitempty"`
        ProvisioningKeyID                string                    `json:"provisioningKeyId"`
        ProvisioningKeyName              string                    `json:"provisioningKeyName"`
        Platform                         string                    `json:"platform,omitempty"`
        PreviousVersion                  string                    `json:"previousVersion,omitempty"`
        PrivateIP                        string                    `json:"privateIp,omitempty"`
        PublicIP                         string                    `json:"publicIp,omitempty"`
        PublishIPs                       string                    `json:"publishIps,omitempty"`
        SargeVersion                     string                    `json:"sargeVersion,omitempty"`
        EnrollmentCert                   map[string]interface{}    `json:"enrollmentCert,omitempty"`
        UpgradeAttempt                   string                    `json:"upgradeAttempt,omitempty"`
        UpgradeStatus                    string                    `json:"upgradeStatus,omitempty"`
        MicroTenantID                    string                    `json:"microtenantId,omitempty"`
        MicroTenantName                  string                    `json:"microtenantName,omitempty"`
        ZPNSubModuleUpgradeList          []ZPNSubModuleUpgradeList `json:"zpnSubModuleUpgradeList,omitempty"`
}

type ZPNSubModuleUpgradeList struct {
        ID              string `json:"id,omitempty"`
        CreationTime    string `json:"creationTime,omitempty"`
        CurrentVersion  string `json:"currentVersion,omitempty"`
        EntityGid       string `json:"entityGid,omitempty"`
        EntityType      string `json:"entityType,omitempty"`
        ExpectedVersion string `json:"expectedVersion,omitempty"`
        ModifiedBy      string `json:"modifiedBy,omitempty"`
        ModifiedTime    string `json:"modifiedTime,omitempty"`
        PreviousVersion string `json:"previousVersion,omitempty"`
        Role            string `json:"role,omitempty"`
        UpgradeStatus   string `json:"upgradeStatus,omitempty"`
        UpgradeTime     string `json:"upgradeTime,omitempty"`
}

func (service *Service) Get(serviceEdgeID string) (*ServiceEdgeController, *http.Response, error) <span class="cov0" title="0">{
        v := new(ServiceEdgeController)
        path := fmt.Sprintf("%v/%v", mgmtConfig+service.Client.Config.CustomerID+serviceEdgeControllerEndpoint, serviceEdgeID)
        resp, err := service.Client.NewRequestDo("GET", path, common.Filter{MicroTenantID: service.microTenantID}, nil, v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return v, resp, nil</span>
}

func (service *Service) GetByName(serviceEdgeName string) (*ServiceEdgeController, *http.Response, error) <span class="cov0" title="0">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + serviceEdgeControllerEndpoint
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[ServiceEdgeController](service.Client, relativeURL, common.Filter{Search: serviceEdgeName, MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">for _, service := range list </span><span class="cov0" title="0">{
                if strings.EqualFold(service.Name, serviceEdgeName) </span><span class="cov0" title="0">{
                        return &amp;service, resp, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, resp, fmt.Errorf("no service edge named '%s' was found", serviceEdgeName)</span>
}

func (service *Service) GetAll() ([]ServiceEdgeController, *http.Response, error) <span class="cov0" title="0">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + serviceEdgeControllerEndpoint
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[ServiceEdgeController](service.Client, relativeURL, common.Filter{MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return list, resp, nil</span>
}

type BulkDeleteRequest struct {
        IDs []string `json:"ids"`
}

// Update Updates the Service Edge details for the specified ID.
func (service *Service) Update(serviceEdgeID string, serviceEdge ServiceEdgeController) (*ServiceEdgeController, *http.Response, error) <span class="cov0" title="0">{
        path := fmt.Sprintf("%v/%v", mgmtConfig+service.Client.Config.CustomerID+serviceEdgeControllerEndpoint, serviceEdgeID)
        _, err := service.Client.NewRequestDo("PUT", path, common.Filter{MicroTenantID: service.microTenantID}, serviceEdgeID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">resource, resp, err := service.Get(serviceEdgeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return resource, resp, nil</span>
}

// Delete Deletes the Service Edge for the specified ID.
func (service *Service) Delete(serviceEdgeID string) (*http.Response, error) <span class="cov0" title="0">{
        path := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+serviceEdgeControllerEndpoint, serviceEdgeID)
        resp, err := service.Client.NewRequestDo("DELETE", path, common.Filter{MicroTenantID: service.microTenantID}, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resp, err</span>
}

// BulkDelete Bulk deletes the Service Edge.
func (service *Service) BulkDelete(serviceEdgeIDs []string) (*http.Response, error) <span class="cov0" title="0">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + serviceEdgeControllerEndpoint + "/bulkDelete"
        resp, err := service.Client.NewRequestDo("POST", relativeURL, common.Filter{MicroTenantID: service.microTenantID}, BulkDeleteRequest{IDs: serviceEdgeIDs}, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">package serviceedgegroup

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client        *zpa.Client
        microTenantID *string
}

func New(c *zpa.Client) *Service <span class="cov10" title="5">{
        return &amp;Service{Client: c}
}</span>

func (service *Service) WithMicroTenant(microTenantID string) *Service <span class="cov0" title="0">{
        var mid *string
        if microTenantID != "" </span><span class="cov0" title="0">{
                mid_ := microTenantID
                mid = &amp;mid_
        }</span>
        <span class="cov0" title="0">return &amp;Service{
                Client:        service.Client,
                microTenantID: mid,
        }</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">package serviceedgegroup

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfig               = "/mgmtconfig/v1/admin/customers/"
        serviceEdgeGroupEndpoint = "/serviceEdgeGroup"
)

type ServiceEdgeGroup struct {
        CityCountry                   string            `json:"cityCountry,omitempty"`
        CountryCode                   string            `json:"countryCode,omitempty"`
        CreationTime                  string            `json:"creationTime,omitempty"`
        Description                   string            `json:"description,omitempty"`
        Enabled                       bool              `json:"enabled"`
        GeoLocationID                 string            `json:"geoLocationId,omitempty"`
        GraceDistanceEnabled          bool              `json:"graceDistanceEnabled"`
        GraceDistanceValue            string            `json:"graceDistanceValue,omitempty"`
        GraceDistanceValueUnit        string            `json:"graceDistanceValueUnit,omitempty"`
        ID                            string            `json:"id,omitempty"`
        IsPublic                      string            `json:"isPublic,omitempty"`
        Latitude                      string            `json:"latitude,omitempty"`
        Location                      string            `json:"location,omitempty"`
        Longitude                     string            `json:"longitude,omitempty"`
        ModifiedBy                    string            `json:"modifiedBy,omitempty"`
        ModifiedTime                  string            `json:"modifiedTime,omitempty"`
        Name                          string            `json:"name,omitempty"`
        UseInDrMode                   bool              `json:"useInDrMode"`
        OverrideVersionProfile        bool              `json:"overrideVersionProfile"`
        ServiceEdges                  []ServiceEdges    `json:"serviceEdges,omitempty"`
        TrustedNetworks               []TrustedNetworks `json:"trustedNetworks,omitempty"`
        UpgradeDay                    string            `json:"upgradeDay,omitempty"`
        UpgradeTimeInSecs             string            `json:"upgradeTimeInSecs,omitempty"`
        VersionProfileID              string            `json:"versionProfileId,omitempty"`
        VersionProfileName            string            `json:"versionProfileName,omitempty"`
        VersionProfileVisibilityScope string            `json:"versionProfileVisibilityScope,omitempty"`
        ObjectType                    string            `json:"objectType,omitempty"`
        ScopeName                     string            `json:"scopeName,omitempty"`
        RestrictedEntity              bool              `json:"restrictedEntity,omitempty"`
        AltCloud                      string            `json:"altCloud,omitempty"`
        MicroTenantID                 string            `json:"microtenantId,omitempty"`
        MicroTenantName               string            `json:"microtenantName,omitempty"`
}

type ServiceEdges struct {
        ApplicationStartTime             string                 `json:"applicationStartTime,omitempty"`
        ControlChannelStatus             string                 `json:"controlChannelStatus,omitempty"`
        CreationTime                     string                 `json:"creationTime,omitempty"`
        CtrlBrokerName                   string                 `json:"ctrlBrokerName,omitempty"`
        CurrentVersion                   string                 `json:"currentVersion,omitempty"`
        Description                      string                 `json:"description,omitempty"`
        Enabled                          bool                   `json:"enabled"`
        ExpectedUpgradeTime              string                 `json:"expectedUpgradeTime,omitempty"`
        ExpectedVersion                  string                 `json:"expectedVersion,omitempty"`
        Fingerprint                      string                 `json:"fingerprint,omitempty"`
        ID                               string                 `json:"id,omitempty"`
        IPACL                            []string               `json:"ipAcl,omitempty"`
        IssuedCertID                     string                 `json:"issuedCertId,omitempty"`
        LastBrokerConnectTime            string                 `json:"lastBrokerConnectTime,omitempty"`
        LastBrokerConnectTimeDuration    string                 `json:"lastBrokerConnectTimeDuration,omitempty"`
        LastBrokerDisconnectTime         string                 `json:"lastBrokerDisconnectTime,omitempty"`
        LastBrokerDisconnectTimeDuration string                 `json:"lastBrokerDisconnectTimeDuration,omitempty"`
        LastUpgradeTime                  string                 `json:"lastUpgradeTime,omitempty"`
        Latitude                         string                 `json:"latitude,omitempty"`
        ListenIPs                        []string               `json:"listenIps,omitempty"`
        Location                         string                 `json:"location,omitempty"`
        Longitude                        string                 `json:"longitude,omitempty"`
        ModifiedBy                       string                 `json:"modifiedBy,omitempty"`
        ModifiedTime                     string                 `json:"modifiedTime,omitempty"`
        Name                             string                 `json:"name,omitempty"`
        ProvisioningKeyID                string                 `json:"provisioningKeyId,omitempty"`
        ProvisioningKeyName              string                 `json:"provisioningKeyName,omitempty"`
        Platform                         string                 `json:"platform,omitempty"`
        PreviousVersion                  string                 `json:"previousVersion,omitempty"`
        ServiceEdgeGroupID               string                 `json:"serviceEdgeGroupId,omitempty"`
        ServiceEdgeGroupName             string                 `json:"serviceEdgeGroupName,omitempty"`
        PrivateIP                        string                 `json:"privateIp,omitempty"`
        PublicIP                         string                 `json:"publicIp,omitempty"`
        PublishIPs                       []string               `json:"publishIps,omitempty"`
        SargeVersion                     string                 `json:"sargeVersion,omitempty"`
        EnrollmentCert                   map[string]interface{} `json:"enrollmentCert"`
        UpgradeAttempt                   string                 `json:"upgradeAttempt,omitempty"`
        UpgradeStatus                    string                 `json:"upgradeStatus,omitempty"`
        MicroTenantID                    string                 `json:"microtenantId,omitempty"`
        MicroTenantName                  string                 `json:"microtenantName,omitempty"`
}

type TrustedNetworks struct {
        CreationTime     string `json:"creationTime,omitempty"`
        Domain           string `json:"domain,omitempty"`
        ID               string `json:"id,omitempty"`
        MasterCustomerID string `json:"masterCustomerId"`
        ModifiedBy       string `json:"modifiedBy,omitempty"`
        ModifiedTime     string `json:"modifiedTime,omitempty"`
        Name             string `json:"name,omitempty"`
        NetworkID        string `json:"networkId,omitempty"`
        ZscalerCloud     string `json:"zscalerCloud,omitempty"`
}

func (service *Service) Get(serviceEdgeGroupID string) (*ServiceEdgeGroup, *http.Response, error) <span class="cov10" title="2">{
        v := new(ServiceEdgeGroup)
        path := fmt.Sprintf("%v/%v", mgmtConfig+service.Client.Config.CustomerID+serviceEdgeGroupEndpoint, serviceEdgeGroupID)
        resp, err := service.Client.NewRequestDo("GET", path, common.Filter{MicroTenantID: service.microTenantID}, nil, v)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return v, resp, nil</span>
}

func (service *Service) GetByName(serviceEdgeGroupName string) (*ServiceEdgeGroup, *http.Response, error) <span class="cov10" title="2">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + serviceEdgeGroupEndpoint
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[ServiceEdgeGroup](service.Client, relativeURL, common.Filter{Search: serviceEdgeGroupName, MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov10" title="2">for _, app := range list </span><span class="cov1" title="1">{
                if strings.EqualFold(app.Name, serviceEdgeGroupName) </span><span class="cov1" title="1">{
                        return &amp;app, resp, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, resp, fmt.Errorf("no service edge group named '%s' was found", serviceEdgeGroupName)</span>
}

func (service *Service) Create(serviceEdge ServiceEdgeGroup) (*ServiceEdgeGroup, *http.Response, error) <span class="cov1" title="1">{
        v := new(ServiceEdgeGroup)
        resp, err := service.Client.NewRequestDo("POST", mgmtConfig+service.Client.Config.CustomerID+serviceEdgeGroupEndpoint, common.Filter{MicroTenantID: service.microTenantID}, serviceEdge, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return v, resp, nil</span>
}

func (service *Service) Update(serviceEdgeGroupID string, serviceEdge *ServiceEdgeGroup) (*http.Response, error) <span class="cov10" title="2">{
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+serviceEdgeGroupEndpoint, serviceEdgeGroupID)
        resp, err := service.Client.NewRequestDo("PUT", relativeURL, common.Filter{MicroTenantID: service.microTenantID}, serviceEdge, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp, err</span>
}

func (service *Service) Delete(serviceEdgeGroupID string) (*http.Response, error) <span class="cov10" title="2">{
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfig+service.Client.Config.CustomerID+serviceEdgeGroupEndpoint, serviceEdgeGroupID)
        resp, err := service.Client.NewRequestDo("DELETE", relativeURL, common.Filter{MicroTenantID: service.microTenantID}, nil, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp, nil</span>
}

func (service *Service) GetAll() ([]ServiceEdgeGroup, *http.Response, error) <span class="cov1" title="1">{
        relativeURL := mgmtConfig + service.Client.Config.CustomerID + serviceEdgeGroupEndpoint
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[ServiceEdgeGroup](service.Client, relativeURL, common.Filter{MicroTenantID: service.microTenantID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">return list, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package trustednetwork

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zpa"
)

type Service struct {
        Client *zpa.Client
}

func New(c *zpa.Client) *Service <span class="cov10" title="5">{
        return &amp;Service{Client: c}
}</span>
</pre>
		
		<pre class="file" id="file94" style="display: none">package trustednetwork

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zpa/services/common"
)

const (
        mgmtConfigV1           = "/mgmtconfig/v1/admin/customers/"
        mgmtConfigV2           = "/mgmtconfig/v2/admin/customers/"
        trustedNetworkEndpoint = "/network"
)

type TrustedNetwork struct {
        CreationTime     string `json:"creationTime,omitempty"`
        Domain           string `json:"domain,omitempty"`
        ID               string `json:"id,omitempty"`
        MasterCustomerID string `json:"masterCustomerId,omitempty"`
        ModifiedBy       string `json:"modifiedBy,omitempty"`
        ModifiedTime     string `json:"modifiedTime,omitempty"`
        Name             string `json:"name,omitempty"`
        NetworkID        string `json:"networkId,omitempty"`
        ZscalerCloud     string `json:"zscalerCloud,omitempty"`
}

func (service *Service) Get(networkID string) (*TrustedNetwork, *http.Response, error) <span class="cov1" title="1">{
        v := new(TrustedNetwork)
        relativeURL := fmt.Sprintf("%s/%s", mgmtConfigV1+service.Client.Config.CustomerID+trustedNetworkEndpoint, networkID)
        resp, err := service.Client.NewRequestDo("GET", relativeURL, nil, nil, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return v, resp, nil</span>
}

func (service *Service) GetByNetID(netID string) (*TrustedNetwork, *http.Response, error) <span class="cov1" title="1">{
        relativeURL := fmt.Sprintf(mgmtConfigV2 + service.Client.Config.CustomerID + trustedNetworkEndpoint)
        list, resp, err := common.GetAllPagesGeneric[TrustedNetwork](service.Client, relativeURL, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">for _, trustedNetwork := range list </span><span class="cov1" title="1">{
                if trustedNetwork.NetworkID == netID </span><span class="cov1" title="1">{
                        return &amp;trustedNetwork, resp, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, resp, fmt.Errorf("no trusted network with NetworkID '%s' was found", netID)</span>
}

func (service *Service) GetByName(trustedNetworkName string) (*TrustedNetwork, *http.Response, error) <span class="cov6" title="10">{
        adaptedtrustedNetworkName := common.RemoveCloudSuffix(trustedNetworkName)
        relativeURL := mgmtConfigV2 + service.Client.Config.CustomerID + trustedNetworkEndpoint

        // Set up custom filters for pagination
        filters := common.Filter{Search: adaptedtrustedNetworkName} // Using the adapted trusted Network Name for searching

        // Use the custom pagination function with custom filters
        list, resp, err := common.GetAllPagesGenericWithCustomFilters[TrustedNetwork](service.Client, relativeURL, filters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // Iterate through the list and find the trusted network by its name
        <span class="cov6" title="10">for _, trustedNetwork := range list </span><span class="cov10" title="43">{
                if strings.EqualFold(common.RemoveCloudSuffix(trustedNetwork.Name), adaptedtrustedNetworkName) </span><span class="cov5" title="8">{
                        return &amp;trustedNetwork, resp, nil
                }</span>
        }
        <span class="cov2" title="2">return nil, resp, fmt.Errorf("no trusted network named '%s' was found", trustedNetworkName)</span>
}

func (service *Service) GetAll() ([]TrustedNetwork, *http.Response, error) <span class="cov3" title="3">{
        relativeURL := mgmtConfigV2 + service.Client.Config.CustomerID + trustedNetworkEndpoint
        list, resp, err := common.GetAllPagesGeneric[TrustedNetwork](service.Client, relativeURL, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov3" title="3">return list, resp, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
