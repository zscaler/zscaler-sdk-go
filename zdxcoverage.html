
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>administration: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services/administration/administration.go (83.3%)</option>
				
				<option value="file1">github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services/alerts/alerts.go (36.4%)</option>
				
				<option value="file2">github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services/common/common.go (0.0%)</option>
				
				<option value="file3">github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services/inventory/inventory.go (41.7%)</option>
				
				<option value="file4">github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services/reports/applications/application_score_metrics.go (0.0%)</option>
				
				<option value="file5">github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services/reports/applications/applications.go (41.7%)</option>
				
				<option value="file6">github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services/reports/devices/device_apps.go (0.0%)</option>
				
				<option value="file7">github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services/reports/devices/device_cloudpath_probes.go (0.0%)</option>
				
				<option value="file8">github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services/reports/devices/device_events.go (0.0%)</option>
				
				<option value="file9">github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services/reports/devices/device_health_metrics.go (0.0%)</option>
				
				<option value="file10">github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services/reports/devices/device_quality_metrics.go (0.0%)</option>
				
				<option value="file11">github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services/reports/devices/device_top_process.go (0.0%)</option>
				
				<option value="file12">github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services/reports/devices/device_web_probes.go (0.0%)</option>
				
				<option value="file13">github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services/reports/devices/devices.go (41.7%)</option>
				
				<option value="file14">github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services/reports/devices/geo_locations.go (83.3%)</option>
				
				<option value="file15">github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services/reports/users/users.go (41.7%)</option>
				
				<option value="file16">github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services/service.go (100.0%)</option>
				
				<option value="file17">github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services/troubleshooting/analysis/analysis.go (0.0%)</option>
				
				<option value="file18">github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services/troubleshooting/deeptrace/deeptrace.go (0.0%)</option>
				
				<option value="file19">github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/v2_client.go (60.2%)</option>
				
				<option value="file20">github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/v2_config.go (47.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package administration

import (
        "context"
        "net/http"

        "github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services"
)

const (
        departmentsEndpoint = "v1/administration/departments"
        locationsEndpoint   = "v1/administration/locations"
)

type Department struct {
        ID   int    `json:"id"`
        Name string `json:"name,omitempty"`
}

type Location struct {
        ID   int    `json:"id"`
        Name string `json:"name,omitempty"`
}

type GetDepartmentsFilters struct {
        From   int    `json:"from,omitempty" url:"from,omitempty"`
        To     int    `json:"to,omitempty" url:"to,omitempty"`
        Search string `json:"search,omitempty" url:"search,omitempty"`
}

type GetLocationsFilters struct {
        From   int    `json:"from,omitempty" url:"from,omitempty"`
        To     int    `json:"to,omitempty" url:"to,omitempty"`
        Search string `json:"search,omitempty" url:"search,omitempty"`
        Q      string `json:"q,omitempty" url:"q,omitempty"`
}

// Gets the list of configured departments.
func GetDepartments(ctx context.Context, service *services.Service, filters GetDepartmentsFilters) ([]Department, *http.Response, error) <span class="cov8" title="1">{
        var departments []Department
        path := departmentsEndpoint
        resp, err := service.Client.NewRequestDo(ctx, "GET", path, filters, nil, &amp;departments)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">return departments, resp, nil</span>
}

// Gets the list of configured locations.
func GetLocations(ctx context.Context, service *services.Service, filters GetLocationsFilters) ([]Location, *http.Response, error) <span class="cov8" title="1">{
        var locations []Location
        path := locationsEndpoint
        resp, err := service.Client.NewRequestDo(ctx, "GET", path, filters, nil, &amp;locations)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">return locations, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package alerts

import (
        "context"
        "fmt"
        "net/http"

        "github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services"
        "github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services/common"
)

const (
        baseEndpoint            = "v1/alerts"
        ongoingEndpoint         = baseEndpoint + "/ongoing"
        historicalEndpoint      = baseEndpoint + "/historical"
        alertEndpoint           = baseEndpoint + "/%s"
        affectedDevicesEndpoint = baseEndpoint + "/%s/affected_devices"
)

type AlertsResponse struct {
        Alerts     []Alert `json:"alerts"`
        NextOffset string  `json:"next_offset"`
}

type Alert struct {
        ID              int           `json:"id"`
        RuleName        string        `json:"rule_name,omitempty"`
        Severity        string        `json:"severity,omitempty"`
        AlertType       string        `json:"alert_type,omitempty"`
        AlertStatus     string        `json:"alert_status,omitempty"`
        NumGeolocations int           `json:"num_geolocations,omitempty"`
        NumDevices      int           `json:"num_devices,omitempty"`
        StartedOn       int           `json:"started_on,omitempty"`
        EndedOn         int           `json:"ended_on,omitempty"`
        Application     Application   `json:"application,omitempty"`
        Departments     []Department  `json:"departments,omitempty"`
        Locations       []Location    `json:"locations,omitempty"`
        Geolocations    []Geolocation `json:"geolocations,omitempty"`
}

type Application struct {
        ID   int    `json:"id"`
        Name string `json:"name"`
}

type Department struct {
        ID         int    `json:"id"`
        Name       string `json:"name"`
        NumDevices int    `json:"num_devices"`
}

type Geolocation struct {
        ID         string `json:"id"`
        Name       string `json:"name"`
        NumDevices int    `json:"num_devices"`
}

type Location struct {
        ID         int     `json:"id"`
        Name       string  `json:"name"`
        NumDevices int     `json:"num_devices"`
        Groups     []Group `json:"groups"`
}

type Group struct {
        ID   int    `json:"id"`
        Name string `json:"name"`
}

type Device struct {
        ID        int    `json:"id"`
        Name      string `json:"name"`
        UserID    int    `json:"userid"`
        UserName  string `json:"userName"`
        UserEmail string `json:"userEmail"`
}

type AffectedDevicesResponse struct {
        Devices    []Device `json:"devices"`
        NextOffset string   `json:"next_offset"`
}

// GetOngoingAlerts retrieves ongoing alerts with optional filters
func GetOngoingAlerts(ctx context.Context, service *services.Service, filters common.GetFromToFilters) (*AlertsResponse, *http.Response, error) <span class="cov8" title="1">{
        var response AlertsResponse
        resp, err := service.Client.NewRequestDo(ctx, "GET", ongoingEndpoint, filters, nil, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">return &amp;response, resp, nil</span>
}

// GetHistoricalAlerts retrieves historical alerts
// Gets the list of alert history rules defined across an organization.
// All alert history rules are returned if the search filter is not specified.
// The default is set to the previous 2 hours. Alert history rules have an Ended On date.
// The Ended On date is used to pull alerts in conjunction with the provided filters.
// Cannot exceed the 14-day time range limit for alert rules.
func GetHistoricalAlerts(ctx context.Context, service *services.Service, filters common.GetFromToFilters) (*AlertsResponse, *http.Response, error) <span class="cov8" title="1">{
        var response AlertsResponse
        resp, err := service.Client.NewRequestDo(ctx, "GET", historicalEndpoint, filters, nil, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">return &amp;response, resp, nil</span>
}

// GetAlert retrieves a specific alert by ID
func GetAlert(ctx context.Context, service *services.Service, alertID string) (*Alert, *http.Response, error) <span class="cov0" title="0">{
        var response Alert
        path := fmt.Sprintf(alertEndpoint, alertID)
        resp, err := service.Client.NewRequestDo(ctx, "GET", path, nil, nil, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return &amp;response, resp, nil</span>
}

// GetAffectedDevices retrieves the affected devices for a specific alert by ID
func GetAffectedDevices(ctx context.Context, service *services.Service, alertID string, filters common.GetFromToFilters) (*AffectedDevicesResponse, *http.Response, error) <span class="cov0" title="0">{
        var response AffectedDevicesResponse
        path := fmt.Sprintf(affectedDevicesEndpoint, alertID)
        resp, err := service.Client.NewRequestDo(ctx, "GET", path, filters, nil, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return &amp;response, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package common

import "fmt"

type Metric struct {
        Metric     string      `json:"metric,omitempty"`
        Unit       string      `json:"unit,omitempty"`
        DataPoints []DataPoint `json:"datapoints"`
}

type DataPoint struct {
        TimeStamp int     `json:"timestamp,omitempty"`
        Value     float64 `json:"value,omitempty"`
}

type GetFromToFilters struct {
        // The start time (in seconds) for the query. The value is entered in Unix Epoch. If not entered, returns the data for the last 2 hours.
        From int `json:"from,omitempty" url:"from,omitempty"`
        // The end time (in seconds) for the query. The value is entered in Unix Epoch. If not entered, returns the data for the last 2 hours.
        To             int      `json:"to,omitempty" url:"to,omitempty"`
        Loc            []int    `json:"loc,omitempty" url:"loc,omitempty"`
        Dept           []int    `json:"dept,omitempty" url:"dept,omitempty"`
        Geo            []string `json:"geo,omitempty" url:"geo,omitempty"`
        LocationGroups []string `json:"location_groups,omitempty" url:"location_groups,omitempty"`
        MetricName     string   `json:"metric_name,omitempty" url:"metric_name,omitempty"`
        Offset         string   `json:"offset,omitempty" url:"offset,omitempty"`
        // The number of items that must be returned per request from the list.
        Limit int `json:"limit,omitempty" url:"limit,omitempty"`
        // Search for a user name or email. The search results include active users for the first 1000 matches.
        Q string `json:"q,omitempty" url:"q,omitempty"`
}

// Centralized safe conversion function
func SafeCastToInt(value int64) (int, error) <span class="cov0" title="0">{
        minInt := int64(-1 &lt;&lt; 31)      // Minimum value of int32
        maxInt := int64((1 &lt;&lt; 31) - 1) // Maximum value of int32

        if value &lt; minInt || value &gt; maxInt </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("value %d is out of range for int type", value)
        }</span>
        <span class="cov0" title="0">return int(value), nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package inventory

import (
        "context"
        "fmt"
        "net/http"

        "github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services"
)

const (
        softwareEndpoint    = "v1/inventory/software"
        softwareKeyEndpoint = "v1/inventory/software"
)

type SoftwareOverviewResponse struct {
        Software   []SoftwareOverview `json:"software"`
        NextOffset string             `json:"next_offset,omitempty"`
}

type SoftwareKeyResponse struct {
        Software   []SoftwareUserList `json:"software"`
        NextOffset string             `json:"next_offset,omitempty"`
}

type SoftwareOverview struct {
        SoftwareKey         string `json:"software_key,omitempty"`
        SoftwareName        string `json:"software_name,omitempty"`
        Vendor              string `json:"vendor,omitempty"`
        SoftwareGroup       string `json:"software_group,omitempty"`
        SoftwareInstallType string `json:"sw_install_type,omitempty"`
        UserTotal           int    `json:"user_total,omitempty"`
        DeviceTotal         int    `json:"device_total,omitempty"`
}

type SoftwareUserList struct {
        SoftwareKey     string `json:"software_key,omitempty"`
        SoftwareName    string `json:"software_name,omitempty"`
        SoftwareVersion string `json:"software_version,omitempty"`
        SoftwareGroup   string `json:"software_group,omitempty"`
        OS              string `json:"os,omitempty"`
        Vendor          string `json:"vendor,omitempty"`
        UserID          int    `json:"user_id,omitempty"`
        DeviceID        int    `json:"device_id,omitempty"`
        Hostname        string `json:"hostname,omitempty"`
        Username        string `json:"username,omitempty"`
        InstallDate     string `json:"install_date,omitempty"`
}

func GetSoftware(ctx context.Context, service *services.Service, filters GetSoftwareFilters) ([]SoftwareOverview, string, *http.Response, error) <span class="cov10" title="2">{
        var response SoftwareOverviewResponse
        path := softwareEndpoint
        resp, err := service.Client.NewRequestDo(ctx, "GET", path, filters, nil, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", nil, err
        }</span>
        <span class="cov10" title="2">return response.Software, response.NextOffset, resp, nil</span>
}

func GetSoftwareKey(ctx context.Context, service *services.Service, softwareKey string, filters GetSoftwareFilters) ([]SoftwareUserList, string, *http.Response, error) <span class="cov0" title="0">{
        var response SoftwareKeyResponse
        path := fmt.Sprintf("%v/%v", softwareKeyEndpoint, softwareKey)
        resp, err := service.Client.NewRequestDo(ctx, "GET", path, filters, nil, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", nil, err
        }</span>
        <span class="cov0" title="0">return response.Software, response.NextOffset, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package applications

import (
        "context"
        "fmt"
        "net/http"

        "github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services"
        "github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services/common"
)

const (
        scoreEndpoint   = "/score"
        metricsEndpoint = "/metrics"
)

// Gets the application's ZDX score trend. If the time range is not specified, the endpoint defaults to the last 2 hours.
func GetAppScores(ctx context.Context, service *services.Service, appID int, filters common.GetFromToFilters) ([]common.Metric, *http.Response, error) <span class="cov0" title="0">{
        var v []common.Metric
        var single common.Metric
        path := fmt.Sprintf("%s/%d%s", appsEndpoint, appID, scoreEndpoint)
        resp, err := service.Client.NewRequestDo(ctx, "GET", path, filters, nil, &amp;v)
        if err == nil </span><span class="cov0" title="0">{
                return v, resp, nil
        }</span>

        // If unmarshalling to an array fails, try unmarshalling to a single object
        <span class="cov0" title="0">resp, err = service.Client.NewRequestDo(ctx, "GET", path, filters, nil, &amp;single)
        if err == nil </span><span class="cov0" title="0">{
                v = append(v, single)
                return v, resp, nil
        }</span>

        <span class="cov0" title="0">return nil, nil, err</span>
}

/*
Gets the application's metric trend. For Web Probes, you can access Page Fetch Time, Server Response Time, DNS Time or Availability.
If not specified, it defaults to Page Fetch Time (PFT).
For CloudPath Probes, you can access latency metrics for End to End, Client - Egress, Egress - Application, ZIA Service Edge - Egress, and ZIA Service Edge - Application.
If not specified, it defaults to End to End latency.
If the time range is not specified, the endpoint defaults to the last 2 hours.
*/
// Gets the application's metric trend.
func GetAppMetrics(ctx context.Context, service *services.Service, appID int, filters common.GetFromToFilters) ([]common.Metric, *http.Response, error) <span class="cov0" title="0">{
        var v []common.Metric
        var single common.Metric
        path := fmt.Sprintf("%s/%d%s", appsEndpoint, appID, metricsEndpoint)
        resp, err := service.Client.NewRequestDo(ctx, "GET", path, filters, nil, &amp;v)
        if err == nil </span><span class="cov0" title="0">{
                return v, resp, nil
        }</span>

        // If unmarshalling to an array fails, try unmarshalling to a single object
        <span class="cov0" title="0">resp, err = service.Client.NewRequestDo(ctx, "GET", path, filters, nil, &amp;single)
        if err == nil </span><span class="cov0" title="0">{
                v = append(v, single)
                return v, resp, nil
        }</span>

        <span class="cov0" title="0">return nil, nil, err</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package applications

import (
        "context"
        "net/http"

        "github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services"
        "github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services/common"
)

const (
        appsEndpoint = "v1/apps"
)

type Apps struct {
        ID                 int                 `json:"id"`
        Name               string              `json:"name,omitempty"`
        Score              float32             `json:"score"`
        MostImpactedRegion *MostImpactedRegion `json:"most_impacted_region,omitempty"`
        Stats              *Stats              `json:"stats,omitempty"`
        TotalUsers         int                 `json:"total_users,omitempty"`
}

type MostImpactedRegion struct {
        ID      string `json:"id"`
        City    string `json:"city,omitempty"`
        Region  string `json:"region,omitempty"`
        Country string `json:"country,omitempty"`
        GeoType string `json:"geo_type,omitempty"`
}

type Stats struct {
        ActiveUsers   int `json:"active_users"`
        ActiveDevices int `json:"active_devices"`
        NumPoor       int `json:"num_poor"`
        NumOkay       int `json:"num_okay"`
        NumGood       int `json:"num_good"`
}

// Lists all active applications configured for a tenant.
// The endpoint gets each application's ZDX score (default for the last 2 hours), most impacted location, and the total number of users impacted.
// To learn more, see About the ZDX Dashboard at https://help.zscaler.com/zdx/about-zdx-dashboard.
func GetAllApps(ctx context.Context, service *services.Service, filters common.GetFromToFilters) ([]Apps, *http.Response, error) <span class="cov10" title="4">{
        var apps []Apps
        path := appsEndpoint
        resp, err := service.Client.NewRequestDo(ctx, "GET", path, filters, nil, &amp;apps)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov10" title="4">return apps, resp, nil</span>
}

func GetApp(ctx context.Context, service *services.Service, appID string, filters common.GetFromToFilters) (*Apps, *http.Response, error) <span class="cov0" title="0">{
        var app Apps
        path := appsEndpoint + "/" + appID
        resp, err := service.Client.NewRequestDo(ctx, "GET", path, filters, nil, &amp;app)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return &amp;app, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package devices

import (
        "context"
        "fmt"
        "net/http"

        "github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services"
        "github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services/common"
)

const (
        deviceAppsEndpoint = "apps"
)

type App struct {
        ID    int     `json:"id,omitempty"`
        Name  string  `json:"name,omitempty"`
        Score float32 `json:"score,omitempty"`
}

// Gets the application's ZDX score trend for a device. If the time range is not specified, the endpoint defaults to the last 2 hours.
func GetDeviceApp(ctx context.Context, service *services.Service, deviceID, appID string, filters common.GetFromToFilters) (*App, *http.Response, error) <span class="cov0" title="0">{
        v := new(App)
        path := fmt.Sprintf("%v/%v/%v/%v", devicesEndpoint, deviceID, deviceAppsEndpoint, appID)
        resp, err := service.Client.NewRequestDo(ctx, "GET", path, filters, nil, v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return v, resp, nil</span>
}

// Gets the list all active applications for a device. The endpoint gets the ZDX score each application. If the time range is not specified, the endpoint defaults to the last 2 hours.
func GetDeviceAllApps(ctx context.Context, service *services.Service, deviceID string, filters common.GetFromToFilters) ([]App, *http.Response, error) <span class="cov0" title="0">{
        var v []App
        relativeURL := devicesEndpoint + "/" + deviceID + "/" + deviceAppsEndpoint
        resp, err := service.Client.NewRequestDo(ctx, "GET", relativeURL, filters, nil, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return v, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package devices

import (
        "context"
        "fmt"
        "net/http"

        "github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services"
        "github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services/common"
)

const (
        deviceCloudPathProbesEndpoint = "cloudpath-probes"
)

// devices/{deviceid}/apps/{appid}/cloudpath-probes
type DeviceCloudPathProbe struct {
        ID             int              `json:"id,omitempty"`
        Name           string           `json:"name,omitempty"`
        NumProbes      int              `json:"num_probes,omitempty"`
        AverageLatency []AverageLatency `json:"avg_latencies,omitempty"`
}

type AverageLatency struct {
        LegSRC  string  `json:"leg_src,omitempty"`
        LegDst  string  `json:"leg_dst,omitempty"`
        Latency float32 `json:"latency,omitempty"`
}

// /devices/{deviceid}/apps/{appid}/cloudpath-probes/{probeid}
type NetworkStats struct {
        LegSRC string          `json:"leg_src,omitempty"`
        LegDst string          `json:"leg_dst,omitempty"`
        Stats  []common.Metric `json:"stats,omitempty"`
}

// /devices/{deviceid}/apps/{appid}/cloudpath-probes/{probeid}/cloudpath
type CloudPathProbe struct {
        TimeStamp int         `json:"timestamp,omitempty"`
        CloudPath []CloudPath `json:"cloudpath,omitempty"` // Changed to a slice
}

type CloudPath struct {
        SRC           string  `json:"src,omitempty"`
        DST           string  `json:"dst,omitempty"`
        NumHops       int     `json:"num_hops,omitempty"`
        Latency       float32 `json:"latency,omitempty"`
        Loss          float32 `json:"loss,omitempty"`
        NumUnrespHops int     `json:"num_unresp_hops,omitempty"`
        TunnelType    int     `json:"tunnel_type,omitempty"`
        Hops          []Hops  `json:"hops,omitempty"` // Changed to a slice
}

type Hops struct {
        IP          string `json:"ip,omitempty"`
        GWMac       string `json:"gw_mac,omitempty"`
        GWMacVendor string `json:"gw_mac_vendor,omitempty"`
        PktSent     int    `json:"pkt_sent,omitempty"`
        PktRcvd     int    `json:"pkt_rcvd,omitempty"`
        LatencyMin  int    `json:"latency_min,omitempty"`
        LatencyMax  int    `json:"latency_max,omitempty"`
        LatencyAvg  int    `json:"latency_avg,omitempty"`
        LatencyDiff int    `json:"latency_diff,omitempty"`
}

// devices/{deviceid}/apps/{appid}/cloudpath-probes
// Gets the list of all active Cloud Path probes on a device.
// If the time range is not specified, the default is the previous 2 hours
func GetAllCloudPathProbes(ctx context.Context, service *services.Service, deviceID, appID int, filters common.GetFromToFilters) ([]DeviceCloudPathProbe, *http.Response, error) <span class="cov0" title="0">{
        var v []DeviceCloudPathProbe
        path := fmt.Sprintf("%v/%v/%v/%v/%v", devicesEndpoint, deviceID, deviceAppsEndpoint, appID, deviceCloudPathProbesEndpoint)
        resp, err := service.Client.NewRequestDo(ctx, "GET", path, filters, nil, &amp;v) // Pass the address of v
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return v, resp, nil</span>
}

// /devices/{deviceid}/apps/{appid}/cloudpath-probes/{probeid}/cloudpath
// Gets the Web probe's Page Fetch Time (PFT) on a device for an application. If the time range is not specified, the endpoint defaults to the previous 2 hours.
func GetDeviceAppCloudPathProbe(ctx context.Context, service *services.Service, deviceID, appID, probeID int, filters common.GetFromToFilters) ([]NetworkStats, *http.Response, error) <span class="cov0" title="0">{
        var v []NetworkStats
        path := fmt.Sprintf("%v/%v/%v/%v/%v/%v", devicesEndpoint, deviceID, deviceAppsEndpoint, appID, deviceCloudPathProbesEndpoint, probeID)
        resp, err := service.Client.NewRequestDo(ctx, "GET", path, filters, nil, &amp;v) // Pass the address of v
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return v, resp, nil</span>
}

// /devices/{deviceid}/apps/{appid}/cloudpath-probes/{probeid}/cloudpath
// Gets the Cloud Path hop data for an application on a specific device.
// Includes the summary data for the entire path like the total number of hops, packet loss, latency, and tunnel type (if available).
// It also includes a similar summary of data for each individual hop. If the time range is not specified, the endpoint defaults to the previous 2 hours.
func GetCloudPathAppDevice(ctx context.Context, service *services.Service, deviceID, appID, probeID int, filters common.GetFromToFilters) ([]CloudPathProbe, *http.Response, error) <span class="cov0" title="0">{
        var v []CloudPathProbe
        path := fmt.Sprintf("%v/%v/%v/%v/%v/%v/%s", devicesEndpoint, deviceID, deviceAppsEndpoint, appID, deviceCloudPathProbesEndpoint, probeID, "/cloudpath")
        resp, err := service.Client.NewRequestDo(ctx, "GET", path, filters, nil, &amp;v) // Pass the address of v
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return v, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package devices

import (
        "context"
        "fmt"
        "net/http"

        "github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services"
        "github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services/common"
)

const (
        deviceEventsEndpoint = "events"
)

type DeviceEvents struct {
        TimeStamp int      `json:"timestamp,omitempty"`
        Events    []Events `json:"instances,omitempty"`
}

type Events struct {
        Category    string `json:"category,omitempty"`
        Name        string `json:"name,omitempty"`
        DisplayName string `json:"display_name,omitempty"`
        Prev        string `json:"prev,omitempty"`
        Curr        string `json:"curr,omitempty"`
}

// Gets the Events metrics trend for a device. If the time range is not specified, the endpoint defaults to the last 2 hours.
// The event metrics include Zscaler, Hardware, Software, and Network event changes.
func GetEvents(ctx context.Context, service *services.Service, deviceID int, filters common.GetFromToFilters) ([]DeviceEvents, *http.Response, error) <span class="cov0" title="0">{
        var v []DeviceEvents
        path := fmt.Sprintf("%v/%v/%v", devicesEndpoint, deviceID, deviceEventsEndpoint)
        resp, err := service.Client.NewRequestDo(ctx, "GET", path, filters, nil, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return v, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package devices

import (
        "context"
        "fmt"
        "net/http"

        "github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services"
        "github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services/common"
)

const (
        deviceHealthMetricsEndpoint = "health-metrics"
)

type HealthMetrics struct {
        Category  string      `json:"category,omitempty"`
        Instances []Instances `json:"instances,omitempty"`
}

type Instances struct {
        Name    string          `json:"metric,omitempty"`
        Metrics []common.Metric `json:"metrics,omitempty"`
}

// /devices/42827781/apps/1/health-metrics?from=1718247199&amp;to=1718254399
// Gets the health metrics trend for a device. If the time range is not specified, the endpoint defaults to the last 2 hours.
// The health metrics include CPU, Memory, Disk I/O, Network I/O, Wi-Fi, Network Bandwidth, etc.
func GetHealthMetrics(ctx context.Context, service *services.Service, deviceID int, filters common.GetFromToFilters) ([]HealthMetrics, *http.Response, error) <span class="cov0" title="0">{
        var v []HealthMetrics
        path := fmt.Sprintf("%v/%v/%v", devicesEndpoint, deviceID, deviceHealthMetricsEndpoint)
        resp, err := service.Client.NewRequestDo(ctx, "GET", path, filters, nil, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return v, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package devices

import (
        "context"
        "fmt"
        "net/http"

        "github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services"
        "github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services/common"
)

const (
        deviceQualityMetricsEndpoint = "call-quality-metrics"
)

type CallQualityMetrics struct {
        MeetID        string          `json:"meet_id,omitempty"`
        MeetSessionID string          `json:"meet_session_id,omitempty"`
        MeetSubject   string          `json:"meet_subject,omitempty"`
        Metrics       []common.Metric `json:"metrics,omitempty"`
}

// Gets the Call Quality metric trend for a device for a CQM application.
// If the time range is not specified, the endpoint defaults to the last 2 hours.
func GetQualityMetrics(ctx context.Context, service *services.Service, deviceID, appID int, filters common.GetFromToFilters) ([]CallQualityMetrics, *http.Response, error) <span class="cov0" title="0">{
        var v []CallQualityMetrics
        path := fmt.Sprintf("%v/%v/%v/%v/%v", devicesEndpoint, deviceID, deviceAppsEndpoint, appID, deviceQualityMetricsEndpoint)
        resp, err := service.Client.NewRequestDo(ctx, "GET", path, filters, nil, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return v, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package devices

import (
        "context"
        "fmt"
        "net/http"

        "github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services"
        "github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services/common"
)

const (
        deviceTopProcessEndpoint = "top-processes"
)

type DeviceTopProcesses struct {
        TimeStamp    int            `json:"timestamp,omitempty"`
        TopProcesses []TopProcesses `json:"top_processes,omitempty"`
}

type TopProcesses struct {
        Category  string      `json:"category,omitempty"`
        Processes []Processes `json:"processes,omitempty"`
}

type Processes struct {
        ID   int    `json:"id,omitempty"`
        Name string `json:"name,omitempty"`
}

// GetDeviceTopProcesses gets the top processes for a device's deep trace session
func GetDeviceTopProcesses(ctx context.Context, service *services.Service, deviceID int, traceID string, filters common.GetFromToFilters) ([]DeviceTopProcesses, *http.Response, error) <span class="cov0" title="0">{
        var v []DeviceTopProcesses
        path := fmt.Sprintf("%v/%v/deeptraces/%v/%v", devicesEndpoint, deviceID, traceID, deviceTopProcessEndpoint)
        resp, err := service.Client.NewRequestDo(ctx, "GET", path, filters, nil, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return v, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package devices

import (
        "context"
        "fmt"
        "net/http"

        "github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services"
        "github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services/common"
)

const (
        deviceWebProbesEndpoint = "web-probes"
)

type DeviceWebProbe struct {
        ID        int     `json:"id,omitempty"`
        Name      string  `json:"name,omitempty"`
        NumProbes int     `json:"num_probes,omitempty"`
        AvgScore  float32 `json:"avg_score,omitempty"`
        AvgPFT    float32 `json:"avg_pft,omitempty"`
}

func generateWebProbesPath(deviceID, appID int) string <span class="cov0" title="0">{
        return fmt.Sprintf("%v/%v/%v/%v/%v", devicesEndpoint, deviceID, deviceAppsEndpoint, appID, deviceWebProbesEndpoint)
}</span>

func generateWebProbePath(deviceID, appID, probeID int) string <span class="cov0" title="0">{
        return fmt.Sprintf("%v/%v/%v/%v/%v/%v", devicesEndpoint, deviceID, deviceAppsEndpoint, appID, deviceWebProbesEndpoint, probeID)
}</span>

// Gets the Web Probe metrics trend on a device for an application.
// For Web Probes, you can access Page Fetch Time, Server Response Time, DNS Time, or Availability.
// If not specified, it defaults to Page Fetch Time (PFT).
// If the time range is not specified, the endpoint defaults to the last 2 hours.
func GetWebProbes(ctx context.Context, service *services.Service, deviceID, appID, probeID int, filters common.GetFromToFilters) ([]common.Metric, *http.Response, error) <span class="cov0" title="0">{
        var v []common.Metric
        var single common.Metric
        path := generateWebProbePath(deviceID, appID, probeID)
        resp, err := service.Client.NewRequestDo(ctx, "GET", path, filters, nil, &amp;v)
        if err == nil </span><span class="cov0" title="0">{
                return v, resp, nil
        }</span>

        // If unmarshalling to an array fails, try unmarshalling to a single object
        <span class="cov0" title="0">resp, err = service.Client.NewRequestDo(ctx, "GET", path, filters, nil, &amp;single)
        if err == nil </span><span class="cov0" title="0">{
                v = append(v, single)
                return v, resp, nil
        }</span>

        <span class="cov0" title="0">return nil, nil, err</span>
}

// Gets the list of all active web probes on a device. If the time range is not specified, the endpoint defaults to the last 2 hours.
func GetAllWebProbes(ctx context.Context, service *services.Service, deviceID, appID int, filters common.GetFromToFilters) ([]DeviceWebProbe, *http.Response, error) <span class="cov0" title="0">{
        var v []DeviceWebProbe
        path := generateWebProbesPath(deviceID, appID)
        resp, err := service.Client.NewRequestDo(ctx, "GET", path, filters, nil, &amp;v) // Pass the address of v
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return v, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package devices

import (
        "context"
        "fmt"
        "net/http"

        "github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services"
)

const (
        devicesEndpoint = "v1/devices"
)

type DeviceDetail struct {
        ID       int       `json:"id"`
        Name     string    `json:"name,omitempty"`
        Hardware *Hardware `json:"hardware,omitempty"`
        Network  []Network `json:"network,omitempty"`
        Software *Software `json:"software,omitempty"`
}

type Hardware struct {
        HWModel     string  `json:"hw_model,omitempty"`
        HWMFG       string  `json:"hw_mfg,omitempty"`
        HWType      string  `json:"hw_type,omitempty"`
        HWSerial    string  `json:"hw_serial,omitempty"`
        TotMem      int     `json:"tot_mem,omitempty"`
        GPU         string  `json:"gpu,omitempty"`
        DiskSize    int     `json:"disk_size,omitempty"`
        DiskModel   string  `json:"disk_model,omitempty"`
        DiskType    string  `json:"disk_type,omitempty"`
        CPUMFG      string  `json:"cpu_mfg,omitempty"`
        CPUModel    string  `json:"cpu_model,omitempty"`
        SpeedGHZ    float32 `json:"speed_ghz,omitempty"`
        LogicalProc int     `json:"logical_proc,omitempty"`
        NumCores    int     `json:"num_cores,omitempty"`
}

type Network struct {
        NetType     string `json:"net_type,omitempty"`
        Status      string `json:"status,omitempty"`
        IPv4        string `json:"ipv4,omitempty"`
        IPv6        string `json:"ipv6,omitempty"`
        DNSSRVS     string `json:"dns_srvs,omitempty"`
        DNSSuffix   string `json:"dns_suffix,omitempty"`
        Gateway     string `json:"gateway,omitempty"`
        MAC         string `json:"mac,omitempty"`
        GUID        string `json:"guid,omitempty"`
        WiFiAdapter string `json:"wifi_adapter,omitempty"`
        WiFiType    string `json:"wifi_type,omitempty"`
        SSID        string `json:"ssid,omitempty"`
        Channel     string `json:"channel,omitempty"`
        BSSID       string `json:"bssid,omitempty"`
}

type Software struct {
        OSName        string `json:"os_name,omitempty"`
        OSVer         string `json:"os_ver,omitempty"`
        Hostname      string `json:"hostname,omitempty"`
        NetBios       string `json:"netbios,omitempty"`
        User          string `json:"user,omitempty"`
        ClientConnVer string `json:"client_conn_ver,omitempty"`
        ZDXVer        string `json:"zdx_ver,omitempty"`
}

// Gets the device details including the device model information, tunnel type, network, and software details. The JSON must contain the user ID and email address to associate the device to a user. If the time range is not specified, the endpoint defaults to the last 2 hours.
func GetDevice(ctx context.Context, service *services.Service, deviceID string) (*DeviceDetail, *http.Response, error) <span class="cov0" title="0">{
        v := new(DeviceDetail)
        path := fmt.Sprintf("%v/%v", devicesEndpoint, deviceID)
        resp, err := service.Client.NewRequestDo(ctx, "GET", path, nil, nil, v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return v, resp, nil</span>
}

// Gets the list of all active devices and its basic details. The JSON must contain the user's ID and email address to associate the device to the user. If the time range is not specified, the endpoint defaults to the last 2 hours.
func GetAllDevices(ctx context.Context, service *services.Service, filters GetDevicesFilters) ([]DeviceDetail, *http.Response, error) <span class="cov10" title="12">{
        var v struct {
                NextOffSet interface{}    `json:"next_offset"`
                List       []DeviceDetail `json:"devices"`
        }

        relativeURL := devicesEndpoint
        resp, err := service.Client.NewRequestDo(ctx, "GET", relativeURL, filters, nil, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov10" title="12">return v.List, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package devices

import (
        "context"
        "net/http"

        "github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services"
)

const (
        geoLocationsEndpoint = "v1/active_geo"
)

type GeoLocation struct {
        ID          string     `json:"id"`
        Name        string     `json:"name,omitempty"`
        GeoType     string     `json:"geo_type,omitempty"`
        Description string     `json:"description,omitempty"`
        Children    []Children `json:"children,omitempty"`
}

type Children struct {
        ID          string `json:"id"`
        Description string `json:"description,omitempty"`
        GeoType     string `json:"geo_type,omitempty"`
}

// Gets the list of all active geolocations for the time range specified.
// If not specified, the endpoint defaults to the last 2 hours. The state and city data is retrieved only for the US.
func GetGeoLocations(ctx context.Context, service *services.Service, filters GeoLocationFilter) ([]GeoLocation, *http.Response, error) <span class="cov8" title="1">{
        var v []GeoLocation
        path := geoLocationsEndpoint
        resp, err := service.Client.NewRequestDo(ctx, "GET", path, filters, nil, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">return v, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package users

import (
        "context"
        "fmt"
        "net/http"

        "github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services"
)

const (
        usersEndpoint = "v1/users"
)

type User struct {
        ID      int       `json:"id"`
        Name    string    `json:"name,omitempty"`
        Email   string    `json:"email,omitempty"`
        Devices []Devices `json:"devices,omitempty"`
}

type Devices struct {
        ID           int            `json:"id"`
        Name         string         `json:"name,omitempty"`
        UserLocation []UserLocation `json:"geo_loc,omitempty"`
        ZSLocation   []ZSLocation   `json:"zs_loc,omitempty"`
}

type UserLocation struct {
        ID           string  `json:"id"`
        City         string  `json:"city,omitempty"`
        State        string  `json:"state,omitempty"`
        Country      string  `json:"country,omitempty"`
        GeoLat       float32 `json:"geo_lat,omitempty"`
        GeoLong      float32 `json:"geo_long,omitempty"`
        GeoDetection string  `json:"geo_detection,omitempty"`
}

type ZSLocation struct {
        ID   int    `json:"id"`
        Name string `json:"name,omitempty"`
}

// Gets user details including the device information, active geolocations, and Zscaler locations. If the time range is not specified, the endpoint defaults to the last 2 hours.
func GetUser(ctx context.Context, service *services.Service, userID string) (*User, *http.Response, error) <span class="cov0" title="0">{
        v := new(User)
        path := fmt.Sprintf("%v/%v", usersEndpoint, userID)
        resp, err := service.Client.NewRequestDo(ctx, "GET", path, nil, nil, v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return v, resp, nil</span>
}

// Gets the list of all active users, their devices, active geolocations, and Zscaler locations. If the time range is not specified, the endpoint defaults to the last 2 hours.
func GetAllUsers(ctx context.Context, service *services.Service, filters GetUsersFilters) ([]User, *http.Response, error) <span class="cov10" title="2">{
        var v struct {
                NextOffSet interface{} `json:"next_offset"`
                List       []User      `json:"users"`
        }

        relativeURL := usersEndpoint
        resp, err := service.Client.NewRequestDo(ctx, "GET", relativeURL, filters, nil, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov10" title="2">return v.List, resp, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package services

import (
        "github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx"
)

type Service struct {
        Client *zdx.Client
}

func New(c *zdx.Client) *Service <span class="cov10" title="26">{
        return &amp;Service{Client: c}
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package analysis

import (
        "context"
        "fmt"
        "net/http"

        "github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services"
)

const (
        analysisEndpoint = "v1/analysis"
)

type AnalysisRequest struct {
        DeviceID int `json:"device_id"`
        AppID    int `json:"app_id"`
        T0       int `json:"t0"`
        T1       int `json:"t1"`
}

type AnalysisResult struct {
        ErrMsg string `json:"err_msg"`
        Result Result `json:"result"`
}

type Result struct {
        Issue      string `json:"issue"`
        Confidence int    `json:"confidence"`
        Message    string `json:"message"`
        Times      []int  `json:"times"`
}

func GetAnalysis(ctx context.Context, service *services.Service, analysisID string) (*AnalysisResult, *http.Response, error) <span class="cov0" title="0">{
        var response AnalysisResult
        path := fmt.Sprintf("%s/%s", analysisEndpoint, analysisID)
        resp, err := service.Client.NewRequestDo(ctx, "GET", path, nil, nil, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return &amp;response, resp, nil</span>
}

func CreateAnalysis(ctx context.Context, service *services.Service, request AnalysisRequest) (*http.Response, error) <span class="cov0" title="0">{
        path := analysisEndpoint
        resp, err := service.Client.NewRequestDo(ctx, "POST", path, nil, request, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resp, nil</span>
}

func DeleteAnalysis(ctx context.Context, service *services.Service, analysisID string) (*http.Response, error) <span class="cov0" title="0">{
        path := fmt.Sprintf("%s/%s", analysisEndpoint, analysisID)
        resp, err := service.Client.NewRequestDo(ctx, "DELETE", path, nil, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package deeptrace

import (
        "context"
        "fmt"
        "net/http"

        "github.com/zscaler/zscaler-sdk-go/v3/zscaler/zdx/services"
)

const (
        deepTracesEndpoint = "v1/devices"
)

type DeepTraceSession struct {
        TraceID             string       `json:"trace_id"`
        TraceDetails        TraceDetails `json:"trace_details,omitempty"`
        Status              string       `json:"status,omitempty"`
        CreatedAt           int          `json:"created_at,omitempty"`
        StartedAt           int          `json:"started_at,omitempty"`
        EndedAt             int          `json:"ended_at,omitempty"`
        ExpectedTimeMinutes int          `json:"expected_time_minutes,omitempty"`
}

type TraceDetails struct {
        SessionName        string `json:"session_name"`
        AppID              string `json:"app_id"`
        AppName            string `json:"app_name"`
        UserID             string `json:"user_id,omitempty"`
        Username           string `json:"username,omitempty"`
        DeviceID           string `json:"device_id,omitempty"`
        DeviceName         string `json:"device_name,omitempty"`
        WebProbeID         string `json:"web_probe_id,omitempty"`
        WebProbeName       string `json:"web_probe_name,omitempty"`
        CloudPathProbeID   string `json:"cloudpath_probe_id,omitempty"`
        CloudPathProbeName string `json:"cloud_path_name,omitempty"`
        SessionLength      int    `json:"session_length,omitempty"`
        ProbeDevice        bool   `json:"probe_device,omitempty"`
}

type DeepTraceSessionPayload struct {
        SessionName          string `json:"session_name"`
        AppID                int    `json:"app_id"`
        WebProbeID           int    `json:"web_probe_id"`
        CloudPathProbeID     int    `json:"cloud_path_probe_id"`
        SessionLengthMinutes int    `json:"session_length_minutes"`
        ProbeDevice          bool   `json:"probe_device"`
}

func GetDeepTraces(ctx context.Context, service *services.Service, deviceID int) ([]DeepTraceSession, *http.Response, error) <span class="cov0" title="0">{
        var response []DeepTraceSession
        path := fmt.Sprintf("%s/%d/deeptraces", deepTracesEndpoint, deviceID)
        resp, err := service.Client.NewRequestDo(ctx, "GET", path, nil, nil, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return response, resp, nil</span>
}

func GetDeepTraceSession(ctx context.Context, service *services.Service, deviceID int, traceID string) (*http.Response, error) <span class="cov0" title="0">{
        path := fmt.Sprintf("%s/%d/deeptraces/%s", deepTracesEndpoint, deviceID, traceID)
        resp, err := service.Client.NewRequestDo(ctx, "GET", path, nil, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resp, nil</span>
}

func CreateDeepTraceSession(ctx context.Context, service *services.Service, deviceID int, payload DeepTraceSessionPayload) (*DeepTraceSession, *http.Response, error) <span class="cov0" title="0">{
        var response DeepTraceSession
        path := fmt.Sprintf("%s/%d/deeptraces", deepTracesEndpoint, deviceID)
        resp, err := service.Client.NewRequestDo(ctx, "POST", path, nil, payload, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return &amp;response, resp, nil</span>
}

func DeleteDeepTraceSession(ctx context.Context, service *services.Service, deviceID int, traceID string) (*http.Response, error) <span class="cov0" title="0">{
        path := fmt.Sprintf("%s/%d/deeptraces/%s", deepTracesEndpoint, deviceID, traceID)
        resp, err := service.Client.NewRequestDo(ctx, "DELETE", path, nil, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package zdx

import (
        "bytes"
        "context"
        "crypto/sha256"
        "crypto/tls"
        "encoding/hex"
        "encoding/json"
        "errors"
        "fmt"
        "html"
        "io"
        "math"
        "math/rand"
        "net/http"
        "net/url"
        "os"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/google/go-querystring/query"
        "github.com/google/uuid"
        "github.com/hashicorp/go-retryablehttp"
        "github.com/zscaler/zscaler-sdk-go/v3/logger"
        rl "github.com/zscaler/zscaler-sdk-go/v3/ratelimiter"
        "github.com/zscaler/zscaler-sdk-go/v3/utils"
        "github.com/zscaler/zscaler-sdk-go/v3/zscaler/errorx"
)

type Client struct {
        sync.Mutex
        Config *Configuration
}

func NewClient(config *Configuration) (*Client, error) <span class="cov6" title="26">{
        if config == nil </span><span class="cov0" title="0">{
                return nil, errors.New("configuration cannot be nil")
        }</span>

        // Enable Debug logging if the Debug flag is set
        <span class="cov6" title="26">if config.Debug </span><span class="cov0" title="0">{
                _ = os.Setenv("ZSCALER_SDK_LOG", "true")
                _ = os.Setenv("ZSCALER_SDK_VERBOSE", "true")
                config.Logger = logger.GetDefaultLogger("zdx-logger: ")
        }</span>

        // Ensure HTTP clients are properly initialized
        <span class="cov6" title="26">if config.HTTPClient == nil </span><span class="cov0" title="0">{
                config.HTTPClient = getHTTPClient(config.Logger, nil, config)
        }</span>

        // Authenticate the client using the configuration
        <span class="cov6" title="26">authToken, err := Authenticate(config.Context, config, config.Logger)
        if err != nil </span><span class="cov0" title="0">{
                config.Logger.Printf("[ERROR] Failed to authenticate client: %v\n", err)
                return nil, fmt.Errorf("failed to authenticate client: %w", err)
        }</span>

        <span class="cov6" title="26">config.ZDX.Client.AuthToken = authToken

        client := &amp;Client{
                Config: config,
        }

        return client, nil</span>
}

func (cfg *Configuration) SetBackoffConfig(backoffConf *BackoffConfig) <span class="cov0" title="0">{
        cfg.ZDX.Client.RateLimit.BackoffConf = backoffConf
}</span>

// getHTTPClient sets up the retryable HTTP client with backoff and retry policies.
func getHTTPClient(l logger.Logger, rateLimiter *rl.RateLimiter, cfg *Configuration) *http.Client <span class="cov6" title="26">{
        retryableClient := retryablehttp.NewClient()

        // Set retry settings
        retryableClient.RetryWaitMin = cfg.ZDX.Client.RateLimit.RetryWaitMin
        retryableClient.RetryWaitMax = cfg.ZDX.Client.RateLimit.RetryWaitMax

        retryableClient.RetryMax = int(cfg.ZDX.Client.RateLimit.MaxRetries)
        if retryableClient.RetryMax == 0 </span><span class="cov0" title="0">{
                retryableClient.RetryMax = math.MaxInt32
        }</span>

        // Use configured threshold or fallback to 2
        <span class="cov6" title="26">threshold := cfg.ZDX.Client.RateLimit.BackoffConf
        var proactiveThreshold int
        if threshold != nil &amp;&amp; threshold.MaxNumOfRetries &gt; 0 </span><span class="cov0" title="0">{
                proactiveThreshold = threshold.MaxNumOfRetries
        }</span> else<span class="cov6" title="26"> {
                proactiveThreshold = 2
        }</span>

        // Backoff logic with rate limit headers
        <span class="cov6" title="26">retryableClient.Backoff = func(min, max time.Duration, attemptNum int, resp *http.Response) time.Duration </span><span class="cov0" title="0">{
                if resp != nil </span><span class="cov0" title="0">{
                        retryAfter := getRetryAfter(resp, l, proactiveThreshold)
                        if retryAfter &gt; 0 </span><span class="cov0" title="0">{
                                return retryAfter
                        }</span>

                        <span class="cov0" title="0">if resp.Request != nil &amp;&amp; rateLimiter != nil </span><span class="cov0" title="0">{
                                wait, delay := rateLimiter.Wait(resp.Request.Method)
                                if wait </span><span class="cov0" title="0">{
                                        return delay
                                }</span>
                        }
                }

                // Default exponential backoff
                <span class="cov0" title="0">multiplier := math.Pow(2, float64(attemptNum)) * float64(min)
                sleep := time.Duration(multiplier)
                if float64(sleep) != multiplier || sleep &gt; max </span><span class="cov0" title="0">{
                        sleep = max
                }</span>
                <span class="cov0" title="0">return sleep</span>
        }

        <span class="cov6" title="26">retryableClient.CheckRetry = checkRetry
        retryableClient.Logger = l

        // Set request timeout
        if cfg.ZDX.Client.RequestTimeout == 0 </span><span class="cov0" title="0">{
                retryableClient.HTTPClient.Timeout = time.Second * 60
        }</span> else<span class="cov6" title="26"> {
                retryableClient.HTTPClient.Timeout = cfg.ZDX.Client.RequestTimeout
        }</span>

        // Configure proxy settings
        <span class="cov6" title="26">proxyFunc := http.ProxyFromEnvironment
        if cfg.ZDX.Client.Proxy.Host != "" </span><span class="cov0" title="0">{
                proxyURLString := fmt.Sprintf("http://%s:%d", cfg.ZDX.Client.Proxy.Host, cfg.ZDX.Client.Proxy.Port)
                if cfg.ZDX.Client.Proxy.Username != "" &amp;&amp; cfg.ZDX.Client.Proxy.Password != "" </span><span class="cov0" title="0">{
                        proxyAuth := url.UserPassword(cfg.ZDX.Client.Proxy.Username, cfg.ZDX.Client.Proxy.Password)
                        proxyURLString = fmt.Sprintf("http://%s@%s:%d", proxyAuth.String(), cfg.ZDX.Client.Proxy.Host, cfg.ZDX.Client.Proxy.Port)
                }</span>

                <span class="cov0" title="0">proxyURL, err := url.Parse(proxyURLString)
                if err == nil </span><span class="cov0" title="0">{
                        proxyFunc = http.ProxyURL(proxyURL)
                }</span> else<span class="cov0" title="0"> {
                        l.Printf("[ERROR] Invalid proxy URL: %v", err)
                }</span>
        }

        <span class="cov6" title="26">transport := &amp;http.Transport{
                Proxy:               proxyFunc,
                MaxIdleConnsPerHost: maxIdleConnections,
        }

        if cfg.ZDX.Testing.DisableHttpsCheck </span><span class="cov0" title="0">{
                transport.TLSClientConfig = &amp;tls.Config{InsecureSkipVerify: false}
                l.Printf("[INFO] HTTPS certificate validation is disabled (testing mode).")
        }</span>

        <span class="cov6" title="26">retryableClient.HTTPClient.Transport = transport
        return retryableClient.StandardClient()</span>
}

func containsInt(codes []int, code int) bool <span class="cov6" title="26">{
        for _, a := range codes </span><span class="cov6" title="26">{
                if a == code </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov6" title="26">return false</span>
}

func getRetryAfter(resp *http.Response, l logger.Logger, threshold int) time.Duration <span class="cov9" title="123">{
        remaining := resp.Header.Get("X-Ratelimit-Remaining-Second")
        limit := resp.Header.Get("X-Ratelimit-Limit-Second")

        l.Printf("[DEBUG] X-Ratelimit-Remaining-Second: %s", remaining)
        l.Printf("[DEBUG] X-Ratelimit-Limit-Second: %s", limit)

        // Preemptive backoff before hitting the limit
        if remaining != "" </span><span class="cov0" title="0">{
                if val, err := strconv.Atoi(remaining); err == nil &amp;&amp; val &lt; threshold </span><span class="cov0" title="0">{
                        jitter := time.Duration(rand.Intn(500)) * time.Millisecond
                        l.Printf("[INFO] Approaching rate limit (remaining=%d &lt; threshold=%d), backing off for 1s + %s jitter", val, threshold, jitter)
                        return time.Second + jitter
                }</span>
        }

        // Retry after actual 429 (fallback strategy)
        <span class="cov9" title="123">if resp.StatusCode == http.StatusTooManyRequests </span><span class="cov9" title="123">{
                l.Printf("[WARN] 429 received, applying fallback retry delay (2s)")
                return 2 * time.Second
        }</span>

        // Default fallback delay for other cases
        <span class="cov0" title="0">return 500 * time.Millisecond</span>
}

// getRetryOnStatusCodes return a list of http status codes we want to apply retry on.
// return empty slice to enable retry on all connection &amp; server errors.
// or return []int{429}  to retry on only TooManyRequests error
func getRetryOnStatusCodes() []int <span class="cov6" title="26">{
        return []int{http.StatusTooManyRequests}
}</span>

// Used to make http client retry on provided list of response status codes
func checkRetry(ctx context.Context, resp *http.Response, err error) (bool, error) <span class="cov6" title="26">{
        if ctx.Err() != nil </span><span class="cov0" title="0">{
                return false, ctx.Err()
        }</span>
        <span class="cov6" title="26">if resp != nil &amp;&amp; containsInt(getRetryOnStatusCodes(), resp.StatusCode) </span><span class="cov0" title="0">{
                return true, nil
        }</span>
        <span class="cov6" title="26">return retryablehttp.DefaultRetryPolicy(ctx, resp, err)</span>
}

type ApiErr struct {
        Code    string `json:"code"`
        Message string `json:"message"`
}

func Authenticate(ctx context.Context, cfg *Configuration, logger logger.Logger) (*AuthToken, error) <span class="cov8" title="78">{
        cfg.Lock()
        defer cfg.Unlock()

        if cfg.ZDX.Client.AuthToken == nil || cfg.ZDX.Client.AuthToken.AccessToken == "" || utils.IsTokenExpired(cfg.ZDX.Client.AuthToken.AccessToken) </span><span class="cov6" title="26">{
                if cfg.ZDX.Client.ZDXAPIKeyID == "" || cfg.ZDX.Client.ZDXAPISecret == "" </span><span class="cov0" title="0">{
                        logger.Printf("[ERROR] No client credentials provided. Set %s and %s environment variables or use ConfigSetter.", ZDX_API_KEY_ID, ZDX_API_SECRET)
                        return nil, fmt.Errorf("missing client credentials: %s and/or %s", ZDX_API_KEY_ID, ZDX_API_SECRET)
                }</span>

                <span class="cov6" title="26">maskedAPIKeyID := maskAPIKeyID(cfg.ZDX.Client.ZDXAPIKeyID)
                currTimestamp := time.Now().Unix()
                authReq := AuthRequest{
                        Timestamp:    currTimestamp,
                        APIKeyID:     cfg.ZDX.Client.ZDXAPIKeyID,
                        APIKeySecret: generateHash(cfg.ZDX.Client.ZDXAPISecret, currTimestamp),
                }

                data, _ := json.Marshal(authReq)
                url := cfg.BaseURL.String() + "/v1/oauth/token"

                attempts := 0
                maxAttempts := int(cfg.ZDX.Client.RateLimit.MaxRetries)
                if maxAttempts == 0 </span><span class="cov0" title="0">{
                        maxAttempts = 5
                }</span>

                <span class="cov6" title="26">for attempts &lt; maxAttempts </span><span class="cov10" title="149">{
                        req, err := http.NewRequest("POST", url, strings.NewReader(string(data)))
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Printf("[ERROR] Failed to create request for user %s=%s, err: %v", ZDX_API_KEY_ID, maskedAPIKeyID, err)
                                return nil, fmt.Errorf("[ERROR] Failed to create request for user %s=%s, err: %v", ZDX_API_KEY_ID, maskedAPIKeyID, err)
                        }</span>

                        <span class="cov10" title="149">req.Header.Add("Content-Type", contentTypeJSON)
                        if cfg.UserAgent != "" </span><span class="cov10" title="149">{
                                req.Header.Add("User-Agent", cfg.UserAgent)
                        }</span>

                        <span class="cov10" title="149">resp, err := cfg.HTTPClient.Do(req)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Printf("[ERROR] Failed to sign in the user %s=%s, err: %v", ZDX_API_KEY_ID, maskedAPIKeyID, err)
                                return nil, fmt.Errorf("[ERROR] Failed to sign in the user %s=%s, err: %v", ZDX_API_KEY_ID, maskedAPIKeyID, err)
                        }</span>
                        <span class="cov10" title="149">defer resp.Body.Close()

                        respBody, err := io.ReadAll(resp.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Printf("[ERROR] Failed to read response for user %s=%s, err: %v", ZDX_API_KEY_ID, maskedAPIKeyID, err)
                                return nil, fmt.Errorf("[ERROR] Failed to read response for user %s=%s, err: %v", ZDX_API_KEY_ID, maskedAPIKeyID, err)
                        }</span>

                        <span class="cov10" title="149">if resp.StatusCode == http.StatusTooManyRequests || resp.StatusCode == http.StatusServiceUnavailable </span><span class="cov9" title="123">{
                                // Use the centralized retry logic
                                sleepTime := getRetryAfter(resp, logger, 2) // Default proactive threshold = 2
                                logger.Printf("[WARN] Rate limit hit (attempt %d/%d). Retrying in %s", attempts+1, maxAttempts, sleepTime)
                                time.Sleep(sleepTime)
                                attempts++
                                continue</span>
                        }

                        <span class="cov6" title="26">if resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                                logger.Printf("[ERROR] Failed to sign in the user %s=%s, got HTTP status: %d, response body: %s, url: %s",
                                        ZDX_API_KEY_ID, maskedAPIKeyID, resp.StatusCode, respBody, url)
                                return nil, fmt.Errorf("[ERROR] Failed to sign in the user %s=%s, got HTTP status: %d, response body: %s, url: %s",
                                        ZDX_API_KEY_ID, maskedAPIKeyID, resp.StatusCode, respBody, url)
                        }</span>

                        <span class="cov6" title="26">var authToken AuthToken
                        err = json.Unmarshal(respBody, &amp;authToken)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Printf("[ERROR] Failed to parse response for user %s=%s, err: %v", ZDX_API_KEY_ID, maskedAPIKeyID, err)
                                return nil, fmt.Errorf("[ERROR] Failed to parse response for user %s=%s, err: %v", ZDX_API_KEY_ID, maskedAPIKeyID, err)
                        }</span>

                        <span class="cov6" title="26">cfg.ZDX.Client.AuthToken = &amp;authToken
                        return &amp;authToken, nil</span>
                }

                <span class="cov0" title="0">logger.Printf("[ERROR] Rate limit retries exceeded for user %s=%s", ZDX_API_KEY_ID, maskedAPIKeyID)
                return nil, fmt.Errorf("[ERROR] Rate limit retries exceeded for user %s=%s", ZDX_API_KEY_ID, maskedAPIKeyID)</span>
        }

        <span class="cov8" title="52">return cfg.ZDX.Client.AuthToken, nil</span>
}

func (client *Client) NewRequestDo(ctx context.Context, method, urlStr string, options, body, v interface{}) (*http.Response, error) <span class="cov6" title="26">{
        if client == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("client is nil: ensure the client is properly initialized")
        }</span>
        <span class="cov6" title="26">return client.newRequestDoCustom(ctx, method, urlStr, options, body, v, client.Config)</span>
}

func (client *Client) newRequestDoCustom(ctx context.Context, method, urlStr string, options, body, v interface{}, config *Configuration) (*http.Response, error) <span class="cov6" title="26">{
        // Authenticate and log errors
        if _, err := Authenticate(ctx, config, config.Logger); err != nil </span><span class="cov0" title="0">{
                client.Config.Logger.Printf("[ERROR] Authentication failed: %v", err)
                return nil, err
        }</span>

        // Create the request
        <span class="cov6" title="26">req, err := client.newRequest(method, urlStr, options, body, client.Config)
        if err != nil </span><span class="cov0" title="0">{
                client.Config.Logger.Printf("[ERROR] Failed to create request: %v", err)
                return nil, err
        }</span>

        <span class="cov6" title="26">req = req.WithContext(ctx)

        reqID := uuid.NewString()
        start := time.Now()
        logger.LogRequest(client.Config.Logger, req, reqID, nil, true)

        // Perform the request
        resp, err := client.do(req, v, start, reqID)
        if err != nil </span><span class="cov0" title="0">{
                client.Config.Logger.Printf("[ERROR] Request failed: %v", err)
                return resp, err
        }</span>

        // Safeguard against nil response
        <span class="cov6" title="26">if resp == nil </span><span class="cov0" title="0">{
                client.Config.Logger.Printf("[ERROR] Received nil response from API.")
                return nil, fmt.Errorf("received nil response from API")
        }</span>

        <span class="cov6" title="26">defer func() </span><span class="cov6" title="26">{
                if resp != nil &amp;&amp; resp.Body != nil </span><span class="cov6" title="26">{
                        resp.Body.Close()
                }</span>
        }()

        // Handle unauthorized or forbidden responses
        <span class="cov6" title="26">if resp.StatusCode == http.StatusUnauthorized || resp.StatusCode == http.StatusForbidden </span><span class="cov0" title="0">{
                client.Config.Logger.Printf("[WARN] Unauthorized or forbidden response. Retrying authentication.")

                // Re-authenticate and log errors
                if _, err := Authenticate(ctx, config, config.Logger); err != nil </span><span class="cov0" title="0">{
                        client.Config.Logger.Printf("[ERROR] Re-authentication failed: %v", err)
                        return nil, err
                }</span>

                // Retry the original request
                <span class="cov0" title="0">resp, err = client.do(req, v, start, reqID)
                if err != nil </span><span class="cov0" title="0">{
                        client.Config.Logger.Printf("[ERROR] Request failed after re-authentication: %v", err)
                        return nil, err
                }</span>

                // Ensure the response is not nil before returning
                <span class="cov0" title="0">if resp == nil </span><span class="cov0" title="0">{
                        client.Config.Logger.Printf("[ERROR] Nil response received after re-authentication.")
                        return nil, fmt.Errorf("nil response received after re-authentication")
                }</span>
        }

        <span class="cov6" title="26">return resp, err</span>
}

func generateHash(apiSecret string, currTimestamp int64) string <span class="cov6" title="26">{
        currTimestampStr := strconv.FormatInt(currTimestamp, 10)
        hash := sha256.New()
        hash.Write([]byte(apiSecret + ":" + currTimestampStr))
        return hex.EncodeToString(hash.Sum(nil))
}</span>

func maskAPIKeyID(apiKeyID string) string <span class="cov6" title="26">{
        if len(apiKeyID) &lt;= 4 </span><span class="cov0" title="0">{
                return "****"
        }</span>
        <span class="cov6" title="26">return apiKeyID[:2] + strings.Repeat("*", len(apiKeyID)-4) + apiKeyID[len(apiKeyID)-2:]</span>
}

// Generating the Http request
func (client *Client) newRequest(method, urlPath string, options, body interface{}, cfg *Configuration) (*http.Request, error) <span class="cov6" title="26">{
        if cfg.ZDX.Client.AuthToken == nil || cfg.ZDX.Client.AuthToken.AccessToken == "" </span><span class="cov0" title="0">{
                maskedAPIKeyID := maskAPIKeyID(cfg.ZDX.Client.ZDXAPIKeyID)
                client.Config.Logger.Printf("[ERROR] Failed to sign in the user %s=%s\n", ZDX_API_KEY_ID, maskedAPIKeyID)
                return nil, fmt.Errorf("failed to sign in the user %s=%s", ZDX_API_KEY_ID, maskedAPIKeyID)
        }</span>
        <span class="cov6" title="26">var buf io.ReadWriter
        if body != nil </span><span class="cov0" title="0">{
                buf = new(bytes.Buffer)
                err := json.NewEncoder(buf).Encode(body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Join the path to the base-url
        <span class="cov6" title="26">u := *client.Config.BaseURL
        unescaped, err := url.PathUnescape(urlPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set the encoded path data
        <span class="cov6" title="26">u.RawPath = u.Path + urlPath
        u.Path = u.Path + unescaped

        // Set the query parameters
        if options != nil </span><span class="cov6" title="26">{
                q, err := query.Values(options)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov6" title="26">u.RawQuery = q.Encode()</span>
        }

        <span class="cov6" title="26">req, err := http.NewRequest(method, u.String(), buf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="26">req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", cfg.ZDX.Client.AuthToken.AccessToken))
        req.Header.Add("Content-Type", contentTypeJSON)

        if client.Config.UserAgent != "" </span><span class="cov6" title="26">{
                req.Header.Add("User-Agent", client.Config.UserAgent)
        }</span>

        <span class="cov6" title="26">return req, nil</span>
}

func (client *Client) do(req *http.Request, v interface{}, start time.Time, reqID string) (*http.Response, error) <span class="cov6" title="26">{
        // Initialize the HTTP client using the configuration's method
        httpClient := getHTTPClient(client.Config.Logger, nil, client.Config)

        resp, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Read and log the response body
        <span class="cov6" title="26">respBody, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="26">resp.Body = io.NopCloser(bytes.NewBuffer(respBody)) // Reset the response body

        logger.LogResponse(client.Config.Logger, resp, start, reqID)
        logger.WriteLog(client.Config.Logger, "Response Body: %s", string(respBody)) // Log the response body separately

        if err := errorx.CheckErrorInResponse(resp, err); err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov6" title="26">if v != nil </span><span class="cov6" title="26">{
                // Reset the response body again for unmarshalling
                resp.Body = io.NopCloser(bytes.NewBuffer(respBody))
                if err := decodeJSON(resp, v); err != nil </span><span class="cov0" title="0">{
                        return resp, err
                }</span>
        }
        <span class="cov6" title="26">unescapeHTML(v)
        return resp, nil</span>
}

func decodeJSON(res *http.Response, v interface{}) error <span class="cov6" title="26">{
        return json.NewDecoder(res.Body).Decode(&amp;v)
}</span>

func unescapeHTML(entity interface{}) <span class="cov6" title="26">{
        if entity == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov6" title="26">data, err := json.Marshal(entity)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov6" title="26">var mapData map[string]interface{}
        err = json.Unmarshal(data, &amp;mapData)
        if err != nil </span><span class="cov4" title="7">{
                return
        }</span>
        <span class="cov6" title="19">for _, field := range []string{"name", "description"} </span><span class="cov7" title="38">{
                if v, ok := mapData[field]; ok &amp;&amp; v != nil </span><span class="cov0" title="0">{
                        str, ok := v.(string)
                        if ok </span><span class="cov0" title="0">{
                                mapData[field] = html.UnescapeString(html.UnescapeString(str))
                        }</span>
                }
        }
        <span class="cov6" title="19">data, err = json.Marshal(mapData)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov6" title="19">json.Unmarshal(data, entity)</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package zdx

import (
        "context"
        "errors"
        "fmt"
        "net/http"
        "net/url"
        "os"
        "os/user"
        "runtime"
        "sync"
        "time"

        "github.com/kelseyhightower/envconfig"
        "github.com/zscaler/zscaler-sdk-go/v3/logger"
        rl "github.com/zscaler/zscaler-sdk-go/v3/ratelimiter"
        "gopkg.in/yaml.v3"
)

type contextKey string

func (c contextKey) String() string <span class="cov0" title="0">{
        return "zscaler " + string(c)
}</span>

var (
        // ContextAccessToken takes a string OAuth2 access token as authentication for the request.
        ContextAccessToken = contextKey("access_token")
)

const (
        maxIdleConnections    int = 40
        requestTimeout        int = 60
        JSessionIDTimeout         = 30 // minutes.
        jSessionTimeoutOffset     = 5 * time.Minute
        contentTypeJSON           = "application/json"
        cookieName                = "JSESSIONID"
        MaxNumOfRetries           = 100
        RetryWaitMaxSeconds       = 20
        RetryWaitMinSeconds       = 5
        loggerPrefix              = "zdx-logger: "
)

const (
        VERSION        = "3.1.4"
        ZDX_API_KEY_ID = "ZDX_API_KEY_ID"
        ZDX_API_SECRET = "ZDX_API_SECRET"
)

type BackoffConfig struct {
        Enabled             bool // Set to true to enable backoff and retry mechanism
        RetryWaitMinSeconds int  // Minimum time to wait
        RetryWaitMaxSeconds int  // Maximum time to wait
        MaxNumOfRetries     int  // Maximum number of retries
}

type AuthRequest struct {
        APIKeyID     string `json:"key_id"`
        APIKeySecret string `json:"key_secret"`
        Timestamp    int64  `json:"timestamp"`
}

type AuthToken struct {
        TokenType   string `json:"token_type"`
        AccessToken string `json:"token"`
        ExpiresIn   int    `json:"expires_in"`
}

type Configuration struct {
        sync.Mutex
        Logger         logger.Logger
        HTTPClient     *http.Client
        BaseURL        *url.URL
        DefaultHeader  map[string]string `json:"defaultHeader,omitempty"`
        UserAgent      string            `json:"userAgent,omitempty"`
        Debug          bool              `json:"debug,omitempty"`
        UserAgentExtra string
        Context        context.Context
        ZDX            struct {
                Client struct {
                        ZDXAPIKeyID  string     `yaml:"apiKey" envconfig:"ZDX_API_KEY_ID"`
                        ZDXAPISecret string     `yaml:"secretKey" envconfig:"ZDX_API_SECRET"`
                        ZDXCloud     string     `yaml:"cloud" envconfig:"ZDX_CLOUD"`
                        AuthToken    *AuthToken `yaml:"authToken"`
                        AccessToken  *AuthToken `yaml:"accessToken"`
                        Proxy        struct {
                                Port     int32  `yaml:"port" envconfig:"ZDX_CLIENT_PROXY_PORT"`
                                Host     string `yaml:"host" envconfig:"ZDX_CLIENT_PROXY_HOST"`
                                Username string `yaml:"username" envconfig:"ZDX_CLIENT_PROXY_USERNAME"`
                                Password string `yaml:"password" envconfig:"ZDX_CLIENT_PROXY_PASSWORD"`
                        } `yaml:"proxy"`
                        RequestTimeout time.Duration `yaml:"requestTimeout" envconfig:"ZDX_CLIENT_REQUEST_TIMEOUT"`
                        RateLimit      struct {
                                MaxRetries              int32         `yaml:"maxRetries" envconfig:"ZDX_CLIENT_RATE_LIMIT_MAX_RETRIES"`
                                RetryWaitMin            time.Duration `yaml:"minWait" envconfig:"ZDX_CLIENT_RATE_LIMIT_MIN_WAIT"`
                                RetryWaitMax            time.Duration `yaml:"maxWait" envconfig:"ZDX_CLIENT_RATE_LIMIT_MAX_WAIT"`
                                RetryRemainingThreshold int           `yaml:"remainingThreshold" envconfig:"ZDX_CLIENT_RATE_LIMIT_REMAINING_THRESHOLD"`
                                BackoffConf             *BackoffConfig
                        } `yaml:"rateLimit"`
                } `yaml:"client"`
                Testing struct {
                        DisableHttpsCheck bool `yaml:"disableHttpsCheck" envconfig:"ZDX_TESTING_DISABLE_HTTPS_CHECK"`
                } `yaml:"testing"`
        } `yaml:"zdx"`
}

func NewConfiguration(conf ...ConfigSetter) (*Configuration, error) <span class="cov7" title="26">{
        logger := logger.GetDefaultLogger(loggerPrefix)
        cfg := &amp;Configuration{
                DefaultHeader: make(map[string]string),
                Logger:        logger,
                UserAgent:     fmt.Sprintf("zscaler-sdk-go/%s golang/%s %s/%s", VERSION, runtime.Version(), runtime.GOOS, runtime.GOARCH),
                Debug:         false,
                Context:       context.Background(),
        }

        // logger.Printf("[DEBUG] Initializing configuration with default values.")

        // Set default rate limit and request timeout values
        cfg.ZDX.Client.RateLimit.MaxRetries = MaxNumOfRetries
        cfg.ZDX.Client.RateLimit.RetryWaitMax = time.Second * time.Duration(RetryWaitMaxSeconds)
        cfg.ZDX.Client.RateLimit.RetryWaitMin = time.Second * time.Duration(RetryWaitMinSeconds)
        cfg.ZDX.Client.RequestTimeout = time.Duration(requestTimeout) * time.Second

        // Read configuration from YAML (lowest precedence)
        readConfigFromSystem(cfg)
        // logger.Printf("[DEBUG] Configuration loaded from system configuration.")

        // Read environment variables (medium precedence)
        readConfigFromEnvironment(cfg)
        // logger.Printf("[DEBUG] Configuration loaded from environment variables.")

        // Apply ConfigSetter functions (highest precedence)
        for _, confSetter := range conf </span><span class="cov10" title="78">{
                confSetter(cfg)
        }</span>
        // logger.Printf("[DEBUG] Configuration setters applied.")

        // Validate credentials after all sources (YAML, env, setters)
        <span class="cov7" title="26">if cfg.ZDX.Client.ZDXAPIKeyID == "" || cfg.ZDX.Client.ZDXAPISecret == "" </span><span class="cov0" title="0">{
                logger.Printf("[ERROR] Missing ZDX credentials. Ensure they are provided via setters, environment variables, or YAML configuration.")
                return nil, errors.New("missing required ZDX credentials")
        }</span>

        // Construct and validate the base URL
        <span class="cov7" title="26">var rawBaseURL string
        if cfg.ZDX.Client.ZDXCloud == "" </span><span class="cov7" title="26">{
                rawBaseURL = "https://api.zdxcloud.net" // Default base URL
        }</span> else<span class="cov0" title="0"> {
                rawBaseURL = fmt.Sprintf("https://api.%s.net", cfg.ZDX.Client.ZDXCloud) // User-specified ZDXCloud
        }</span>
        <span class="cov7" title="26">baseURL, err := url.Parse(rawBaseURL)
        if err != nil </span><span class="cov0" title="0">{
                logger.Printf("[ERROR] Error occurred while configuring the base URL: %v", err)
                return nil, fmt.Errorf("invalid base URL: %w", err)
        }</span>
        <span class="cov7" title="26">cfg.BaseURL = baseURL
        // logger.Printf("[DEBUG] Base URL configured successfully: %s", cfg.BaseURL.String())

        // Set up HTTP clients
        setHttpClients(cfg)
        if cfg.HTTPClient == nil </span><span class="cov0" title="0">{
                logger.Printf("[ERROR] HTTP clients not initialized")
                return nil, errors.New("HTTP clients not initialized")
        }</span>
        // logger.Printf("[DEBUG] HTTP clients configured.")

        // Authenticate the client and populate the AuthToken
        <span class="cov7" title="26">authToken, err := Authenticate(cfg.Context, cfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Printf("[ERROR] Authentication failed: %v", err)
                return nil, fmt.Errorf("authentication failed: %w", err)
        }</span>
        <span class="cov7" title="26">cfg.ZDX.Client.AuthToken = authToken

        // Add the AuthToken to the context
        if cfg.ZDX.Client.AuthToken != nil &amp;&amp; cfg.ZDX.Client.AuthToken.AccessToken != "" </span><span class="cov7" title="26">{
                cfg.Context = context.WithValue(context.Background(), ContextAccessToken, cfg.ZDX.Client.AuthToken.AccessToken)
                // logger.Printf("[DEBUG] AuthToken added to context.")
        }</span> else<span class="cov0" title="0"> {
                logger.Printf("[ERROR] Failed to set AuthToken in context.")
                return nil, errors.New("AuthToken is missing or invalid after authentication")
        }</span>

        // logger.Printf("[DEBUG] Configuration successfully initialized.")
        <span class="cov7" title="26">return cfg, nil</span>
}

type ConfigSetter func(*Configuration)

// ConfigSetter type defines a function that modifies a Config struct.
// WithClientID sets the ClientID in the Config.
func WithZDXAPIKeyID(keyID string) ConfigSetter <span class="cov7" title="26">{
        return func(c *Configuration) </span><span class="cov7" title="26">{
                c.ZDX.Client.ZDXAPIKeyID = keyID
        }</span>
}

// WithClientSecret sets the ClientSecret in the Config.
func WithZDXAPISecret(apiSecret string) ConfigSetter <span class="cov7" title="26">{
        return func(c *Configuration) </span><span class="cov7" title="26">{
                c.ZDX.Client.ZDXAPISecret = apiSecret
        }</span>
}

func WithZDXCloud(cloud string) ConfigSetter <span class="cov0" title="0">{
        return func(c *Configuration) </span><span class="cov0" title="0">{
                c.ZDX.Client.ZDXCloud = cloud
        }</span>
}

// WithHttpClient sets the HttpClient in the Config.
func WithHttpClientPtr(httpClient *http.Client) ConfigSetter <span class="cov0" title="0">{
        return func(c *Configuration) </span><span class="cov0" title="0">{
                c.HTTPClient = httpClient
        }</span>
}

func WithProxyPort(i int32) ConfigSetter <span class="cov0" title="0">{
        return func(c *Configuration) </span><span class="cov0" title="0">{
                c.ZDX.Client.Proxy.Port = i
        }</span>
}

func WithProxyHost(host string) ConfigSetter <span class="cov0" title="0">{
        return func(c *Configuration) </span><span class="cov0" title="0">{
                c.ZDX.Client.Proxy.Host = host
        }</span>
}

func WithProxyUsername(username string) ConfigSetter <span class="cov0" title="0">{
        return func(c *Configuration) </span><span class="cov0" title="0">{
                c.ZDX.Client.Proxy.Username = username
        }</span>
}

func WithProxyPassword(pass string) ConfigSetter <span class="cov0" title="0">{
        return func(c *Configuration) </span><span class="cov0" title="0">{
                c.ZDX.Client.Proxy.Password = pass
        }</span>
}

func WithTestingDisableHttpsCheck(httpsCheck bool) ConfigSetter <span class="cov0" title="0">{
        return func(c *Configuration) </span><span class="cov0" title="0">{
                c.ZDX.Testing.DisableHttpsCheck = httpsCheck
        }</span>
}

func WithRequestTimeout(requestTimeout time.Duration) ConfigSetter <span class="cov0" title="0">{
        return func(c *Configuration) </span><span class="cov0" title="0">{
                c.ZDX.Client.RequestTimeout = requestTimeout
                setHttpClients(c)
        }</span>
}

func WithRateLimitMaxRetries(maxRetries int32) ConfigSetter <span class="cov0" title="0">{
        return func(c *Configuration) </span><span class="cov0" title="0">{
                c.ZDX.Client.RateLimit.MaxRetries = maxRetries
                setHttpClients(c)
        }</span>
}

func WithRateLimitMaxWait(maxWait time.Duration) ConfigSetter <span class="cov0" title="0">{
        return func(c *Configuration) </span><span class="cov0" title="0">{
                c.ZDX.Client.RateLimit.RetryWaitMax = maxWait
                setHttpClients(c)
        }</span>
}

func WithRateLimitMinWait(minWait time.Duration) ConfigSetter <span class="cov0" title="0">{
        return func(c *Configuration) </span><span class="cov0" title="0">{
                c.ZDX.Client.RateLimit.RetryWaitMin = minWait
                setHttpClients(c)
        }</span>
}

// WithUserAgent sets the UserAgent in the Config.
func WithUserAgentExtra(userAgent string) ConfigSetter <span class="cov0" title="0">{
        return func(c *Configuration) </span><span class="cov0" title="0">{
                c.UserAgentExtra = userAgent
        }</span>
}

func WithDebug(debug bool) ConfigSetter <span class="cov7" title="26">{
        return func(c *Configuration) </span><span class="cov7" title="26">{
                c.Debug = debug
                // Automatically set the environment variables if debug is enabled
                if debug </span><span class="cov0" title="0">{
                        _ = os.Setenv("ZSCALER_SDK_LOG", "true")
                        _ = os.Setenv("ZSCALER_SDK_VERBOSE", "true")
                }</span>
        }
}

func setHttpClients(cfg *Configuration) <span class="cov7" title="26">{
        var log logger.Logger
        if cfg == nil || cfg.Logger == nil </span><span class="cov0" title="0">{
                log = logger.GetDefaultLogger(loggerPrefix)
                log.Printf("[ERROR] Configuration is nil. Cannot initialize HTTP clients.")
                return
        }</span> else<span class="cov7" title="26"> {
                log = cfg.Logger
        }</span>

        // Initialize the global rate limiter (example: 100 requests/min)
        <span class="cov7" title="26">globalLimiter := rl.NewGlobalRateLimiter(100, 60)

        // Configure the HTTP client with rate limiting
        httpClient := &amp;http.Client{
                Transport: &amp;rl.RateLimitTransport{
                        Limiter:         globalLimiter,
                        WaitFunc:        globalLimiter.Wait, // Pass the method reference of the limiter
                        Logger:          log,
                        AdditionalDelay: 5 * time.Second,
                },
        }

        // Assign the rate-limited HTTP client to the configuration
        cfg.HTTPClient = httpClient</span>

        // log.Printf("[DEBUG] HTTP client initialized with global rate limiting.")
}

func readConfigFromFile(location string, c *Configuration) (*Configuration, error) <span class="cov7" title="26">{
        yamlConfig, err := os.ReadFile(location)
        if err != nil </span><span class="cov7" title="26">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = yaml.Unmarshal(yamlConfig, &amp;c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c, err</span>
}

func readConfigFromSystem(c *Configuration) *Configuration <span class="cov7" title="26">{
        currUser, err := user.Current()
        if err != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov7" title="26">if currUser.HomeDir == "" </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov7" title="26">conf, err := readConfigFromFile(currUser.HomeDir+"/.zscaler/zscaler.yaml", c)
        if err != nil </span><span class="cov7" title="26">{
                return c
        }</span>
        <span class="cov0" title="0">return conf</span>
}

func readConfigFromEnvironment(c *Configuration) *Configuration <span class="cov7" title="26">{
        err := envconfig.Process("zscaler", c)
        if err != nil </span><span class="cov0" title="0">{
                c.Logger.Printf("[ERROR] Error parsing environment variables: %v", err)
                return c
        }</span>
        // c.Logger.Printf("[DEBUG] Successfully parsed environment variables.")
        <span class="cov7" title="26">return c</span>
}

// AddDefaultHeader adds a new HTTP header to the default header in the request
func (c *Configuration) AddDefaultHeader(key string, value string) <span class="cov0" title="0">{
        c.DefaultHeader[key] = value
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
