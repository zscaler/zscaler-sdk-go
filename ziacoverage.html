
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>activation_cli: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/zscaler/zscaler-sdk-go/v2/zia/activation_cli/ziaActivator.go (0.0%)</option>
				
				<option value="file1">github.com/zscaler/zscaler-sdk-go/v2/zia/client.go (35.3%)</option>
				
				<option value="file2">github.com/zscaler/zscaler-sdk-go/v2/zia/config.go (50.9%)</option>
				
				<option value="file3">github.com/zscaler/zscaler-sdk-go/v2/zia/errors.go (0.0%)</option>
				
				<option value="file4">github.com/zscaler/zscaler-sdk-go/v2/zia/services/activation/activation.go (75.0%)</option>
				
				<option value="file5">github.com/zscaler/zscaler-sdk-go/v2/zia/services/adminuserrolemgmt/admins/adminusers.go (85.0%)</option>
				
				<option value="file6">github.com/zscaler/zscaler-sdk-go/v2/zia/services/adminuserrolemgmt/roles/adminroles.go (80.0%)</option>
				
				<option value="file7">github.com/zscaler/zscaler-sdk-go/v2/zia/services/cloudbrowserisolation/cloudbrowserisolation.go (80.0%)</option>
				
				<option value="file8">github.com/zscaler/zscaler-sdk-go/v2/zia/services/common/common.go (87.2%)</option>
				
				<option value="file9">github.com/zscaler/zscaler-sdk-go/v2/zia/services/common/service.go (0.0%)</option>
				
				<option value="file10">github.com/zscaler/zscaler-sdk-go/v2/zia/services/devicegroups/devicegroups.go (80.6%)</option>
				
				<option value="file11">github.com/zscaler/zscaler-sdk-go/v2/zia/services/dlp/dlp_engines/dlp_engines.go (88.2%)</option>
				
				<option value="file12">github.com/zscaler/zscaler-sdk-go/v2/zia/services/dlp/dlp_exact_data_match/dlp_exact_data_match.go (88.2%)</option>
				
				<option value="file13">github.com/zscaler/zscaler-sdk-go/v2/zia/services/dlp/dlp_exact_data_match_lite/dlp_exact_data_match_lite.go (95.7%)</option>
				
				<option value="file14">github.com/zscaler/zscaler-sdk-go/v2/zia/services/dlp/dlp_icap_servers/dlp_icap_server.go (88.2%)</option>
				
				<option value="file15">github.com/zscaler/zscaler-sdk-go/v2/zia/services/dlp/dlp_idm_profile_lite/dlp_idm_profile_lite.go (87.5%)</option>
				
				<option value="file16">github.com/zscaler/zscaler-sdk-go/v2/zia/services/dlp/dlp_idm_profiles/dlp_idm_profiles.go (88.2%)</option>
				
				<option value="file17">github.com/zscaler/zscaler-sdk-go/v2/zia/services/dlp/dlp_incident_receiver_servers/dlp_incident_receiver_servers.go (88.2%)</option>
				
				<option value="file18">github.com/zscaler/zscaler-sdk-go/v2/zia/services/dlp/dlp_notification_templates/dlp_notification_templates.go (91.4%)</option>
				
				<option value="file19">github.com/zscaler/zscaler-sdk-go/v2/zia/services/dlp/dlp_web_rules/dlp_web_rules.go (91.4%)</option>
				
				<option value="file20">github.com/zscaler/zscaler-sdk-go/v2/zia/services/dlp/dlpdictionaries/dlpdictionaries.go (91.4%)</option>
				
				<option value="file21">github.com/zscaler/zscaler-sdk-go/v2/zia/services/eventlogentryreport/eventlogentryreport.go (0.0%)</option>
				
				<option value="file22">github.com/zscaler/zscaler-sdk-go/v2/zia/services/firewallpolicies/applicationservices/applicationservices.go (90.9%)</option>
				
				<option value="file23">github.com/zscaler/zscaler-sdk-go/v2/zia/services/firewallpolicies/appservicegroups/appservicegroups.go (90.9%)</option>
				
				<option value="file24">github.com/zscaler/zscaler-sdk-go/v2/zia/services/firewallpolicies/filteringrules/filteringrules.go (91.4%)</option>
				
				<option value="file25">github.com/zscaler/zscaler-sdk-go/v2/zia/services/firewallpolicies/ipdestinationgroups/ipdestinationgroups.go (91.4%)</option>
				
				<option value="file26">github.com/zscaler/zscaler-sdk-go/v2/zia/services/firewallpolicies/ipsourcegroups/ipsourcegroups.go (91.4%)</option>
				
				<option value="file27">github.com/zscaler/zscaler-sdk-go/v2/zia/services/firewallpolicies/networkapplicationgroups/networkapplicationgroups.go (91.4%)</option>
				
				<option value="file28">github.com/zscaler/zscaler-sdk-go/v2/zia/services/firewallpolicies/networkapplications/networkapplications.go (63.6%)</option>
				
				<option value="file29">github.com/zscaler/zscaler-sdk-go/v2/zia/services/firewallpolicies/networkservicegroups/networkservicegroups.go (91.4%)</option>
				
				<option value="file30">github.com/zscaler/zscaler-sdk-go/v2/zia/services/firewallpolicies/networkservices/networkservices.go (91.4%)</option>
				
				<option value="file31">github.com/zscaler/zscaler-sdk-go/v2/zia/services/firewallpolicies/timewindow/timewindow.go (90.9%)</option>
				
				<option value="file32">github.com/zscaler/zscaler-sdk-go/v2/zia/services/forwarding_control_policy/forwarding_rules/forwarding_rules.go (91.4%)</option>
				
				<option value="file33">github.com/zscaler/zscaler-sdk-go/v2/zia/services/forwarding_control_policy/zpa_gateways/service.go (100.0%)</option>
				
				<option value="file34">github.com/zscaler/zscaler-sdk-go/v2/zia/services/forwarding_control_policy/zpa_gateways/zpa_gateways.go (91.4%)</option>
				
				<option value="file35">github.com/zscaler/zscaler-sdk-go/v2/zia/services/intermediatecacertificates/intermediatecacertificates.go (15.2%)</option>
				
				<option value="file36">github.com/zscaler/zscaler-sdk-go/v2/zia/services/location/locationgroups/locationgroups.go (80.0%)</option>
				
				<option value="file37">github.com/zscaler/zscaler-sdk-go/v2/zia/services/location/locationlite/locationlite.go (88.2%)</option>
				
				<option value="file38">github.com/zscaler/zscaler-sdk-go/v2/zia/services/location/locationmanagement/locationmanagement.go (82.6%)</option>
				
				<option value="file39">github.com/zscaler/zscaler-sdk-go/v2/zia/services/rule_labels/rule_labels.go (91.4%)</option>
				
				<option value="file40">github.com/zscaler/zscaler-sdk-go/v2/zia/services/sandbox/sandbox_report/sandbox_report.go (75.9%)</option>
				
				<option value="file41">github.com/zscaler/zscaler-sdk-go/v2/zia/services/sandbox/sandbox_settings/sandbox_settings.go (82.4%)</option>
				
				<option value="file42">github.com/zscaler/zscaler-sdk-go/v2/zia/services/sandbox/sandbox_submission/sandbox_submission.go (77.3%)</option>
				
				<option value="file43">github.com/zscaler/zscaler-sdk-go/v2/zia/services/security_policy_settings/security_policy_settings.go (75.0%)</option>
				
				<option value="file44">github.com/zscaler/zscaler-sdk-go/v2/zia/services/service.go (100.0%)</option>
				
				<option value="file45">github.com/zscaler/zscaler-sdk-go/v2/zia/services/trafficforwarding/greinternalipranges/greinternalipranges.go (75.0%)</option>
				
				<option value="file46">github.com/zscaler/zscaler-sdk-go/v2/zia/services/trafficforwarding/gretunnelinfo/gretunnelinfo.go (87.5%)</option>
				
				<option value="file47">github.com/zscaler/zscaler-sdk-go/v2/zia/services/trafficforwarding/gretunnels/gretunnels.go (91.4%)</option>
				
				<option value="file48">github.com/zscaler/zscaler-sdk-go/v2/zia/services/trafficforwarding/region/datacenter/group_by_datacenter.go (92.6%)</option>
				
				<option value="file49">github.com/zscaler/zscaler-sdk-go/v2/zia/services/trafficforwarding/region/geo_coordinates/geo_coordinates.go (85.7%)</option>
				
				<option value="file50">github.com/zscaler/zscaler-sdk-go/v2/zia/services/trafficforwarding/region/ip_address/ip_address.go (80.0%)</option>
				
				<option value="file51">github.com/zscaler/zscaler-sdk-go/v2/zia/services/trafficforwarding/region/search/region.go (80.0%)</option>
				
				<option value="file52">github.com/zscaler/zscaler-sdk-go/v2/zia/services/trafficforwarding/staticips/staticips.go (91.4%)</option>
				
				<option value="file53">github.com/zscaler/zscaler-sdk-go/v2/zia/services/trafficforwarding/virtualipaddress/virtualipaddress.go (67.3%)</option>
				
				<option value="file54">github.com/zscaler/zscaler-sdk-go/v2/zia/services/trafficforwarding/vpncredentials/vpncredentials.go (72.5%)</option>
				
				<option value="file55">github.com/zscaler/zscaler-sdk-go/v2/zia/services/urlcategories/urlcategories.go (85.0%)</option>
				
				<option value="file56">github.com/zscaler/zscaler-sdk-go/v2/zia/services/urlfilteringpolicies/urlfilteringpolicies.go (89.4%)</option>
				
				<option value="file57">github.com/zscaler/zscaler-sdk-go/v2/zia/services/user_authentication_settings/user_authentication_settings.go (76.7%)</option>
				
				<option value="file58">github.com/zscaler/zscaler-sdk-go/v2/zia/services/usermanagement/departments/departments.go (88.2%)</option>
				
				<option value="file59">github.com/zscaler/zscaler-sdk-go/v2/zia/services/usermanagement/departments/service.go (14.3%)</option>
				
				<option value="file60">github.com/zscaler/zscaler-sdk-go/v2/zia/services/usermanagement/groups/group.go (87.0%)</option>
				
				<option value="file61">github.com/zscaler/zscaler-sdk-go/v2/zia/services/usermanagement/groups/service.go (14.3%)</option>
				
				<option value="file62">github.com/zscaler/zscaler-sdk-go/v2/zia/services/usermanagement/users/service.go (14.3%)</option>
				
				<option value="file63">github.com/zscaler/zscaler-sdk-go/v2/zia/services/usermanagement/users/users.go (67.3%)</option>
				
				<option value="file64">github.com/zscaler/zscaler-sdk-go/v2/zia/services/workloadgroups/workloadgroups.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "log"
        "os"
        "runtime"

        client "github.com/zscaler/zscaler-sdk-go/v2/zia"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/activation"
)

func getEnvVarOrFail(k string) string <span class="cov0" title="0">{
        if v := os.Getenv(k); v != "" </span><span class="cov0" title="0">{
                return v
        }</span>
        <span class="cov0" title="0">log.Fatalf("[ERROR] Couldn't find environment variable %s\n", k)
        return ""</span>
}

func main() <span class="cov0" title="0">{
        log.Printf("[INFO] Initializing ZIA client\n")

        // Here, rather than setting up the client configuration from the external library,
        // we'll simply gather the required details for initializing the client
        username := getEnvVarOrFail("ZIA_USERNAME")
        password := getEnvVarOrFail("ZIA_PASSWORD")
        apiKey := getEnvVarOrFail("ZIA_API_KEY")
        ziaCloud := getEnvVarOrFail("ZIA_CLOUD")
        userAgent := fmt.Sprintf("(%s %s) cli/ziaActivator", runtime.GOOS, runtime.GOARCH)

        // Now, we'll use the local SDK's NewClient method to get the client instance
        cli, err := client.NewClient(username, password, apiKey, ziaCloud, userAgent)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("[ERROR] Failed Initializing ZIA client: %v\n", err)
        }</span>

        <span class="cov0" title="0">service := services.New(cli)
        resp, err := activation.CreateActivation(service, activation.Activation{
                Status: "active",
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[ERROR] Activation Failed: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("[INFO] Activation succeeded: %#v\n", resp)
        }</span>

        <span class="cov0" title="0">log.Printf("[INFO] Destroying session: %#v\n", resp)
        _ = cli.Logout()
        os.Exit(0)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package zia

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "reflect"
        "strings"
        "time"

        "github.com/google/uuid"
        "github.com/zscaler/zscaler-sdk-go/v2/cache"
        "github.com/zscaler/zscaler-sdk-go/v2/logger"
)

func (c *Client) do(req *http.Request, start time.Time, reqID string) (*http.Response, error) <span class="cov10" title="3">{
        key := cache.CreateCacheKey(req)
        if c.cacheEnabled </span><span class="cov0" title="0">{
                if req.Method != http.MethodGet </span><span class="cov0" title="0">{
                        // this will allow to remove resource from cache when PUT/DELETE/PATCH requests are called, which modifies the resource
                        c.cache.Delete(key)
                        // to avoid resources that GET url is not the same as DELETE/PUT/PATCH url, because of different query params.
                        // example delete app segment has key url/&lt;id&gt;?forceDelete=true but GET has url/&lt;id&gt;, in this case we clean the whole cache entries with key prefix url/&lt;id&gt;
                        c.cache.ClearAllKeysWithPrefix(strings.Split(key, "?")[0])
                }</span>
                <span class="cov0" title="0">resp := c.cache.Get(key)
                inCache := resp != nil
                if c.freshCache </span><span class="cov0" title="0">{
                        c.cache.Delete(key)
                        inCache = false
                        c.freshCache = false
                }</span>
                <span class="cov0" title="0">if inCache </span><span class="cov0" title="0">{
                        c.Logger.Printf("[INFO] served from cache, key:%s\n", key)
                        return resp, nil
                }</span>
        }

        <span class="cov10" title="3">resp, err := c.HTTPClient.Do(req)
        logger.LogResponse(c.Logger, resp, start, reqID)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov10" title="3">if c.cacheEnabled &amp;&amp; resp.StatusCode &gt;= 200 &amp;&amp; resp.StatusCode &lt;= 299 &amp;&amp; req.Method == http.MethodGet </span><span class="cov0" title="0">{
                c.Logger.Printf("[INFO] saving to cache, key:%s\n", key)
                c.cache.Set(key, cache.CopyResponse(resp))
        }</span>
        <span class="cov10" title="3">return resp, nil</span>
}

// Request ... // Needs to review this function.
func (c *Client) GenericRequest(baseUrl, endpoint, method string, body io.Reader, urlParams url.Values, contentType string) ([]byte, error) <span class="cov10" title="3">{
        if contentType == "" </span><span class="cov0" title="0">{
                contentType = contentTypeJSON
        }</span>

        <span class="cov10" title="3">var req *http.Request
        var resp *http.Response
        var err error
        params := ""
        if urlParams != nil </span><span class="cov0" title="0">{
                params = urlParams.Encode()
        }</span>
        <span class="cov10" title="3">if strings.Contains(endpoint, "?") &amp;&amp; params != "" </span><span class="cov0" title="0">{
                endpoint += "&amp;" + params
        }</span> else<span class="cov10" title="3"> if params != "" </span><span class="cov0" title="0">{
                endpoint += "?" + params
        }</span>
        <span class="cov10" title="3">fullURL := fmt.Sprintf("%s%s", baseUrl, endpoint)
        isSandboxRequest := baseUrl == c.GetSandboxURL()
        req, err = http.NewRequest(method, fullURL, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="3">req.Header.Set("Content-Type", contentType)
        if c.UserAgent != "" </span><span class="cov0" title="0">{
                req.Header.Add("User-Agent", c.UserAgent)
        }</span>
        <span class="cov10" title="3">var otherHeaders map[string]string
        if !isSandboxRequest </span><span class="cov10" title="3">{
                err = c.checkSession()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov10" title="3">otherHeaders = map[string]string{"JSessionID": c.session.JSessionID}</span>
        }
        <span class="cov10" title="3">reqID := uuid.New().String()
        start := time.Now()
        logger.LogRequest(c.Logger, req, reqID, otherHeaders, !isSandboxRequest)
        for retry := 1; retry &lt;= 5; retry++ </span><span class="cov10" title="3">{
                if !isSandboxRequest </span><span class="cov10" title="3">{
                        err = c.checkSession()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                <span class="cov10" title="3">resp, err = c.do(req, start, reqID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov10" title="3">if resp.StatusCode &lt;= 299 </span><span class="cov10" title="3">{
                        defer resp.Body.Close()
                        break</span>
                }

                <span class="cov0" title="0">resp.Body.Close()
                if resp.StatusCode &gt; 299 &amp;&amp; resp.StatusCode != http.StatusUnauthorized </span><span class="cov0" title="0">{
                        return nil, checkErrorInResponse(resp, fmt.Errorf("api responded with code: %d", resp.StatusCode))
                }</span>
        }

        <span class="cov10" title="3">bodyResp, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="3">return bodyResp, nil</span>
}

// Request ... // Needs to review this function.
func (c *Client) Request(endpoint, method string, data []byte, contentType string) ([]byte, error) <span class="cov10" title="3">{
        return c.GenericRequest(c.URL, endpoint, method, bytes.NewReader(data), nil, contentType)
}</span>

func (client *Client) WithFreshCache() <span class="cov0" title="0">{
        client.freshCache = true
}</span>

// Create send HTTP Post request.
func (c *Client) Create(endpoint string, o interface{}) (interface{}, error) <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return nil, errors.New("tried to create with a nil payload not a Struct")
        }</span>
        <span class="cov0" title="0">t := reflect.TypeOf(o)
        if t.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return nil, errors.New("tried to create with a " + t.Kind().String() + " not a Struct")
        }</span>
        <span class="cov0" title="0">data, err := json.Marshal(o)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp, err := c.Request(endpoint, "POST", data, "application/json")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp) &gt; 0 </span><span class="cov0" title="0">{
                responseObject := reflect.New(t).Interface()
                err = json.Unmarshal(resp, &amp;responseObject)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">id := reflect.Indirect(reflect.ValueOf(responseObject)).FieldByName("ID")

                c.Logger.Printf("Created Object with ID %v", id)
                return responseObject, nil</span>
        } else<span class="cov0" title="0"> {
                // in case of 204 no content
                return nil, nil
        }</span>
}

// Read ...
func (c *Client) Read(endpoint string, o interface{}) error <span class="cov0" title="0">{
        contentType := c.GetContentType()
        resp, err := c.Request(endpoint, "GET", nil, contentType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(resp, o)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Update ...
func (c *Client) UpdateWithPut(endpoint string, o interface{}) (interface{}, error) <span class="cov0" title="0">{
        return c.updateGeneric(endpoint, o, "PUT", "application/json")
}</span>

// Update ...
func (c *Client) Update(endpoint string, o interface{}) (interface{}, error) <span class="cov0" title="0">{
        return c.updateGeneric(endpoint, o, "PATCH", "application/merge-patch+json")
}</span>

// Update ...
func (c *Client) updateGeneric(endpoint string, o interface{}, method, contentType string) (interface{}, error) <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return nil, errors.New("tried to update with a nil payload not a Struct")
        }</span>
        <span class="cov0" title="0">t := reflect.TypeOf(o)
        if t.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return nil, errors.New("tried to update with a " + t.Kind().String() + " not a Struct")
        }</span>
        <span class="cov0" title="0">data, err := json.Marshal(o)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp, err := c.Request(endpoint, method, data, contentType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">responseObject := reflect.New(t).Interface()
        err = json.Unmarshal(resp, &amp;responseObject)
        return responseObject, err</span>
}

// Delete ...
func (c *Client) Delete(endpoint string) error <span class="cov0" title="0">{
        _, err := c.Request(endpoint, "DELETE", nil, "application/json")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package zia

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "math"
        "net/http"
        "net/http/cookiejar"
        "net/url"
        "os"
        "regexp"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/hashicorp/go-retryablehttp"
        "github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
        "github.com/zscaler/zscaler-sdk-go/v2/cache"
        "github.com/zscaler/zscaler-sdk-go/v2/logger"
        rl "github.com/zscaler/zscaler-sdk-go/v2/ratelimiter"
)

const (
        maxIdleConnections    int = 40
        requestTimeout        int = 60
        JSessionIDTimeout         = 30 // minutes.
        jSessionTimeoutOffset     = 5 * time.Minute
        contentTypeJSON           = "application/json"
        cookieName                = "JSESSIONID"
        MaxNumOfRetries           = 100
        RetryWaitMaxSeconds       = 20
        RetryWaitMinSeconds       = 5
        // API types.
        ziaAPIVersion = "api/v1"
        ziaAPIAuthURL = "/authenticatedSession"
        loggerPrefix  = "zia-logger: "
)

// Client ...
type Client struct {
        sync.Mutex
        userName         string
        password         string
        cloud            string
        apiKey           string
        session          *Session
        sessionRefreshed time.Time     // Also indicates last usage
        sessionTimeout   time.Duration // in minutes
        URL              string
        HTTPClient       *http.Client
        Logger           logger.Logger
        UserAgent        string
        freshCache       bool
        cacheEnabled     bool
        cache            cache.Cache
        cacheTtl         time.Duration
        cacheCleanwindow time.Duration
        cacheMaxSizeMB   int
        rateLimiter      *rl.RateLimiter
}

// Session ...
type Session struct {
        AuthType           string `json:"authType"`
        ObfuscateAPIKey    bool   `json:"obfuscateApiKey"`
        PasswordExpiryTime int    `json:"passwordExpiryTime"`
        PasswordExpiryDays int    `json:"passwordExpiryDays"`
        Source             string `json:"source"`
        JSessionID         string `json:"jSessionID,omitempty"`
}

// Credentials ...
type Credentials struct {
        Username  string `json:"username"`
        Password  string `json:"password"`
        APIKey    string `json:"apiKey"`
        TimeStamp string `json:"timestamp"`
}

func obfuscateAPIKey(apiKey, timeStamp string) (string, error) <span class="cov5" title="6">{
        // check min required size
        if len(timeStamp) &lt; 6 || len(apiKey) &lt; 12 </span><span class="cov0" title="0">{
                return "", errors.New("time stamp or api key doesn't have required sizes")
        }</span>

        <span class="cov5" title="6">seed := apiKey

        high := timeStamp[len(timeStamp)-6:]
        highInt, _ := strconv.Atoi(high)
        low := fmt.Sprintf("%06d", highInt&gt;&gt;1)
        key := ""

        for i := 0; i &lt; len(high); i++ </span><span class="cov10" title="36">{
                index, _ := strconv.Atoi((string)(high[i]))
                key += (string)(seed[index])
        }</span>
        <span class="cov5" title="6">for i := 0; i &lt; len(low); i++ </span><span class="cov10" title="36">{
                index, _ := strconv.Atoi((string)(low[i]))
                key += (string)(seed[index+2])
        }</span>

        <span class="cov5" title="6">return key, nil</span>
}

// NewClient Returns a Client from credentials passed as parameters.
func NewClient(username, password, apiKey, ziaCloud, userAgent string) (*Client, error) <span class="cov4" title="4">{
        logger := logger.GetDefaultLogger(loggerPrefix)
        rateLimiter := rl.NewRateLimiter(2, 1, 1, 1)
        httpClient := getHTTPClient(logger, rateLimiter)
        url := fmt.Sprintf("https://zsapi.%s.net/%s", ziaCloud, ziaAPIVersion)
        if ziaCloud == "zspreview" </span><span class="cov1" title="1">{
                url = fmt.Sprintf("https://admin.%s.net/%s", ziaCloud, ziaAPIVersion)
        }</span>
        <span class="cov4" title="4">cacheDisabled, _ := strconv.ParseBool(os.Getenv("ZSCALER_SDK_CACHE_DISABLED"))
        cli := Client{
                userName:         username,
                password:         password,
                apiKey:           apiKey,
                cloud:            ziaCloud,
                HTTPClient:       httpClient,
                URL:              url,
                Logger:           logger,
                UserAgent:        userAgent,
                cacheEnabled:     !cacheDisabled,
                cacheTtl:         time.Minute * 10,
                cacheCleanwindow: time.Minute * 8,
                cacheMaxSizeMB:   0,
                rateLimiter:      rateLimiter,
        }
        cche, err := cache.NewCache(cli.cacheTtl, cli.cacheCleanwindow, cli.cacheMaxSizeMB)
        if err != nil </span><span class="cov0" title="0">{
                cche = cache.NewNopCache()
        }</span>
        <span class="cov4" title="4">cli.cache = cche
        return &amp;cli, nil</span>
}

// MakeAuthRequestZIA authenticates using the provided credentials and returns the session or an error.
func MakeAuthRequestZIA(credentials *Credentials, url string, client *http.Client, userAgent string) (*Session, error) <span class="cov5" title="6">{
        if credentials == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("empty credentials")
        }</span>

        <span class="cov5" title="6">data, err := json.Marshal(credentials)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="6">req, err := http.NewRequest("POST", url+ziaAPIAuthURL, bytes.NewReader(data))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="6">req.Header.Set("Content-Type", contentTypeJSON)
        if userAgent != "" </span><span class="cov0" title="0">{
                req.Header.Add("User-Agent", userAgent)
        }</span>

        <span class="cov5" title="6">resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="6">defer resp.Body.Close()

        // Read the response body for use in error messages
        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response body: %v", err)
        }</span>

        <span class="cov5" title="6">switch resp.StatusCode </span>{
        case http.StatusOK:<span class="cov5" title="6">
                var session Session
                if err = json.Unmarshal(body, &amp;session); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error unmarshalling response: %v", err)
                }</span>
                <span class="cov5" title="6">session.JSessionID, err = extractJSessionIDFromHeaders(resp.Header)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov5" title="6">return &amp;session, nil</span>
        case http.StatusBadRequest:<span class="cov0" title="0">
                return nil, fmt.Errorf("HTTP 400 Bad Request: %s", string(body))</span>
        case http.StatusUnauthorized:<span class="cov0" title="0">
                return nil, fmt.Errorf("HTTP 401 Unauthorized: %s", string(body))</span>
        case http.StatusForbidden:<span class="cov0" title="0">
                return nil, fmt.Errorf("HTTP 403 Forbidden: %s", string(body))</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("HTTP %d: %s", resp.StatusCode, string(body))</span>
        }
}

func extractJSessionIDFromHeaders(header http.Header) (string, error) <span class="cov5" title="6">{
        sessionIdStr := header.Get("Set-Cookie")
        if sessionIdStr == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no Set-Cookie header received")
        }</span>
        <span class="cov5" title="6">regex := regexp.MustCompile("JSESSIONID=(.*?);")
        // look for the first match we find
        result := regex.FindStringSubmatch(sessionIdStr)
        if len(result) &lt; 2 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("couldn't find JSESSIONID in header value")
        }</span>
        <span class="cov5" title="6">return result[1], nil</span>
}

func getCurrentTimestampMilisecond() string <span class="cov5" title="6">{
        return fmt.Sprintf("%d", time.Now().UnixNano()/int64(time.Millisecond))
}</span>

// RefreshSession .. The caller should require lock.
func (c *Client) refreshSession() error <span class="cov5" title="6">{
        timeStamp := getCurrentTimestampMilisecond()
        obfuscatedKey, err := obfuscateAPIKey(c.apiKey, timeStamp)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="6">credentialData := Credentials{
                Username:  c.userName,
                Password:  c.password,
                APIKey:    obfuscatedKey,
                TimeStamp: timeStamp,
        }
        session, err := MakeAuthRequestZIA(&amp;credentialData, c.URL, c.HTTPClient, c.UserAgent)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="6">c.session = session
        c.sessionRefreshed = time.Now()
        // Set a default session timeout if it's not provided
        if c.session.PasswordExpiryTime == -1 </span><span class="cov0" title="0">{
                c.Logger.Printf("[INFO] PasswordExpiryTime is -1, setting sessionTimeout to 1 minute")
                c.sessionTimeout = 30 * time.Minute
        }</span> else<span class="cov5" title="6"> {
                c.Logger.Printf("[INFO] Setting sessionTimeout to %v seconds based on PasswordExpiryTime", c.session.PasswordExpiryTime)
                c.sessionTimeout = time.Duration(c.session.PasswordExpiryTime) * time.Second
        }</span>
        <span class="cov5" title="6">return nil</span>
}

func (c *Client) WithCache(cache bool) <span class="cov0" title="0">{
        c.cacheEnabled = cache
}</span>

func (c *Client) WithCacheTtl(i time.Duration) <span class="cov0" title="0">{
        c.cacheTtl = i
        c.Lock()
        c.cache.Close()
        cche, err := cache.NewCache(i, c.cacheCleanwindow, c.cacheMaxSizeMB)
        if err != nil </span><span class="cov0" title="0">{
                cche = cache.NewNopCache()
        }</span>
        <span class="cov0" title="0">c.cache = cche
        c.Unlock()</span>
}

func (c *Client) WithCacheCleanWindow(i time.Duration) <span class="cov0" title="0">{
        c.cacheCleanwindow = i
        c.Lock()
        c.cache.Close()
        cche, err := cache.NewCache(c.cacheTtl, i, c.cacheMaxSizeMB)
        if err != nil </span><span class="cov0" title="0">{
                cche = cache.NewNopCache()
        }</span>
        <span class="cov0" title="0">c.cache = cche
        c.Unlock()</span>
}

// checkSession synce new session if its over the timeout limit.
func (c *Client) checkSession() error <span class="cov5" title="6">{
        c.Lock()
        defer c.Unlock()

        if c.session == nil </span><span class="cov2" title="2">{
                c.Logger.Printf("[INFO] No session found, refreshing session")
                err := c.refreshSession()
                if err != nil </span><span class="cov0" title="0">{
                        c.Logger.Printf("[ERROR] Failed to get session id: %v\n", err)
                        return err
                }</span>
        } else<span class="cov4" title="4"> {
                now := time.Now()
                c.Logger.Printf("[INFO] Current time: %v\nSession Refreshed: %v\nSession Timeout: %v\n",
                        now.Format("2006-01-02 15:04:05 MST"),
                        c.sessionRefreshed.Format("2006-01-02 15:04:05 MST"),
                        c.sessionTimeout)
                // Refresh if session has expire time (diff than -1) &amp; c.sessionTimeout less than jSessionTimeoutOffset time remaining. You never refresh on exact timeout.
                if c.session.PasswordExpiryTime &gt; 0 &amp;&amp; now.After(c.sessionRefreshed.Add(c.sessionTimeout-jSessionTimeoutOffset)) </span><span class="cov4" title="4">{
                        c.Logger.Printf("[INFO] Session timeout reached, refreshing session")
                        err := c.refreshSession()
                        if err != nil </span><span class="cov0" title="0">{
                                c.Logger.Printf("[ERROR] Failed to refresh session id: %v\n", err)
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        c.Logger.Printf("[INFO] Session is still valid, no need to refresh")
                }</span>
        }

        <span class="cov5" title="6">url, err := url.Parse(c.URL)
        if err != nil </span><span class="cov0" title="0">{
                c.Logger.Printf("[ERROR] Failed to parse url %s: %v\n", c.URL, err)
                return err
        }</span>

        <span class="cov5" title="6">if c.HTTPClient.Jar == nil </span><span class="cov2" title="2">{
                c.HTTPClient.Jar, err = cookiejar.New(nil)
                if err != nil </span><span class="cov0" title="0">{
                        c.Logger.Printf("[ERROR] Failed to create new http cookie jar %v\n", err)
                        return err
                }</span>
        }

        <span class="cov5" title="6">c.HTTPClient.Jar.SetCookies(url, []*http.Cookie{
                {
                        Name:  cookieName,
                        Value: c.session.JSessionID,
                },
        })

        return nil</span>
}

func (c *Client) GetContentType() string <span class="cov3" title="3">{
        return contentTypeJSON
}</span>

func getRetryAfter(resp *http.Response, l logger.Logger) time.Duration <span class="cov0" title="0">{
        if s := resp.Header.Get("Retry-After"); s != "" </span><span class="cov0" title="0">{
                if sleep, err := strconv.ParseInt(s, 10, 64); err == nil </span><span class="cov0" title="0">{
                        l.Printf("[INFO] got Retry-After from header:%s\n", s)
                        return time.Second * time.Duration(sleep)
                }</span> else<span class="cov0" title="0"> {
                        dur, err := time.ParseDuration(s)
                        if err == nil </span><span class="cov0" title="0">{
                                return dur
                        }</span>
                        <span class="cov0" title="0">l.Printf("[INFO] error getting Retry-After from header:%s\n", err)</span>
                }
        }
        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                l.Printf("[INFO] error getting Retry-After from body:%s\n", err)
                return 0
        }</span>
        <span class="cov0" title="0">data := map[string]string{}
        err = json.Unmarshal(body, &amp;data)
        if err != nil </span><span class="cov0" title="0">{
                l.Printf("[INFO] error getting Retry-After from body:%s\n", err)
                return 0
        }</span>
        <span class="cov0" title="0">if retryAfterStr, ok := data["Retry-After"]; ok &amp;&amp; retryAfterStr != "" </span><span class="cov0" title="0">{
                l.Printf("[INFO] got Retry-After from body:%s\n", retryAfterStr)
                secondsStr := strings.Split(retryAfterStr, " ")[0]
                seconds, err := strconv.Atoi(secondsStr)
                if err != nil </span><span class="cov0" title="0">{
                        l.Printf("[INFO] error getting Retry-After from body:%s\n", err)
                        return 0
                }</span>
                <span class="cov0" title="0">return time.Duration(seconds) * time.Second</span>
        }
        <span class="cov0" title="0">return 0</span>
}

func getHTTPClient(l logger.Logger, rateLimiter *rl.RateLimiter) *http.Client <span class="cov4" title="4">{
        retryableClient := retryablehttp.NewClient()
        retryableClient.RetryWaitMin = time.Second * time.Duration(RetryWaitMinSeconds)
        retryableClient.RetryWaitMax = time.Second * time.Duration(RetryWaitMaxSeconds)
        retryableClient.RetryMax = MaxNumOfRetries

        // Set up the cookie jar
        jar, err := cookiejar.New(nil)
        if err != nil </span><span class="cov0" title="0">{
                l.Printf("[ERROR] failed to create cookie jar: %v", err)
                // Handle the error, possibly by continuing without a cookie jar
                // or you can choose to halt the execution if the cookie jar is critical
        }</span>

        // Configure the underlying HTTP client
        <span class="cov4" title="4">retryableClient.HTTPClient = &amp;http.Client{
                Jar: jar, // Set the cookie jar
                // ... other configurations ...
        }

        retryableClient.Backoff = func(min, max time.Duration, attemptNum int, resp *http.Response) time.Duration </span><span class="cov0" title="0">{
                if resp != nil </span><span class="cov0" title="0">{
                        if resp.StatusCode == http.StatusTooManyRequests || resp.StatusCode == http.StatusServiceUnavailable </span><span class="cov0" title="0">{
                                retryAfter := getRetryAfter(resp, l)
                                if retryAfter &gt; 0 </span><span class="cov0" title="0">{
                                        return retryAfter
                                }</span>
                        }
                        <span class="cov0" title="0">if resp.Request != nil </span><span class="cov0" title="0">{
                                wait, d := rateLimiter.Wait(resp.Request.Method)
                                if wait </span><span class="cov0" title="0">{
                                        return d
                                }</span> else<span class="cov0" title="0"> {
                                        return 0
                                }</span>
                        }
                }
                // default to exp backoff
                <span class="cov0" title="0">mult := math.Pow(2, float64(attemptNum)) * float64(min)
                sleep := time.Duration(mult)
                if float64(sleep) != mult || sleep &gt; max </span><span class="cov0" title="0">{
                        sleep = max
                }</span>
                <span class="cov0" title="0">return sleep</span>
        }
        <span class="cov4" title="4">retryableClient.CheckRetry = checkRetry
        retryableClient.Logger = l
        retryableClient.HTTPClient.Timeout = time.Duration(requestTimeout) * time.Second
        retryableClient.HTTPClient.Transport = &amp;http.Transport{
                Proxy:               http.ProxyFromEnvironment,
                MaxIdleConnsPerHost: maxIdleConnections,
        }

        retryableClient.HTTPClient = &amp;http.Client{
                Timeout: time.Duration(requestTimeout) * time.Second,
                Transport: &amp;http.Transport{
                        Proxy:               http.ProxyFromEnvironment,
                        MaxIdleConnsPerHost: maxIdleConnections,
                },
                Jar: jar, // Set the cookie jar
        }
        retryableClient.HTTPClient.Transport = logging.NewSubsystemLoggingHTTPTransport("gozscaler", retryableClient.HTTPClient.Transport)

        retryableClient.CheckRetry = checkRetry
        retryableClient.Logger = l

        return retryableClient.StandardClient()</span>
}

func containsInt(codes []int, code int) bool <span class="cov6" title="9">{
        for _, a := range codes </span><span class="cov6" title="9">{
                if a == code </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov6" title="9">return false</span>
}

// getRetryOnStatusCodes return a list of http status codes we want to apply retry on.
// Return empty slice to enable retry on all connection &amp; server errors.
// Or return []int{429}  to retry on only TooManyRequests error.
func getRetryOnStatusCodes() []int <span class="cov6" title="9">{
        return []int{http.StatusTooManyRequests}
}</span>

type ApiErr struct {
        Code    string `json:"code"`
        Message string `json:"message"`
}

// Used to make http client retry on provided list of response status codes.
func checkRetry(ctx context.Context, resp *http.Response, err error) (bool, error) <span class="cov6" title="9">{
        // do not retry on context.Canceled or context.DeadlineExceeded
        if ctx.Err() != nil </span><span class="cov0" title="0">{
                return false, ctx.Err()
        }</span>
        <span class="cov6" title="9">if resp != nil &amp;&amp; containsInt(getRetryOnStatusCodes(), resp.StatusCode) </span><span class="cov0" title="0">{
                return true, nil
        }</span>

        <span class="cov6" title="9">if resp != nil &amp;&amp; (resp.StatusCode == http.StatusPreconditionFailed || resp.StatusCode == http.StatusConflict || resp.StatusCode == http.StatusUnauthorized) </span><span class="cov0" title="0">{
                apiRespErr := ApiErr{}
                data, err := io.ReadAll(resp.Body)
                resp.Body = io.NopCloser(bytes.NewBuffer(data))
                if err == nil </span><span class="cov0" title="0">{
                        err = json.Unmarshal(data, &amp;apiRespErr)
                        if err == nil </span><span class="cov0" title="0">{
                                if apiRespErr.Code == "UNEXPECTED_ERROR" &amp;&amp; apiRespErr.Message == "Failed during enter Org barrier" ||
                                        apiRespErr.Code == "EDIT_LOCK_NOT_AVAILABLE" || apiRespErr.Message == "Resource Access Blocked" ||
                                        apiRespErr.Code == "UNEXPECTED_ERROR" &amp;&amp; apiRespErr.Message == "Request processing failed, possibly because an expected precondition was not met" </span><span class="cov0" title="0">{
                                        return true, nil
                                }</span>
                        }
                }
        }
        <span class="cov6" title="9">return retryablehttp.DefaultRetryPolicy(ctx, resp, err)</span>
}

func (c *Client) Logout() error <span class="cov0" title="0">{
        _, err := c.Request(ziaAPIAuthURL, "DELETE", nil, "application/json")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c *Client) GetSandboxURL() string <span class="cov3" title="3">{
        return "https://csbapi." + c.cloud + ".net"
}</span>

func (c *Client) GetSandboxToken() string <span class="cov0" title="0">{
        return os.Getenv("ZIA_SANDBOX_TOKEN")
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package zia

import (
        "fmt"
        "io"
        "net/http"
)

type ErrorResponse struct {
        Response *http.Response
        Err      error
        Message  string
}

func (r *ErrorResponse) Error() string <span class="cov0" title="0">{
        if r.Response != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("FAILED: %v, %v, %d, %v, %v, %v", r.Response.Request.Method, r.Response.Request.URL, r.Response.StatusCode, r.Response.Status, r.Message, r.Err)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("FAILED: %v", r.Err)</span>
}

func checkErrorInResponse(res *http.Response, respErr error) error <span class="cov0" title="0">{
        if c := res.StatusCode; c &gt;= 200 &amp;&amp; c &lt;= 299 </span><span class="cov0" title="0">{
                return respErr
        }</span>
        <span class="cov0" title="0">errorResponse := &amp;ErrorResponse{Response: res, Err: respErr}
        errorMessage, err := io.ReadAll(res.Body)
        if err == nil &amp;&amp; len(errorMessage) &gt; 0 </span><span class="cov0" title="0">{
                errorResponse.Message = string(errorMessage)
        }</span>
        <span class="cov0" title="0">return errorResponse</span>
}

// IsObjectNotFound returns true on missing object error (404).
func (r ErrorResponse) IsObjectNotFound() bool <span class="cov0" title="0">{
        return r.Response.StatusCode == 404
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package activation

import (
        "errors"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
)

const (
        activationStatusEndpoint = "/status"
        activationEndpoint       = "/status/activate"
)

type Activation struct {
        Status string `json:"status"`
}

func GetActivationStatus(service *services.Service) (*Activation, error) <span class="cov1" title="1">{
        var activation Activation
        err := service.Client.Read(activationStatusEndpoint, &amp;activation)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return &amp;activation, nil</span>
}

func CreateActivation(service *services.Service, activation Activation) (*Activation, error) <span class="cov10" title="3">{
        resp, err := service.Client.Create(activationEndpoint, activation)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="3">createdActivation, ok := resp.(*Activation)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("object returned from api was not an activation pointer")
        }</span>

        <span class="cov10" title="3">return createdActivation, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package admins

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        adminUsersEndpoint = "/adminUsers"
)

type AdminUsers struct {
        // Admin or auditor's user ID
        ID int `json:"id,omitempty"`

        // Admin or auditor's login name. loginName is in email format and uses the domain name associated to the Zscaler account
        LoginName string `json:"loginName,omitempty"`

        // Admin or auditor's username
        UserName string `json:"userName,omitempty"`

        // Admin or auditor's email address
        Email string `json:"email,omitempty"`

        // Additional information about the admin or auditor
        Comments string `json:"comments,omitempty"`

        // Indicates whether or not the admin account is disabled
        Disabled bool `json:"disabled,omitempty"`

        // The admin's password. If admin single sign-on (SSO) is disabled, then this field is mandatory for POST requests. This information is not provided in a GET response."
        Password string `json:"password,omitempty"`

        PasswordLastModifiedTime int `json:"pwdLastModifiedTime,omitempty"`

        // Indicates whether or not the admin can be edited or deleted
        IsNonEditable bool `json:"isNonEditable,omitempty"`

        // The default is true when SAML Authentication is disabled. When SAML Authentication is enabled, this can be set to false in order to force the admin to login via SSO only.
        IsPasswordLoginAllowed bool `json:"isPasswordLoginAllowed,omitempty"`

        // Indicates whether or not an admin's password has expired
        IsPasswordExpired bool `json:"isPasswordExpired,omitempty"`

        // Indicates whether the user is an auditor. This attribute is subject to change.
        IsAuditor bool `json:"isAuditor,omitempty"`

        // Communication for Security Report is enabled.
        IsSecurityReportCommEnabled bool `json:"isSecurityReportCommEnabled,omitempty"`

        // Communication setting for Service Update
        IsServiceUpdateCommEnabled bool `json:"isServiceUpdateCommEnabled,omitempty"`

        // Communication setting for Product Update
        IsProductUpdateCommEnabled bool `json:"isProductUpdateCommEnabled,omitempty"`

        // Indicates whether or not Executive Insights App access is enabled for the admin
        IsExecMobileAppEnabled bool `json:"isExecMobileAppEnabled,omitempty"`

        // Only applicable for the LOCATION_GROUP admin scope type, in which case this attribute gives the list of ID/name pairs of locations within the location group. The attribute name is subject to change
        AdminScopeGroupMemberEntities []common.IDNameExtensions `json:"adminScopescopeGroupMemberEntities,omitempty"`

        // Based on the admin scope type, the entities can be the ID/name pair of departments, locations, or location groups. The attribute name is subject to change
        AdminScopeEntities []common.IDNameExtensions `json:"adminScopeScopeEntities,omitempty"`

        // The admin's scope. A scope is required for admins, but not applicable to auditors. This attribute is subject to change
        AdminScopeType string `json:"adminScopeType,omitempty"`

        // Role of the admin. This is not required for an auditor
        Role *Role `json:"role,omitempty"`

        // Read-only information about a Executive Insights App token, if it exists
        ExecMobileAppTokens []ExecMobileAppTokens `json:"execMobileAppTokens,omitempty"`
}

type Role struct {
        // Identifier that uniquely identifies an entity
        ID int `json:"id,omitempty"`

        // The configured name of the entity
        Name         string                 `json:"name,omitempty"`
        IsNameL10Tag bool                   `json:"isNameL10nTag,omitempty"`
        Extensions   map[string]interface{} `json:"extensions,omitempty"`
}

type ExecMobileAppTokens struct {
        Cloud       string `json:"cloud,omitempty"`
        OrgId       int    `json:"orgId,omitempty"`
        Name        string `json:"name,omitempty"`
        TokenId     string `json:"tokenId,omitempty"`
        Token       string `json:"token,omitempty"`
        TokenExpiry int    `json:"tokenExpiry,omitempty"`
        CreateTime  int    `json:"createTime,omitempty"`
        DeviceId    string `json:"deviceId,omitempty"`
        DeviceName  string `json:"deviceName,omitempty"`
}

func GetAdminUsers(service *services.Service, adminUserId int) (*AdminUsers, error) <span class="cov7" title="4">{
        v := new(AdminUsers)
        relativeURL := fmt.Sprintf("%s/%d", adminUsersEndpoint, adminUserId)
        err := service.Client.Read(relativeURL, v)
        if err != nil </span><span class="cov4" title="2">{
                return nil, err
        }</span>
        <span class="cov4" title="2">return v, nil</span>
}

func GetAdminUsersByLoginName(service *services.Service, adminUsersLoginName string) (*AdminUsers, error) <span class="cov1" title="1">{
        adminUsers, err := GetAllAdminUsers(service)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">for _, adminUser := range adminUsers </span><span class="cov8" title="6">{
                if strings.EqualFold(adminUser.LoginName, adminUsersLoginName) </span><span class="cov1" title="1">{
                        return &amp;adminUser, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("no admin login found with name: %s", adminUsersLoginName)</span>
}

func GetAdminByUsername(service *services.Service, adminUsername string) (*AdminUsers, error) <span class="cov1" title="1">{
        adminUsers, err := GetAllAdminUsers(service)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">for _, adminUser := range adminUsers </span><span class="cov10" title="8">{
                if strings.EqualFold(adminUser.UserName, adminUsername) </span><span class="cov0" title="0">{
                        return &amp;adminUser, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("no admin found with username: %s", adminUsername)</span>
}

func CreateAdminUser(service *services.Service, adminUser AdminUsers) (*AdminUsers, error) <span class="cov1" title="1">{
        resp, err := service.Client.Create(adminUsersEndpoint, adminUser)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">res, ok := resp.(*AdminUsers)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("couldn't marshal response to a valid objectm: %#v", resp)
        }</span>
        <span class="cov1" title="1">return res, nil</span>
}

func UpdateAdminUser(service *services.Service, adminUserID int, adminUser AdminUsers) (*AdminUsers, error) <span class="cov4" title="2">{
        path := fmt.Sprintf("%s/%d", adminUsersEndpoint, adminUserID)
        resp, err := service.Client.UpdateWithPut(path, adminUser)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">res, _ := resp.(AdminUsers)
        return &amp;res, err</span>
}

func DeleteAdminUser(service *services.Service, adminUserID int) (*http.Response, error) <span class="cov4" title="2">{
        err := service.Client.Delete(fmt.Sprintf("%s/%d", adminUsersEndpoint, adminUserID))
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return nil, nil</span>
}

func GetAllAdminUsers(service *services.Service) ([]AdminUsers, error) <span class="cov5" title="3">{
        var adminUsers []AdminUsers
        err := common.ReadAllPages(service.Client, adminUsersEndpoint+"?includeAuditorUsers=true&amp;includeAdminUsers=true", &amp;adminUsers)
        return adminUsers, err
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package roles

import (
        "fmt"
        "net/url"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
)

const (
        adminRolesEndpoint = "/adminRoles/lite"
)

type AdminRoles struct {
        // Admin role Id
        ID int `json:"id"`

        // Admin rank of this admin role. This is applicable only when admin rank is enabled in the advanced settings. Default value is 7 (the lowest rank). The assigned admin rank determines the roles or admin users this user can manage, and which rule orders this admin can access.
        Rank int `json:"rank,omitempty"`

        // Name of the admin role
        Name string `json:"name,omitempty"`

        // Policy access permission
        PolicyAccess string `json:"policyAccess,omitempty"`

        // Dashboard access permission
        DashboardAccess string `json:"dashboardAccess"`

        // Report access permission
        ReportAccess string `json:"reportAccess,omitempty"`

        // Insights logs access permission
        AnalysisAccess string `json:"analysisAccess,omitempty"`

        // Username access permission. When set to NONE, the username will be obfuscated
        UsernameAccess string `json:"usernameAccess,omitempty"`

        // Admin and role management access permission
        AdminAcctAccess string `json:"adminAcctAccess,omitempty"`

        // Indicates whether this is an auditor role
        IsAuditor bool `json:"isAuditor,omitempty"`

        // List of functional areas to which this role has access. This attribute is subject to change
        Permissions []string `json:"permissions,omitempty"`

        // Indicates whether or not this admin user is editable/deletable
        IsNonEditable bool `json:"isNonEditable,omitempty"`

        // Log range limit
        LogsLimit string `json:"logsLimit,omitempty"`

        // The admin role type. ()This attribute is subject to change.)
        RoleType string `json:"roleType,omitempty"`
}

// func (service *Service) Get(adminRoleId int) (*AdminRoles, error) {
//         v := new(AdminRoles)
//         relativeURL := fmt.Sprintf("%s/%d", adminRolesEndpoint, adminRoleId)
//         err := service.Client.Read(relativeURL, v)
//         if err != nil {
//                 return nil, err
//         }
//         return v, nil
// }

func GetByName(service *services.Service, adminRoleName string) (*AdminRoles, error) <span class="cov7" title="5">{
        var adminRoles []AdminRoles
        err := service.Client.Read(adminRolesEndpoint, &amp;adminRoles)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov7" title="5">for _, adminRole := range adminRoles </span><span class="cov10" title="9">{
                if strings.EqualFold(adminRole.Name, adminRoleName) </span><span class="cov6" title="4">{
                        return &amp;adminRole, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("no admin role found with name: %s", adminRoleName)</span>
}

func GetAPIRole(service *services.Service, apiRole, includeApiRole string) (*AdminRoles, error) <span class="cov1" title="1">{
        var apiRoles []AdminRoles
        err := service.Client.Read(fmt.Sprintf("%s?includeApiRole=%s", adminRolesEndpoint, url.QueryEscape(includeApiRole)), &amp;apiRoles)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">for _, apiRoleEnabled := range apiRoles </span><span class="cov1" title="1">{
                if strings.EqualFold(apiRoleEnabled.Name, apiRole) </span><span class="cov1" title="1">{
                        return &amp;apiRoleEnabled, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("no api role found with name: %s", apiRole)</span>
}

func GetAuditorRole(service *services.Service, auditorRole, includeAuditorRole string) (*AdminRoles, error) <span class="cov1" title="1">{
        var auditorRoles []AdminRoles
        err := service.Client.Read(fmt.Sprintf("%s?includeAuditorRole=%s", adminRolesEndpoint, url.QueryEscape(includeAuditorRole)), &amp;auditorRoles)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">for _, auditorRoleEnabled := range auditorRoles </span><span class="cov1" title="1">{
                if strings.EqualFold(auditorRoleEnabled.Name, auditorRole) </span><span class="cov1" title="1">{
                        return &amp;auditorRoleEnabled, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("no auditor role found with name: %s", auditorRole)</span>
}

func GetPartnerRole(service *services.Service, partnerRole, includePartnerRole string) (*AdminRoles, error) <span class="cov1" title="1">{
        var partnerRoles []AdminRoles
        err := service.Client.Read(fmt.Sprintf("%s?includePartnerRole=%s", adminRolesEndpoint, url.QueryEscape(includePartnerRole)), &amp;partnerRoles)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">for _, partnerRoleEnabled := range partnerRoles </span><span class="cov1" title="1">{
                if strings.EqualFold(partnerRoleEnabled.Name, partnerRole) </span><span class="cov1" title="1">{
                        return &amp;partnerRoleEnabled, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("no partner role found with name: %s", partnerRole)</span>
}

func GetAllAdminRoles(service *services.Service) ([]AdminRoles, error) <span class="cov3" title="2">{
        var adminRoles []AdminRoles
        err := service.Client.Read(adminRolesEndpoint, &amp;adminRoles)
        return adminRoles, err
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package cloudbrowserisolation

import (
        "fmt"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        cbiProfileEndpoint = "/browserIsolation/profiles"
)

type IsolationProfile struct {
        ID string `json:"id,omitempty"`

        // Name of the browser isolation profile
        Name string `json:"name,omitempty"`

        // The browser isolation profile URL
        URL string `json:"url,omitempty"`

        // (Optional) Indicates whether this is a default browser isolation profile. Zscaler sets this field.
        DefaultProfile bool `json:"defaultProfile,omitempty"`
}

// Updated GetByName function
func GetByName(service *services.Service, profileName string) (*IsolationProfile, error) <span class="cov7" title="21">{
        var cbiProfiles []IsolationProfile
        err := common.ReadAllPages(service.Client, cbiProfileEndpoint, &amp;cbiProfiles)
        if err != nil </span><span class="cov0" title="0">{
                return nil, checkNotSubscribedError(err)
        }</span>
        <span class="cov7" title="21">for _, cbi := range cbiProfiles </span><span class="cov10" title="70">{
                if strings.EqualFold(cbi.Name, profileName) </span><span class="cov7" title="19">{
                        return &amp;cbi, nil
                }</span>
        }
        <span class="cov2" title="2">return nil, fmt.Errorf("no cloud browser isolation profile found with name: %s", profileName)</span>
}

// Updated GetAll function
func GetAll(service *services.Service) ([]IsolationProfile, error) <span class="cov2" title="2">{
        var cbiProfiles []IsolationProfile
        err := common.ReadAllPages(service.Client, cbiProfileEndpoint, &amp;cbiProfiles)
        return cbiProfiles, checkNotSubscribedError(err)
}</span>

type NotSubscribedError struct {
        message string
}

func (e *NotSubscribedError) Error() string <span class="cov0" title="0">{
        return e.message
}</span>

// Helper function to check and wrap the "Not Subscribed" error
func checkNotSubscribedError(err error) error <span class="cov2" title="2">{
        if err != nil &amp;&amp; strings.Contains(err.Error(), "Cloud Browser Isolation subscription is required") </span><span class="cov0" title="0">{
                return &amp;NotSubscribedError{message: "NOT_SUBSCRIBED: Cloud Browser Isolation subscription is required"}
        }</span>
        <span class="cov2" title="2">return err</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package common

import (
        "fmt"
        "net/url"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia"
)

const pageSize = 1000

type IDNameExtensions struct {
        ID         int                    `json:"id,omitempty"`
        Name       string                 `json:"name,omitempty"`
        Extensions map[string]interface{} `json:"extensions,omitempty"`
}

type IDExtensions struct {
        ID         int                    `json:"id,omitempty"`
        Extensions map[string]interface{} `json:"extensions,omitempty"`
}

type IDName struct {
        ID   int    `json:"id,omitempty"`
        Name string `json:"name,omitempty"`
}

type IDCustom struct {
        ID int `json:"id,omitempty"`
}

type ZPAAppSegments struct {
        // A unique identifier assigned to the Application Segment
        ID int `json:"id"`

        // The name of the Application Segment
        Name string `json:"name,omitempty"`

        // Indicates the external ID. Applicable only when this reference is of an external entity.
        ExternalID string `json:"externalId"`
}

type UserGroups struct {
        ID       int    `json:"id,omitempty"`
        Name     string `json:"name,omitempty"`
        IdpID    int    `json:"idp_id,omitempty"`
        Comments string `json:"comments,omitempty"`
}

type UserDepartment struct {
        ID       int    `json:"id,omitempty"`
        Name     string `json:"name,omitempty"`
        IdpID    int    `json:"idp_id,omitempty"`
        Comments string `json:"comments,omitempty"`
        Deleted  bool   `json:"deleted,omitempty"`
}

type DeviceGroups struct {
        ID   int    `json:"id,omitempty"`
        Name string `json:"name,omitempty"`
}

type Devices struct {
        ID   int    `json:"id,omitempty"`
        Name string `json:"name,omitempty"`
}

type IDNameWorkloadGroup struct {
        ID   int    `json:"id,omitempty"`
        Name string `json:"name,omitempty"`
}

type DatacenterSearchParameters struct {
        RoutableIP                bool
        WithinCountryOnly         bool
        IncludePrivateServiceEdge bool
        IncludeCurrentVips        bool
        SourceIp                  string
        Latitude                  float64
        Longitude                 float64
        Subcloud                  string
}

type SandboxRSS struct {
        Risk             string `json:"Risk,omitempty"`
        Signature        string `json:"Signature,omitempty"`
        SignatureSources string `json:"SignatureSources,omitempty"`
}

// GetPageSize returns the page size.
func GetPageSize() int <span class="cov1" title="1">{
        return pageSize
}</span>

func ReadAllPages[T any](client *zia.Client, endpoint string, list *[]T) error <span class="cov9" title="253">{
        if list == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov9" title="253">page := 1
        if !strings.Contains(endpoint, "?") </span><span class="cov9" title="177">{
                endpoint += "?"
        }</span>

        <span class="cov9" title="253">for </span><span class="cov10" title="257">{
                pageItems := []T{}
                err := client.Read(fmt.Sprintf("%s&amp;pageSize=%d&amp;page=%d", endpoint, pageSize, page), &amp;pageItems)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov10" title="257">*list = append(*list, pageItems...)
                if len(pageItems) &lt; pageSize </span><span class="cov9" title="253">{
                        break</span>
                }
                <span class="cov3" title="4">page++</span>
        }
        <span class="cov9" title="253">return nil</span>
}

func ReadPage[T any](client *zia.Client, endpoint string, page int, list *[]T) error <span class="cov3" title="5">{
        if list == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Parse the endpoint into a URL.
        <span class="cov3" title="5">u, err := url.Parse(endpoint)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not parse endpoint URL: %w", err)
        }</span>

        // Get the existing query parameters and add new ones.
        <span class="cov3" title="5">q := u.Query()
        q.Set("pageSize", fmt.Sprintf("%d", pageSize))
        q.Set("page", fmt.Sprintf("%d", page))

        // Set the URL's RawQuery to the encoded query parameters.
        u.RawQuery = q.Encode()

        // Convert the URL back to a string and read the page.
        pageItems := []T{}
        err = client.Read(u.String(), &amp;pageItems)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="5">*list = pageItems
        return nil</span>
}

type (
        SortOrder string
        SortField string
)

const (
        ASCSortOrder          SortOrder = "ASC"
        DESCSortOrder                   = "DESC"
        IDSortField           SortField = "id"
        NameSortField                   = "name"
        CreationTimeSortField           = "creationTime"
        ModifiedTimeSortField           = "modifiedTime"
)

func GetSortParams(sortBy SortField, sortOrder SortOrder) string <span class="cov5" title="21">{
        params := ""
        if sortBy != "" </span><span class="cov5" title="21">{
                params = "sortBy=" + string(sortBy)
        }</span>
        <span class="cov5" title="21">if sortOrder != "" </span><span class="cov5" title="21">{
                if params != "" </span><span class="cov5" title="21">{
                        params += "&amp;"
                }</span>
                <span class="cov5" title="21">params += "sortOrder=" + string(sortOrder)</span>
        }
        <span class="cov5" title="21">return params</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package common

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zia"
)

type Service struct {
        Client *zia.Client
}

func New(c *zia.Client) *Service <span class="cov0" title="0">{
        return &amp;Service{Client: c}
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package devicegroups

import (
        "fmt"
        "net/url"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        deviceGroupEndpoint = "/deviceGroups"
        devicesEndpoint     = "/deviceGroups/devices"
)

type DeviceGroups struct {
        // The unique identifer for the device group
        ID int `json:"id"`

        // The device group name
        Name string `json:"name,omitempty"`

        // The device group type
        GroupType string `json:"groupType,omitempty"`

        // The device group's description
        Description string `json:"description,omitempty"`

        // The operating system (OS)
        OSType string `json:"osType,omitempty"`

        // Indicates whether this is a predefined device group. If this value is set to true, the group is predefined
        Predefined  bool   `json:"predefined"`
        DeviceNames string `json:"deviceNames,omitempty"`

        // The number of devices within the group
        DeviceCount int `json:"deviceCount,omitempty"`
}

type Devices struct {
        // The unique identifier for the device
        ID int `json:"id"`

        // The device name
        Name string `json:"name,omitempty"`

        // The device group type
        DeviceGroupType string `json:"deviceGroupType,omitempty"`

        // The device model
        DeviceModel string `json:"deviceModel,omitempty"`

        // The operating system (OS)
        OSType string `json:"osType,omitempty"`

        // The operating system version
        OSVersion string `json:"osVersion,omitempty"`

        // The device's description
        Description string `json:"description,omitempty"`

        // The unique identifier of the device owner (i.e., user)
        OwnerUserId int `json:"ownerUserId,omitempty"`

        // The device owner's user name
        OwnerName string `json:"ownerName,omitempty"`

        // The hostname of the device
        HostName string `json:"hostName,omitempty"`
}

func GetDeviceGroupByName(service *services.Service, deviceGroupName string) (*DeviceGroups, error) <span class="cov7" title="5">{
        var deviceGroups []DeviceGroups
        err := service.Client.Read(deviceGroupEndpoint, &amp;deviceGroups)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov7" title="5">for _, deviceGroup := range deviceGroups </span><span class="cov10" title="11">{
                if strings.EqualFold(deviceGroup.Name, deviceGroupName) </span><span class="cov6" title="4">{
                        return &amp;deviceGroup, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("no device group found with name: %s", deviceGroupName)</span>
}

func GetIncludeDeviceInfo(service *services.Service, includeDeviceInfo, includePseudoGroups bool) ([]DeviceGroups, error) <span class="cov6" title="4">{
        queryParams := url.Values{}
        if includeDeviceInfo </span><span class="cov3" title="2">{
                queryParams.Set("includeDeviceInfo", "true")
        }</span>
        <span class="cov6" title="4">if includePseudoGroups </span><span class="cov3" title="2">{
                queryParams.Set("includePseudoGroups", "true")
        }</span>

        <span class="cov6" title="4">endpoint := fmt.Sprintf("%s?%s", deviceGroupEndpoint, queryParams.Encode())
        var deviceInfos []DeviceGroups
        err := service.Client.Read(endpoint, &amp;deviceInfos)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="4">return deviceInfos, nil</span>
}

func GetAllDevicesGroups(service *services.Service) ([]DeviceGroups, error) <span class="cov5" title="3">{
        var owners []DeviceGroups
        err := common.ReadAllPages(service.Client, deviceGroupEndpoint, &amp;owners)
        return owners, err
}</span>

func GetDevicesByID(service *services.Service, deviceID int) (*Devices, error) <span class="cov1" title="1">{
        devices, err := GetAllDevices(service)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">for _, device := range devices </span><span class="cov1" title="1">{
                if device.ID == deviceID </span><span class="cov1" title="1">{
                        return &amp;device, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("no device found with ID: %d", deviceID)</span>
}

// Get Devices by Name.
func GetDevicesByName(service *services.Service, deviceName string) (*Devices, error) <span class="cov1" title="1">{
        var devices []Devices
        // We are assuming this device name will be in the firsy 1000 obejcts
        err := common.ReadAllPages(service.Client, fmt.Sprintf("%s?page=1&amp;pageSize=1000", devicesEndpoint), &amp;devices)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">for _, device := range devices </span><span class="cov1" title="1">{
                if strings.EqualFold(device.Name, deviceName) </span><span class="cov1" title="1">{
                        return &amp;device, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("no device found with name: %s", deviceName)</span>
}

func GetDevicesByModel(service *services.Service, deviceModel string) (*Devices, error) <span class="cov1" title="1">{
        var models []Devices
        err := common.ReadAllPages(service.Client, fmt.Sprintf("%s?model=%s", devicesEndpoint, url.QueryEscape(deviceModel)), &amp;models)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">for _, model := range models </span><span class="cov1" title="1">{
                if strings.EqualFold(model.DeviceModel, deviceModel) </span><span class="cov1" title="1">{
                        return &amp;model, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("no device found with model: %s", deviceModel)</span>
}

func GetDevicesByOwner(service *services.Service, ownerName string) (*Devices, error) <span class="cov1" title="1">{
        var owners []Devices
        err := common.ReadAllPages(service.Client, fmt.Sprintf("%s?owner=%s", devicesEndpoint, url.QueryEscape(ownerName)), &amp;owners)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">for _, owner := range owners </span><span class="cov1" title="1">{
                if strings.EqualFold(owner.OwnerName, ownerName) </span><span class="cov1" title="1">{
                        return &amp;owner, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("no device found for owner: %s", ownerName)</span>
}

func GetDevicesByOSType(service *services.Service, osTypeName string) (*Devices, error) <span class="cov1" title="1">{
        var osTypes []Devices
        err := common.ReadAllPages(service.Client, fmt.Sprintf("%s?osType=%s", devicesEndpoint, url.QueryEscape(osTypeName)), &amp;osTypes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">for _, osType := range osTypes </span><span class="cov1" title="1">{
                if strings.EqualFold(osType.OSType, osTypeName) </span><span class="cov1" title="1">{
                        return &amp;osType, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("no device found for type: %s", osTypeName)</span>
}

func GetDevicesByOSVersion(service *services.Service, osVersionName string) (*Devices, error) <span class="cov1" title="1">{
        var osVersions []Devices
        err := common.ReadAllPages(service.Client, fmt.Sprintf("%s?osVersion=%s", devicesEndpoint, url.QueryEscape(osVersionName)), &amp;osVersions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">for _, osVersion := range osVersions </span><span class="cov1" title="1">{
                if strings.EqualFold(osVersion.OSVersion, osVersionName) </span><span class="cov1" title="1">{
                        return &amp;osVersion, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("no device found for version: %s", osVersionName)</span>
}

func GetAllDevices(service *services.Service) ([]Devices, error) <span class="cov3" title="2">{
        var owners []Devices
        err := common.ReadAllPages(service.Client, devicesEndpoint, &amp;owners)
        return owners, err
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package dlp_engines

import (
        "errors"
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        dlpEnginesEndpoint    = "/dlpEngines"
        dlpEngineLiteEndpoint = "/dlpEngines/lite"
)

type DLPEngines struct {
        // The unique identifier for the DLP engine.
        ID int `json:"id"`

        // The DLP engine name as configured by the admin. This attribute is required in POST and PUT requests for custom DLP engines.
        Name string `json:"name,omitempty"`

        // The DLP engine's description.
        Description string `json:"description,omitempty"`

        // The name of the predefined DLP engine.
        PredefinedEngineName string `json:"predefinedEngineName,omitempty"`

        // The boolean logical operator in which various DLP dictionaries are combined within a DLP engine's expression.
        EngineExpression string `json:"engineExpression,omitempty"`

        // Indicates whether this is a custom DLP engine. If this value is set to true, the engine is custom.
        CustomDlpEngine bool `json:"customDlpEngine,omitempty"`
}

func Get(service *services.Service, engineID int) (*DLPEngines, error) <span class="cov5" title="5">{
        var dlpEngines DLPEngines
        err := service.Client.Read(fmt.Sprintf("%s/%d", dlpEnginesEndpoint, engineID), &amp;dlpEngines)
        if err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>

        <span class="cov4" title="3">service.Client.Logger.Printf("[DEBUG]Returning dlp engine from Get: %d", dlpEngines.ID)
        return &amp;dlpEngines, nil</span>
}

func GetByName(service *services.Service, engineName string) (*DLPEngines, error) <span class="cov2" title="2">{
        dlpEngines, err := GetAll(service)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov2" title="2">for _, engine := range dlpEngines </span><span class="cov6" title="6">{
                if strings.EqualFold(engine.Name, engineName) </span><span class="cov1" title="1">{
                        return &amp;engine, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("no dlp engine found with name: %s", engineName)</span>
}

func Create(service *services.Service, engineID *DLPEngines) (*DLPEngines, *http.Response, error) <span class="cov1" title="1">{
        resp, err := service.Client.Create(dlpEnginesEndpoint, *engineID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">createdDlpEngine, ok := resp.(*DLPEngines)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, errors.New("object returned from api was not a dlp engine pointer")
        }</span>

        <span class="cov1" title="1">service.Client.Logger.Printf("[DEBUG]returning new dlp engine from create: %d", createdDlpEngine.ID)
        return createdDlpEngine, nil, nil</span>
}

func Update(service *services.Service, engineID int, engines *DLPEngines) (*DLPEngines, *http.Response, error) <span class="cov2" title="2">{
        resp, err := service.Client.UpdateWithPut(fmt.Sprintf("%s/%d", dlpEnginesEndpoint, engineID), *engines)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">updatedDlpEngine, _ := resp.(*DLPEngines)

        service.Client.Logger.Printf("[DEBUG]returning updates dlp engine from update: %d", updatedDlpEngine.ID)
        return updatedDlpEngine, nil, nil</span>
}

func Delete(service *services.Service, engineID int) (*http.Response, error) <span class="cov2" title="2">{
        err := service.Client.Delete(fmt.Sprintf("%s/%d", dlpEnginesEndpoint, engineID))
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return nil, nil</span>
}

func GetAll(service *services.Service) ([]DLPEngines, error) <span class="cov6" title="6">{
        var dlpEngines []DLPEngines
        err := common.ReadAllPages(service.Client, dlpEnginesEndpoint, &amp;dlpEngines)
        return dlpEngines, err
}</span>

// Functions to for DLP Engine Lite query
func GetEngineLiteID(service *services.Service, engineID int) (*DLPEngines, error) <span class="cov1" title="1">{
        dlpEngines, err := GetAllEngineLite(service)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">for _, engine := range dlpEngines </span><span class="cov1" title="1">{
                if engine.ID == engineID </span><span class="cov1" title="1">{
                        return &amp;engine, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("no dlp engine found with ID: %d", engineID)</span>
}

func GetByPredefinedEngine(service *services.Service, engineName string) (*DLPEngines, error) <span class="cov5" title="5">{
        dlpEngines, err := GetAllEngineLite(service)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="5">for _, engine := range dlpEngines </span><span class="cov10" title="25">{
                if strings.EqualFold(engine.PredefinedEngineName, engineName) </span><span class="cov4" title="4">{
                        return &amp;engine, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("no predefined dlp engine found with name: %s", engineName)</span>
}

func GetAllEngineLite(service *services.Service) ([]DLPEngines, error) <span class="cov6" title="7">{
        var engines []DLPEngines
        err := common.ReadAllPages(service.Client, dlpEngineLiteEndpoint, &amp;engines)
        return engines, err
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package dlp_exact_data_match

import (
        "fmt"
        "net/url"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        dlpEDMSchemaEndpoint = "/dlpExactDataMatchSchemas"
)

type DLPEDMSchema struct {
        // The identifier (1-65519) for the EDM schema (i.e., EDM template) that is unique within the organization.
        SchemaID int `json:"schemaId,omitempty"`

        // The unique identifer for the Index Tool that was used to create the EDM template. This attribute is ignored by PUT requests, but required for POST requests.
        EDMClient *common.IDNameExtensions `json:"edmClient,omitempty"`

        // The EDM schema (i.e., EDM template) name. This attribute is ignored by PUT requests, but required for POST requests.
        ProjectName string `json:"projectName,omitempty"`

        // The revision number of the CSV file upload to the Index Tool. This attribute is required by PUT requests.
        Revision int `json:"revision,omitempty"`

        // The generated filename, excluding the extention.
        Filename string `json:"filename,omitempty"`

        // The generated filename, excluding the extention.
        OriginalFileName string `json:"originalFileName,omitempty"`

        // The status of the EDM template's CSV file upload to the Index Tool. This attribute is required by PUT and POST requests.
        FileUploadStatus string `json:"fileUploadStatus,omitempty"`

        // The status of the EDM template's CSV file upload to the Index Tool. This attribute is required by PUT and POST requests.
        SchemaStatus string `json:"schemaStatus,omitempty"`

        // The total count of actual columns selected from the CSV file. This attribute is required by PUT and POST requests.
        OrigColCount int `json:"origColCount,omitempty"`

        // Timestamp when the EDM schema (i.e., EDM template) was last modified. Ignored if the request is PUT, POST, or DELETE.
        LastModifiedTime int `json:"lastModifiedTime,omitempty"`

        // The admin that modified the EDM template's schema last.
        ModifiedBy *common.IDNameExtensions `json:"modifiedBy,omitempty"`

        // The login name (or userid) the admin who created the EDM schema (i.e., EDM template). Ignored if the request is PUT, POST, or DELETE.
        CreatedBy *common.IDNameExtensions `json:"createdBy,omitempty"`

        // The total number of cells used by the EDM schema (i.e., EDM template).
        CellsUsed int `json:"cellsUsed,omitempty"`

        // Indicates the status of a specified EDM schema (i.e., EDM template). If this value is set to true, the schema is active and can be used by DLP dictionaries.
        SchemaActive bool `json:"schemaActive,omitempty"`

        // The total number of cells used by the EDM schema (i.e., EDM template).
        SchedulePresent bool `json:"schedulePresent,omitempty"`

        // Indicates the status of a specified EDM schema (i.e., EDM template). If this value is set to true, the schema is active and can be used by DLP dictionaries.
        TokenList []TokenList `json:"tokenList,omitempty"`

        // The schedule details, if present for the EDM schema (i.e., EDM template). Ignored if the request is PUT, POST, or DELETE.
        Schedule Schedule `json:"schedule,omitempty"`
}

type TokenList struct {
        // The token (i.e., criteria) name. This attribute is required by PUT and POST requests.
        Name string `json:"name,omitempty"`

        // The token (i.e., criteria) name. This attribute is required by PUT and POST requests.
        Type string `json:"type,omitempty"`

        // Indicates whether the token is a primary key.
        PrimaryKey bool `json:"primaryKey,omitempty"`

        // The column position for the token in the original CSV file uploaded to the Index Tool, starting from 1. This attribue required by PUT and POST requests.
        OriginalColumn int `json:"originalColumn,omitempty"`

        // The column position for the token in the hashed file, starting from 1.
        HashfileColumnOrder int `json:"hashfileColumnOrder,omitempty"`

        // The length of the column bitmap in the hashed file.
        ColLengthBitmap int `json:"colLengthBitmap,omitempty"`
}

type Schedule struct {
        // The schedule type for the EDM schema (i.e., EDM template), Monthly, Weekly, Daily, or None. This attribute is required by PUT and POST requests.
        ScheduleType string `json:"scheduleType,omitempty"`

        // The day of the month the EDM schema (i.e., EDM template) is scheduled for. This attribute is required by PUT and POST requests, and if the scheduleType is set to MONTHLY.
        ScheduleDayOfMonth []string `json:"scheduleDayOfMonth,omitempty"`

        // The day of the week the EDM schema (i.e., EDM template) is scheduled for. This attribute is required by PUT and POST requests, and if the scheduleType is set to WEEKLY.
        ScheduleDayOfWeek []string `json:"scheduleDayOfWeek,omitempty"`

        // The time of the day (in minutes) that the EDM schema (i.e., EDM template) is scheduled for. For example: at 3am= 180 mins. This attribute is required by PUT and POST requests.
        ScheduleTime int `json:"scheduleTime,omitempty"`

        // If set to true, the schedule for the EDM schema (i.e., EDM template) is temporarily in a disabled state. This attribute is required by PUT requests in order to disable or enable a schedule.
        ScheduleDisabled bool `json:"scheduleDisabled,omitempty"`
}

func GetDLPEDMSchemaID(service *services.Service, edmSchemaID int) (*DLPEDMSchema, error) <span class="cov1" title="1">{
        var edmSchema DLPEDMSchema
        err := service.Client.Read(fmt.Sprintf("%s/%d", dlpEDMSchemaEndpoint, edmSchemaID), &amp;edmSchema)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">service.Client.Logger.Printf("[DEBUG]returning edm schema from Get: %d", edmSchema.SchemaID)
        return &amp;edmSchema, nil</span>
}

func GetDLPEDMByName(service *services.Service, edmSchemaName string) (*DLPEDMSchema, error) <span class="cov9" title="5">{
        var edmSchema []DLPEDMSchema
        err := common.ReadAllPages(service.Client, fmt.Sprintf("%s?name=%s", dlpEDMSchemaEndpoint, url.QueryEscape(edmSchemaName)), &amp;edmSchema)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov9" title="5">for _, edmSchema := range edmSchema </span><span class="cov10" title="6">{
                if strings.EqualFold(edmSchema.ProjectName, edmSchemaName) </span><span class="cov7" title="4">{
                        return &amp;edmSchema, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("no edm schema found with name: %s", edmSchemaName)</span>
}

func GetAll(service *services.Service) ([]DLPEDMSchema, error) <span class="cov7" title="4">{
        var edmData []DLPEDMSchema
        err := common.ReadAllPages(service.Client, dlpEDMSchemaEndpoint, &amp;edmData)
        return edmData, err
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package dlp_exact_data_match_lite

import (
        "fmt"
        "net/url"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        dlpEDMELiteEndpoint = "/dlpExactDataMatchSchemas/lite"
)

// Gets a list of active EDM templates (or EDM profiles) and their criteria, only.
type DLPEDMLite struct {
        // The identifier (1-65519) for the EDM schema (i.e., EDM template) that is unique within the organization.
        Schema SchemaIDNameExtension `json:"schema,omitempty"`

        // Indicates the status of a specified EDM schema (i.e., EDM template). If this value is set to true, the schema is active and can be used by DLP dictionaries.
        TokenList []TokenList `json:"tokenList,omitempty"`
}

type SchemaIDNameExtension struct {
        // Identifier that uniquely identifies an entity
        ID int `json:"ID,omitempty"`

        // The configured name of the entity
        Name string `json:"name,omitempty"`

        // An external identifier used for an entity that is managed outside of ZIA.
        // Examples include zpaServerGroup and zpaAppSegments.
        // This field is not applicable to ZIA-managed entities.
        ExternalID string `json:"externalId,omitempty"`

        Extensions map[string]interface{} `json:"extensions,omitempty"`
}

type TokenList struct {
        // The token (i.e., criteria) name. This attribute is required by PUT and POST requests.
        Name string `json:"name,omitempty"`

        // The token (i.e., criteria) name. This attribute is required by PUT and POST requests.
        Type string `json:"type,omitempty"`

        // Indicates whether the token is a primary key.
        PrimaryKey bool `json:"primaryKey,omitempty"`

        // The column position for the token in the original CSV file uploaded to the Index Tool, starting from 1. This attribue required by PUT and POST requests.
        OriginalColumn int `json:"originalColumn,omitempty"`

        // The column position for the token in the hashed file, starting from 1.
        HashfileColumnOrder int `json:"hashfileColumnOrder,omitempty"`

        // The length of the column bitmap in the hashed file.
        ColLengthBitmap int `json:"colLengthBitmap,omitempty"`
}

func GetBySchemaName(service *services.Service, schemaName string, activeOnly, fetchTokens bool) ([]DLPEDMLite, error) <span class="cov10" title="9">{
        queryParameters := url.Values{}
        queryParameters.Set("schemaName", schemaName)
        if activeOnly </span><span class="cov6" title="4">{
                queryParameters.Set("activeOnly", "true")
        }</span>
        <span class="cov10" title="9">if fetchTokens </span><span class="cov10" title="9">{
                queryParameters.Set("fetchTokens", "true")
        }</span>

        <span class="cov10" title="9">endpoint := fmt.Sprintf("%s?%s", dlpEDMELiteEndpoint, queryParameters.Encode())
        var edmData []DLPEDMLite
        err := common.ReadAllPages(service.Client, endpoint, &amp;edmData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="9">return edmData, nil</span>
}

func GetAllEDMSchema(service *services.Service, activeOnly, fetchTokens bool) ([]DLPEDMLite, error) <span class="cov8" title="7">{
        queryParameters := url.Values{}
        if activeOnly </span><span class="cov6" title="4">{
                queryParameters.Set("activeOnly", "true")
        }</span>
        <span class="cov8" title="7">if fetchTokens </span><span class="cov8" title="6">{
                queryParameters.Set("fetchTokens", "true")
        }</span>

        <span class="cov8" title="7">endpoint := dlpEDMELiteEndpoint
        if len(queryParameters) &gt; 0 </span><span class="cov8" title="7">{
                endpoint += "?" + queryParameters.Encode()
        }</span>

        <span class="cov8" title="7">var edmData []DLPEDMLite
        err := common.ReadAllPages(service.Client, endpoint, &amp;edmData)
        return edmData, err</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package dlp_icap_servers

import (
        "fmt"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        dlpIcapServersEndpoint = "/icapServers"
)

type DLPICAPServers struct {
        // The unique identifier for a DLP server.
        ID int `json:"id"`

        // The DLP server name.
        Name string `json:"name,omitempty"`

        // The DLP server URL.
        URL string `json:"url,omitempty"`

        // The DLP server status
        Status string `json:"status,omitempty"`
}

func Get(service *services.Service, icapServerID int) (*DLPICAPServers, error) <span class="cov1" title="1">{
        var icapServers DLPICAPServers
        err := service.Client.Read(fmt.Sprintf("%s/%d", dlpIcapServersEndpoint, icapServerID), &amp;icapServers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">service.Client.Logger.Printf("[DEBUG]Returning dlp icap server from Get: %d", icapServers.ID)
        return &amp;icapServers, nil</span>
}

func GetByName(service *services.Service, icapServerName string) (*DLPICAPServers, error) <span class="cov10" title="5">{
        var icapServers []DLPICAPServers
        err := common.ReadAllPages(service.Client, dlpIcapServersEndpoint, &amp;icapServers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="5">for _, icap := range icapServers </span><span class="cov10" title="5">{
                if strings.EqualFold(icap.Name, icapServerName) </span><span class="cov8" title="4">{
                        return &amp;icap, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("no dlp icap server found with name: %s", icapServerName)</span>
}

func GetAll(service *services.Service) ([]DLPICAPServers, error) <span class="cov8" title="4">{
        var icapServers []DLPICAPServers
        err := common.ReadAllPages(service.Client, dlpIcapServersEndpoint, &amp;icapServers)
        return icapServers, err
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package dlp_idm_profile_lite

import (
        "fmt"
        "net/url"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        dlpIDMProfileLiteEndpoint = "/idmprofile/lite"
)

// Gets a list of active IDM templates (or IDM profiles) and their criteria, only.
type DLPIDMProfileLite struct {
        // The identifier (1-64) for the IDM template (i.e., IDM profile) that is unique within the organization.
        ProfileID int `json:"profileId,omitempty"`

        // The IDM template name.
        TemplateName string `json:"templateName,omitempty"`

        // The name of the Index Tool virtual machine (VM) that the IDM template belongs to.
        ClientVM *common.IDNameExtensions `json:"clientVm,omitempty"`

        // The name of the Index Tool virtual machine (VM) that the IDM template belongs to.
        NumDocuments int `json:"numDocuments,omitempty"`

        // The date and time the IDM template was last modified.
        LastModifiedTime int `json:"lastModifiedTime,omitempty"`

        // The admin that modified the IDM template last.
        ModifiedBy *common.IDNameExtensions `json:"modifiedBy,omitempty"`
}

func GetDLPProfileLiteID(service *services.Service, ProfileLiteID int, activeOnly bool) (*DLPIDMProfileLite, error) <span class="cov4" title="2">{
        endpoint := dlpIDMProfileLiteEndpoint
        if activeOnly </span><span class="cov1" title="1">{
                endpoint += "?activeOnly=true"
        }</span> else<span class="cov1" title="1"> {
                endpoint += "?activeOnly=false"
        }</span>

        <span class="cov4" title="2">var profiles []DLPIDMProfileLite
        err := service.Client.Read(endpoint, &amp;profiles)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">for _, profile := range profiles </span><span class="cov4" title="2">{
                if profile.ProfileID == ProfileLiteID </span><span class="cov4" title="2">{
                        service.Client.Logger.Printf("[DEBUG]returning idm profile template from Get: %d", profile.ProfileID)
                        return &amp;profile, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("no DLP profile found with ProfileLiteID: %d", ProfileLiteID)</span>
}

func GetDLPProfileLiteByName(service *services.Service, profileLiteName string, activeOnly bool) (*DLPIDMProfileLite, error) <span class="cov10" title="8">{
        queryParameters := url.Values{}
        queryParameters.Set("name", profileLiteName)
        if activeOnly </span><span class="cov7" title="4">{
                queryParameters.Set("activeOnly", "true")
        }</span>

        <span class="cov10" title="8">endpoint := fmt.Sprintf("%s?%s", dlpIDMProfileLiteEndpoint, queryParameters.Encode())
        var profileLite []DLPIDMProfileLite
        err := common.ReadAllPages(service.Client, endpoint, &amp;profileLite)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="8">for _, profile := range profileLite </span><span class="cov10" title="8">{
                if strings.EqualFold(profile.TemplateName, profileLiteName) </span><span class="cov10" title="8">{
                        return &amp;profile, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("no idm profile template found with name: %s", profileLiteName)</span>
}

func GetAll(service *services.Service, activeOnly bool) ([]DLPIDMProfileLite, error) <span class="cov8" title="6">{
        endpoint := dlpIDMProfileLiteEndpoint
        if activeOnly </span><span class="cov5" title="3">{
                endpoint += "?activeOnly=true"
        }</span>

        <span class="cov8" title="6">var idmpProfile []DLPIDMProfileLite
        err := common.ReadAllPages(service.Client, endpoint, &amp;idmpProfile)
        return idmpProfile, err</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package dlp_idm_profiles

import (
        "fmt"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        dlpIDMProfileEndpoint = "/idmprofile"
)

type DLPIDMProfile struct {
        // The identifier (1-64) for the IDM template (i.e., IDM profile) that is unique within the organization.
        ProfileID int `json:"profileId,omitempty"`

        // The IDM template name, which is unique per Index Tool.
        ProfileName string `json:"profileName,omitempty"`

        // The IDM template's description.
        ProfileDesc string `json:"profileDesc,omitempty"`

        // The IDM template's type. Supported values are: "LOCAL", "REMOTECRON", and "REMOTE"
        ProfileType string `json:"profileType,omitempty"`

        // The fully qualified domain name (FQDN) of the IDM template's host machine.
        Host string `json:"host,omitempty"`

        // The port number of the IDM template's host machine.
        Port int `json:"port,omitempty"`

        // The IDM template's directory file path, where all files are present.
        ProfileDirPath string `json:"profileDirPath,omitempty"`

        // The schedule type for the IDM template's schedule (i.e., Monthly, Weekly, Daily, or None). This attribute is required by PUT and POST requests.
        ScheduleType string `json:"scheduleType,omitempty"`

        // The day the IDM template is scheduled for. This attribute is required by PUT and POST requests.
        ScheduleDay int `json:"scheduleDay,omitempty"`

        // The day of the month that the IDM template is scheduled for. This attribute is required by PUT and POST requests, and when scheduleType is set to MONTHLY.
        ScheduleDayOfMonth []string `json:"scheduleDayOfMonth,omitempty"`

        // The day of the week the IDM template is scheduled for. This attribute is required by PUT and POST requests, and when scheduleType is set to WEEKLY.
        ScheduleDayOfWeek []string `json:"scheduleDayOfWeek,omitempty"`

        // The time of the day (in minutes) that the IDM template is scheduled for. For example: at 3am= 180 mins. This attribute is required by PUT and POST requests.
        ScheduleTime int `json:"scheduleTime,omitempty"`

        // If set to true, the schedule for the IDM template is temporarily in a disabled state. This attribute is required by PUT requests in order to disable or enable a schedule.
        ScheduleDisabled bool `json:"scheduleDisabled,omitempty"`

        // The status of the file uploaded to the Index Tool for the IDM template.
        UploadStatus string `json:"uploadStatus"`

        // The username to be used on the IDM template's host machine.
        UserName string `json:"userName,omitempty"`

        // The version number for the IDM template.
        Version int `json:"version,omitempty"`

        // The unique identifer for the Index Tool that was used to create the IDM template. This attribute is required by POST requests, but ignored if provided in PUT requests.
        IDMClient *common.IDNameExtensions `json:"idmClient,omitempty"`

        // The total volume of all the documents associated to the IDM template.
        VolumeOfDocuments int `json:"volumeOfDocuments,omitempty"`

        // The number of documents associated to the IDM template.
        NumDocuments int `json:"numDocuments,omitempty"`

        // The date and time the IDM template was last modified.
        LastModifiedTime int `json:"lastModifiedTime,omitempty"`

        // The admin that modified the IDM template last.
        ModifiedBy *common.IDNameExtensions `json:"modifiedBy,omitempty"`
}

func Get(service *services.Service, idmProfileID int) (*DLPIDMProfile, error) <span class="cov1" title="1">{
        var idmpProfile DLPIDMProfile
        err := service.Client.Read(fmt.Sprintf("%s/%d", dlpIDMProfileEndpoint, idmProfileID), &amp;idmpProfile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">service.Client.Logger.Printf("[DEBUG]Returning dlp icap server from Get: %d", idmpProfile.ProfileID)
        return &amp;idmpProfile, nil</span>
}

func GetByName(service *services.Service, idmProfileName string) (*DLPIDMProfile, error) <span class="cov10" title="5">{
        var idmpProfile []DLPIDMProfile
        err := common.ReadAllPages(service.Client, dlpIDMProfileEndpoint, &amp;idmpProfile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="5">for _, icap := range idmpProfile </span><span class="cov10" title="5">{
                if strings.EqualFold(icap.ProfileName, idmProfileName) </span><span class="cov8" title="4">{
                        return &amp;icap, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("no dlp icap server found with name: %s", idmProfileName)</span>
}

func GetAll(service *services.Service) ([]DLPIDMProfile, error) <span class="cov7" title="3">{
        var idmpProfile []DLPIDMProfile
        err := common.ReadAllPages(service.Client, dlpIDMProfileEndpoint, &amp;idmpProfile)
        return idmpProfile, err
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package dlp_incident_receiver_servers

import (
        "fmt"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        dlpIncidentReceiverEndpoint = "/incidentReceiverServers"
)

type IncidentReceiverServers struct {
        // The unique identifier for the Incident Receiver.
        ID int `json:"id"`

        // The Incident Receiver server name.
        Name string `json:"name,omitempty"`

        // The Incident Receiver server URL.
        URL string `json:"url,omitempty"`

        // The status of the Incident Receiver.
        Status string `json:"status,omitempty"`

        // The Incident Receiver server flag.
        Flags int `json:"flags,omitempty"`
}

func Get(service *services.Service, receiverID int) (*IncidentReceiverServers, error) <span class="cov1" title="1">{
        var incidentReceiver IncidentReceiverServers
        err := service.Client.Read(fmt.Sprintf("%s/%d", dlpIncidentReceiverEndpoint, receiverID), &amp;incidentReceiver)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">service.Client.Logger.Printf("[DEBUG]Returning dlp incident receiver from Get: %d", incidentReceiver.ID)
        return &amp;incidentReceiver, nil</span>
}

func GetByName(service *services.Service, receiverName string) (*IncidentReceiverServers, error) <span class="cov9" title="5">{
        var incidentReceiver []IncidentReceiverServers
        err := common.ReadAllPages(service.Client, dlpIncidentReceiverEndpoint, &amp;incidentReceiver)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov9" title="5">for _, receiver := range incidentReceiver </span><span class="cov10" title="6">{
                if strings.EqualFold(receiver.Name, receiverName) </span><span class="cov7" title="4">{
                        return &amp;receiver, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("no dlp incident receiver found with name: %s", receiverName)</span>
}

func GetAll(service *services.Service) ([]IncidentReceiverServers, error) <span class="cov7" title="4">{
        var incidentReceiver []IncidentReceiverServers
        err := common.ReadAllPages(service.Client, dlpIncidentReceiverEndpoint, &amp;incidentReceiver)
        return incidentReceiver, err
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package dlp_notification_templates

import (
        "errors"
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        dlpNotificationTemplatesEndpoint = "/dlpNotificationTemplates"
)

type DlpNotificationTemplates struct {
        // The unique identifier for a DLP notification template.
        ID int `json:"id"`

        // The DLP notification template name.
        Name string `json:"name,omitempty"`

        // The Subject line that is displayed within the DLP notification email.
        Subject string `json:"subject,omitempty"`

        // If set to true, the content that is violation is attached to the DLP notification email.
        AttachContent bool `json:"attachContent,omitempty"`

        // The template for the plain text UTF-8 message body that must be displayed in the DLP notification email.
        PlainTextMessage string `json:"plainTextMessage,omitempty"`

        // The template for the HTML message body that must be displayed in the DLP notification email.
        HtmlMessage string `json:"htmlMessage,omitempty"`

        // The template for the HTML message body that must be displayed in the DLP notification email.
        TLSEnabled bool `json:"tlsEnabled,omitempty"`
}

func Get(service *services.Service, dlpTemplateID int) (*DlpNotificationTemplates, error) <span class="cov7" title="5">{
        var dlpTemplates DlpNotificationTemplates
        err := service.Client.Read(fmt.Sprintf("%s/%d", dlpNotificationTemplatesEndpoint, dlpTemplateID), &amp;dlpTemplates)
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>

        <span class="cov5" title="3">service.Client.Logger.Printf("[DEBUG]Returning dlp notification template from Get: %d", dlpTemplates.ID)
        return &amp;dlpTemplates, nil</span>
}

func GetByName(service *services.Service, templateName string) (*DlpNotificationTemplates, error) <span class="cov3" title="2">{
        var dlpTemplates []DlpNotificationTemplates
        err := common.ReadAllPages(service.Client, dlpNotificationTemplatesEndpoint, &amp;dlpTemplates)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="2">for _, template := range dlpTemplates </span><span class="cov10" title="11">{
                if strings.EqualFold(template.Name, templateName) </span><span class="cov1" title="1">{
                        return &amp;template, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("no dictionary found with name: %s", templateName)</span>
}

func Create(service *services.Service, dlpTemplateID *DlpNotificationTemplates) (*DlpNotificationTemplates, *http.Response, error) <span class="cov1" title="1">{
        resp, err := service.Client.Create(dlpNotificationTemplatesEndpoint, *dlpTemplateID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">createdDlpTemplate, ok := resp.(*DlpNotificationTemplates)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, errors.New("object returned from api was not a dlp dictionary pointer")
        }</span>

        <span class="cov1" title="1">service.Client.Logger.Printf("[DEBUG]returning new dlp notification template from create: %d", createdDlpTemplate.ID)
        return createdDlpTemplate, nil, nil</span>
}

func Update(service *services.Service, dlpTemplateID int, dlpTemplates *DlpNotificationTemplates) (*DlpNotificationTemplates, *http.Response, error) <span class="cov3" title="2">{
        resp, err := service.Client.UpdateWithPut(fmt.Sprintf("%s/%d", dlpNotificationTemplatesEndpoint, dlpTemplateID), *dlpTemplates)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">updatedDlpTemplate, _ := resp.(*DlpNotificationTemplates)

        service.Client.Logger.Printf("[DEBUG]returning updates from dlp notification template from update: %d", updatedDlpTemplate.ID)
        return updatedDlpTemplate, nil, nil</span>
}

func Delete(service *services.Service, dlpTemplateID int) (*http.Response, error) <span class="cov3" title="2">{
        err := service.Client.Delete(fmt.Sprintf("%s/%d", dlpNotificationTemplatesEndpoint, dlpTemplateID))
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return nil, nil</span>
}

func GetAll(service *services.Service) ([]DlpNotificationTemplates, error) <span class="cov3" title="2">{
        var dlpTemplates []DlpNotificationTemplates
        err := common.ReadAllPages(service.Client, dlpNotificationTemplatesEndpoint, &amp;dlpTemplates)
        return dlpTemplates, err
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package dlp_web_rules

import (
        "errors"
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        webDlpRulesEndpoint = "/webDlpRules"
)

type WebDLPRules struct {
        // The unique identifier for the DLP policy rule.
        ID int `json:"id,omitempty"`

        // The rule order of execution for the DLP policy rule with respect to other rules.
        Order int `json:"order,omitempty"`
        // The access privilege for this DLP policy rule based on the admin's state.
        AccessControl string `json:"accessControl,omitempty"`

        // The protocol criteria specified for the DLP policy rule.
        Protocols []string `json:"protocols,omitempty"`

        // The admin rank of the admin who created the DLP policy rule.
        Rank int `json:"rank,omitempty"`

        // The DLP policy rule name.
        Name string `json:"name,omitempty"`

        // The description of the DLP policy rule.
        Description string `json:"description,omitempty"`

        // The list of file types to which the DLP policy rule must be applied.
        FileTypes []string `json:"fileTypes,omitempty"`

        // The list of cloud applications to which the DLP policy rule must be applied.
        CloudApplications []string `json:"cloudApplications,omitempty"`

        // The minimum file size (in KB) used for evaluation of the DLP policy rule.
        MinSize int `json:"minSize,omitempty"`

        // The action taken when traffic matches the DLP policy rule criteria.
        Action string `json:"action,omitempty"`

        // Enables or disables the DLP policy rule.
        State string `json:"state,omitempty"`

        // The match only criteria for DLP engines.
        MatchOnly bool `json:"matchOnly,omitempty"`

        // Timestamp when the DLP policy rule was last modified.
        LastModifiedTime int `json:"lastModifiedTime,omitempty"`

        // Indicates a DLP policy rule without content inspection, when the value is set to true.
        WithoutContentInspection bool `json:"withoutContentInspection,omitempty"`

        // Enables or disables image file scanning.
        OcrEnabled bool `json:"ocrEnabled,omitempty"`

        // If this field is set to true, DLP scan is enabled for file downloads from cloud applications configured in the rule.
        // If this field is set to false, DLP scan is disabled for downloads from the cloud applications.
        DLPDownloadScanEnabled bool `json:"dlpDownloadScanEnabled,omitempty"`

        // If this field is set to true, Zscaler Client Connector notification is enabled for the block action triggered by the web DLP rule.
        // If this field is set to false, Zscaler Client Connector notification is disabled.
        ZCCNotificationsEnabled bool `json:"zccNotificationsEnabled,omitempty"`

        // Indicates whether a Zscaler Incident Receiver is associated to the DLP policy rule.
        ZscalerIncidentReceiver bool `json:"zscalerIncidentReceiver,omitempty"`

        // The email address of an external auditor to whom DLP email notifications are sent.
        ExternalAuditorEmail string `json:"externalAuditorEmail,omitempty"`

        // The auditor to which the DLP policy rule must be applied.
        Auditor *common.IDCustom `json:"auditor,omitempty"`

        // The admin that modified the DLP policy rule last.
        LastModifiedBy *common.IDNameExtensions `json:"lastModifiedBy,omitempty"`

        // The template used for DLP notification emails.
        NotificationTemplate *common.IDCustom `json:"notificationTemplate,omitempty"`

        // The DLP server, using ICAP, to which the transaction content is forwarded.
        IcapServer *common.IDCustom `json:"icapServer,omitempty"`

        // The Name-ID pairs of locations to which the DLP policy rule must be applied.
        Locations []common.IDNameExtensions `json:"locations,omitempty"`

        // The Name-ID pairs of locations groups to which the DLP policy rule must be applied.
        LocationGroups []common.IDNameExtensions `json:"locationGroups,omitempty"`

        // The Name-ID pairs of groups to which the DLP policy rule must be applied.
        Groups []common.IDNameExtensions `json:"groups,omitempty"`

        // The Name-ID pairs of departments to which the DLP policy rule must be applied.
        Departments []common.IDNameExtensions `json:"departments,omitempty"`

        // The Name-ID pairs of users to which the DLP policy rule must be applied.
        Users []common.IDNameExtensions `json:"users,omitempty"`

        // The list of URL categories to which the DLP policy rule must be applied.
        URLCategories []common.IDNameExtensions `json:"urlCategories,omitempty"`

        // The list of DLP engines to which the DLP policy rule must be applied.
        DLPEngines []common.IDNameExtensions `json:"dlpEngines,omitempty"`

        // The Name-ID pairs of time windows to which the DLP policy rule must be applied.
        TimeWindows []common.IDNameExtensions `json:"timeWindows,omitempty"`

        // The Name-ID pairs of rule labels associated to the DLP policy rule.
        Labels []common.IDNameExtensions `json:"labels,omitempty"`

        // The name-ID pairs of the groups that are excluded from the DLP policy rule.
        ExcludedGroups []common.IDNameExtensions `json:"excludedGroups,omitempty"`

        // The name-ID pairs of the departments that are excluded from the DLP policy rule.
        ExcludedDepartments []common.IDNameExtensions `json:"excludedDepartments,omitempty"`

        // The name-ID pairs of the users that are excluded from the DLP policy rule.
        ExcludedUsers []common.IDNameExtensions `json:"excludedUsers,omitempty"`

        // The list of domain profiles that must be added to the DLP rule criteria in order to apply the DLP rules only to domains that are part of the specified profiles. A maximum of 8 profiles can be selected.
        IncludedDomainProfiles []common.IDNameExtensions `json:"includedDomainProfiles,omitempty"`

        // The list of domain profiles that must be added to the DLP rule criteria in order to apply the DLP rules to all domains excluding the domains that are part of the specified profiles. A maximum of 8 profiles can be selected.
        ExcludedDomainProfiles []common.IDNameExtensions `json:"excludedDomainProfiles,omitempty"`

        // Source IP address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address group.
        SourceIpGroups []common.IDNameExtensions `json:"sourceIpGroups,omitempty"`

        // The list of preconfigured workload groups to which the policy must be applied.
        WorkloadGroups []common.IDName `json:"workloadGroups,omitempty"`

        // Indicates the severity selected for the DLP rule violation
        Severity string `json:"severity,omitempty"`

        // The unique identifier of the parent rule under which an exception rule is added.
        // Note: Exception rules can be configured only when the inline DLP rule evaluation type is set to evaluate all DLP rules in the DLP Advanced Settings.
        ParentRule int `json:"parentRule,omitempty"`

        // The list of exception rules added to a parent rule.
        // All attributes within the WebDlpRule model are applicable to the sub-rules.
        // Values for each rule are specified by using the WebDlpRule object.
        SubRules []SubRule `json:"subRules,omitempty"`

        UserRiskScoreLevels []string `json:"userRiskScoreLevels,omitempty"`
}

type SubRule struct {
        ID int `json:"id,omitempty"`
}

func Get(service *services.Service, ruleID int) (*WebDLPRules, error) <span class="cov10" title="5">{
        var webDlpRules WebDLPRules
        err := service.Client.Read(fmt.Sprintf("%s/%d", webDlpRulesEndpoint, ruleID), &amp;webDlpRules)
        if err != nil </span><span class="cov4" title="2">{
                return nil, err
        }</span>

        <span class="cov7" title="3">service.Client.Logger.Printf("[DEBUG]Returning web dlp rule from Get: %d", webDlpRules.ID)
        return &amp;webDlpRules, nil</span>
}

func GetByName(service *services.Service, ruleName string) (*WebDLPRules, error) <span class="cov4" title="2">{
        var webDlpRules []WebDLPRules
        err := common.ReadAllPages(service.Client, webDlpRulesEndpoint, &amp;webDlpRules)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="2">for _, rule := range webDlpRules </span><span class="cov1" title="1">{
                if strings.EqualFold(rule.Name, ruleName) </span><span class="cov1" title="1">{
                        return &amp;rule, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("no web dlp rule found with name: %s", ruleName)</span>
}

func Create(service *services.Service, ruleID *WebDLPRules) (*WebDLPRules, error) <span class="cov1" title="1">{
        resp, err := service.Client.Create(webDlpRulesEndpoint, *ruleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">createdWebDlpRules, ok := resp.(*WebDLPRules)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("object returned from api was not a web dlp rule pointer")
        }</span>

        <span class="cov1" title="1">service.Client.Logger.Printf("[DEBUG]returning new web dlp rule from create: %d", createdWebDlpRules.ID)
        return createdWebDlpRules, nil</span>
}

func Update(service *services.Service, ruleID int, webDlpRules *WebDLPRules) (*WebDLPRules, error) <span class="cov4" title="2">{
        resp, err := service.Client.UpdateWithPut(fmt.Sprintf("%s/%d", webDlpRulesEndpoint, ruleID), *webDlpRules)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">updatedWebDlpRules, _ := resp.(*WebDLPRules)

        service.Client.Logger.Printf("[DEBUG]returning updates from web dlp rule from update: %d", updatedWebDlpRules.ID)
        return updatedWebDlpRules, nil</span>
}

func Delete(service *services.Service, ruleID int) (*http.Response, error) <span class="cov4" title="2">{
        err := service.Client.Delete(fmt.Sprintf("%s/%d", webDlpRulesEndpoint, ruleID))
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return nil, nil</span>
}

func GetAll(service *services.Service) ([]WebDLPRules, error) <span class="cov1" title="1">{
        var webDlpRules []WebDLPRules
        err := common.ReadAllPages(service.Client, webDlpRulesEndpoint, &amp;webDlpRules)
        return webDlpRules, err
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package dlpdictionaries

import (
        "errors"
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        dlpDictionariesEndpoint    = "/dlpDictionaries"
        validateDLPPatternEndpoint = "/dlpDictionaries/validateDlpPattern"
)

type DlpDictionary struct {
        // Unique identifier for the DLP dictionary
        ID int `json:"id"`

        // The DLP dictionary's name
        Name string `json:"name,omitempty"`

        // The description of the DLP dictionary
        Description string `json:"description,omitempty"`

        // The DLP confidence threshold
        ConfidenceThreshold string `json:"confidenceThreshold,omitempty"`

        // The DLP custom phrase match type
        CustomPhraseMatchType string `json:"customPhraseMatchType,omitempty"`

        // Indicates whether the name is localized or not. This is always set to True for predefined DLP dictionaries.
        NameL10nTag bool `json:"nameL10nTag"`

        // This value is set to true for custom DLP dictionaries.
        Custom bool `json:"custom"`

        // DLP threshold type
        ThresholdType string `json:"thresholdType,omitempty"`

        // The DLP dictionary type
        DictionaryType string `json:"dictionaryType,omitempty"`

        // The DLP dictionary proximity length.
        Proximity int `json:"proximity,omitempty"`

        // List containing the phrases used within a custom DLP dictionary. This attribute is not applicable to predefined DLP dictionaries.
        Phrases []Phrases `json:"phrases"`

        // List containing the patterns used within a custom DLP dictionary. This attribute is not applicable to predefined DLP dictionaries
        Patterns []Patterns `json:"patterns"`

        // Exact Data Match (EDM) related information for custom DLP dictionaries.
        EDMMatchDetails []EDMMatchDetails `json:"exactDataMatchDetails"`

        // List of Indexed Document Match (IDM) profiles and their corresponding match accuracy for custom DLP dictionaries.
        IDMProfileMatchAccuracy []IDMProfileMatchAccuracy `json:"idmProfileMatchAccuracyDetails"`

        // Indicates whether to exclude documents that are a 100% match to already-indexed documents from triggering an Indexed Document Match (IDM) Dictionary.
        IgnoreExactMatchIdmDict bool `json:"ignoreExactMatchIdmDict,omitempty"`

        // A true value denotes that the specified Bank Identification Number (BIN) values are included in the Credit Cards dictionary. A false value denotes that the specified BIN values are excluded from the Credit Cards dictionary.
        // Note: This field is applicable only to the predefined Credit Cards dictionary and its clones.
        IncludeBinNumbers bool `json:"includeBinNumbers,omitempty"`

        // The list of Bank Identification Number (BIN) values that are included or excluded from the Credit Cards dictionary. BIN values can be specified only for Diners Club, Mastercard, RuPay, and Visa cards. Up to 512 BIN values can be configured in a dictionary.
        // Note: This field is applicable only to the predefined Credit Cards dictionary and its clones.
        BinNumbers []int `json:"binNumbers,omitempty"`

        // ID of the predefined dictionary (original source dictionary) that is used for cloning. This field is applicable only to cloned dictionaries. Only a limited set of identification-based predefined dictionaries (e.g., Credit Cards, Social Security Numbers, National Identification Numbers, etc.) can be cloned. Up to 4 clones can be created from a predefined dictionary.
        DictTemplateId int `json:"dictTemplateId,omitempty"`

        // This field is set to true if the dictionary is cloned from a predefined dictionary. Otherwise, it is set to false.
        PredefinedClone bool `json:"predefinedClone,omitempty"`

        // This value is set to true if proximity length and high confidence phrases are enabled for the DLP dictionary.
        ProximityLengthEnabled bool `json:"proximityLengthEnabled,omitempty"`
}

type Phrases struct {
        // The action applied to a DLP dictionary using phrases
        Action string `json:"action,omitempty"`

        // DLP dictionary phrase
        Phrase string `json:"phrase,omitempty"`
}

type Patterns struct {
        // The action applied to a DLP dictionary using patterns
        Action string `json:"action,omitempty"`

        // DLP dictionary pattern
        Pattern string `json:"pattern,omitempty"`
}

type EDMMatchDetails struct {
        // The unique identifier for the EDM mapping.
        DictionaryEdmMappingID int `json:"dictionaryEdmMappingId,omitempty"`

        // The unique identifier for the EDM template (or schema).
        SchemaID int `json:"schemaId,omitempty"`

        // The EDM template's primary field.
        PrimaryField int `json:"primaryField,omitempty"`

        // The EDM template's secondary fields.
        SecondaryFields []int `json:"secondaryFields,omitempty"`

        // The EDM secondary field to match on.
        SecondaryFieldMatchOn string `json:"secondaryFieldMatchOn,omitempty"`
}

type IDMProfileMatchAccuracy struct {
        // The IDM template reference.
        AdpIdmProfile *common.IDNameExtensions `json:"adpIdmProfile,omitempty"`

        // The IDM template match accuracy.
        MatchAccuracy string `json:"matchAccuracy,omitempty"`
}

func Get(service *services.Service, dlpDictionariesID int) (*DlpDictionary, error) <span class="cov3" title="4">{
        var dlpDictionary DlpDictionary
        err := service.Client.Read(fmt.Sprintf("%s/%d", dlpDictionariesEndpoint, dlpDictionariesID), &amp;dlpDictionary)
        if err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>

        <span class="cov2" title="2">service.Client.Logger.Printf("[DEBUG]Returning dictionary from Get: %d", dlpDictionary.ID)
        return &amp;dlpDictionary, nil</span>
}

func GetByName(service *services.Service, dictionaryName string) (*DlpDictionary, error) <span class="cov2" title="2">{
        var dictionaries []DlpDictionary
        err := common.ReadAllPages(service.Client, dlpDictionariesEndpoint, &amp;dictionaries)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov2" title="2">for _, dictionary := range dictionaries </span><span class="cov10" title="98">{
                if strings.EqualFold(dictionary.Name, dictionaryName) </span><span class="cov1" title="1">{
                        return &amp;dictionary, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("no dictionary found with name: %s", dictionaryName)</span>
}

func Create(service *services.Service, dlpDictionariesID *DlpDictionary) (*DlpDictionary, *http.Response, error) <span class="cov1" title="1">{
        resp, err := service.Client.Create(dlpDictionariesEndpoint, *dlpDictionariesID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">createdDlpDictionary, ok := resp.(*DlpDictionary)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, errors.New("object returned from api was not a dlp dictionary pointer")
        }</span>

        <span class="cov1" title="1">service.Client.Logger.Printf("[DEBUG]returning new custom dlp dictionary that uses patterns and phrases from create: %d", createdDlpDictionary.ID)
        return createdDlpDictionary, nil, nil</span>
}

func Update(service *services.Service, dlpDictionariesID int, dlpDictionaries *DlpDictionary) (*DlpDictionary, *http.Response, error) <span class="cov2" title="2">{
        resp, err := service.Client.UpdateWithPut(fmt.Sprintf("%s/%d", dlpDictionariesEndpoint, dlpDictionariesID), *dlpDictionaries)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">updatedDlpDictionary, _ := resp.(*DlpDictionary)

        service.Client.Logger.Printf("[DEBUG]returning updates custom dlp dictionary that uses patterns and phrases from ppdate: %d", updatedDlpDictionary.ID)
        return updatedDlpDictionary, nil, nil</span>
}

func DeleteDlpDictionary(service *services.Service, dlpDictionariesID int) (*http.Response, error) <span class="cov2" title="2">{
        err := service.Client.Delete(fmt.Sprintf("%s/%d", dlpDictionariesEndpoint, dlpDictionariesID))
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return nil, nil</span>
}

func GetAll(service *services.Service) ([]DlpDictionary, error) <span class="cov1" title="1">{
        var dictionaries []DlpDictionary
        err := common.ReadAllPages(service.Client, dlpDictionariesEndpoint, &amp;dictionaries)
        return dictionaries, err
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package eventlogentryreport

import (
        "errors"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
)

const (
        eventlogEntryReportEndpoint = "/eventlogEntryReport"
)

type EventLogEntryReportTaskInfo struct {
        // Status of running task
        Status string `json:"status,omitempty"`

        // Number of items processed
        ProgressItemsComplete int `json:"progressItemsComplete,omitempty"`

        // End time
        ProgressEndTime int `json:"progressEndTime,omitempty"`

        // Error message
        ErrorMessage string `json:"errorMessage,omitempty"`
        ErrorCode    string `json:"errorCode,omitempty"`
}

type EventLogEntryReport struct {
        // The start time in the time range used to generate the event log report
        StartTime int `json:"startTime,omitempty"`

        // The end time in the time range used to generate the event log report
        EndTime  int    `json:"endTime,omitempty"`
        Page     int    `json:"page,omitempty"`
        PageSize string `json:"pageSize,omitempty"`

        // Filters the list based on the category for which the events were recorded.
        Category string `json:"category,omitempty"`

        // Filters the list based on areas within a category where the events were recorded
        Subcategories []string `json:"subcategories,omitempty"`

        // Filters the list based on the outcome (i.e., Failure or Success) of the events recorded
        ActionResult string `json:"actionResult,omitempty"`

        // The search string used to match against the event log message
        Message string `json:"message,omitempty"`

        // The search string used to match against the error code in event log entries
        ErrorCode string `json:"errorCode,omitempty"`

        // The search string used to match against the status code in event log entries
        StatusCode string `json:"statusCode,omitempty"`
}

func GetAll(service *services.Service) ([]EventLogEntryReportTaskInfo, error) <span class="cov0" title="0">{
        var eventLogEntryReport []EventLogEntryReportTaskInfo
        err := service.Client.Read(eventlogEntryReportEndpoint, &amp;eventLogEntryReport)
        return eventLogEntryReport, err
}</span>

func Create(service *services.Service, eventLog *EventLogEntryReport) (*EventLogEntryReport, error) <span class="cov0" title="0">{
        resp, err := service.Client.Create(eventlogEntryReportEndpoint, eventLog)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">createdEventLogReport, ok := resp.(*EventLogEntryReport)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("object returned from api was not an event log entry report pointer")
        }</span>

        <span class="cov0" title="0">service.Client.Logger.Printf("[DEBUG]returning event log entry report from create: %d", createdEventLogReport)
        return createdEventLogReport, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package applicationservices

import (
        "fmt"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        appServicesLiteEndpoint = "/appServices/lite"
)

type ApplicationServicesLite struct {
        ID          int    `json:"id"`
        Name        string `json:"name,omitempty"`
        NameL10nTag bool   `json:"nameL10nTag"`
}

func GetByName(service *services.Service, serviceName string) (*ApplicationServicesLite, error) <span class="cov6" title="5">{
        var appServicesLite []ApplicationServicesLite
        err := common.ReadAllPages(service.Client, appServicesLiteEndpoint, &amp;appServicesLite)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="5">for _, appServicesLite := range appServicesLite </span><span class="cov10" title="17">{
                if strings.EqualFold(appServicesLite.Name, serviceName) </span><span class="cov5" title="4">{
                        return &amp;appServicesLite, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("no application services found with name: %s", serviceName)</span>
}

func GetAll(service *services.Service) ([]ApplicationServicesLite, error) <span class="cov3" title="2">{
        var appServices []ApplicationServicesLite
        err := common.ReadAllPages(service.Client, appServicesLiteEndpoint, &amp;appServices)
        return appServices, err
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package appservicegroups

import (
        "fmt"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        appServicesGroupLiteEndpoint = "/appServiceGroups/lite"
)

type ApplicationServicesGroupLite struct {
        ID          int    `json:"id"`
        Name        string `json:"name,omitempty"`
        NameL10nTag bool   `json:"nameL10nTag"`
}

func GetByName(service *services.Service, serviceGroupName string) (*ApplicationServicesGroupLite, error) <span class="cov6" title="5">{
        var appServicesGroupLite []ApplicationServicesGroupLite
        err := common.ReadAllPages(service.Client, appServicesGroupLiteEndpoint, &amp;appServicesGroupLite)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="5">for _, appServicesGroupLite := range appServicesGroupLite </span><span class="cov10" title="12">{
                if strings.EqualFold(appServicesGroupLite.Name, serviceGroupName) </span><span class="cov6" title="4">{
                        return &amp;appServicesGroupLite, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("no app services group found with name: %s", serviceGroupName)</span>
}

func GetAll(service *services.Service) ([]ApplicationServicesGroupLite, error) <span class="cov3" title="2">{
        var appServiceGroups []ApplicationServicesGroupLite
        err := common.ReadAllPages(service.Client, appServicesGroupLiteEndpoint, &amp;appServiceGroups)
        return appServiceGroups, err
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package filteringrules

import (
        "errors"
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        firewallRulesEndpoint = "/firewallFilteringRules"
)

type FirewallFilteringRules struct {
        // Unique identifier for the Firewall Filtering policy rule
        ID int `json:"id,omitempty"`

        // Name of the Firewall Filtering policy rule
        Name string `json:"name,omitempty"`

        // Rule order number of the Firewall Filtering policy rule
        Order int `json:"order"`

        // Admin rank of the Firewall Filtering policy rule
        Rank              int    `json:"rank"`
        AccessControl     string `json:"accessControl,omitempty"`
        EnableFullLogging bool   `json:"enableFullLogging"`

        // The action the Firewall Filtering policy rule takes when packets match the rule
        Action string `json:"action,omitempty"`

        // Determines whether the Firewall Filtering policy rule is enabled or disabled
        State string `json:"state,omitempty"`

        // Additional information about the rule
        Description string `json:"description,omitempty"`

        // Timestamp when the rule was last modified. Ignored if the request is POST or PUT. For GET, ignored if or the rule is current version.
        LastModifiedTime int                      `json:"lastModifiedTime,omitempty"`
        LastModifiedBy   *common.IDNameExtensions `json:"lastModifiedBy,omitempty"`

        // User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address.
        SrcIps []string `json:"srcIps,omitempty"`

        // List of destination IP addresses for which the rule is applicable. CIDR notation can be used for destination IP addresses. If not set, the rule is not restricted to a specific destination addresses unless specified by destCountries, destIpGroups or destIpCategories.
        DestAddresses []string `json:"destAddresses,omitempty"`

        // IP address categories of destination for which the DNAT rule is applicable. If not set, the rule is not restricted to specific destination IP categories.
        DestIpCategories []string `json:"destIpCategories,omitempty"`

        // Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
        DestCountries []string `json:"destCountries,omitempty"`

        // Indicates whether the countries specified in the sourceCountries field are included or excluded from the rule.
        // A true value denotes that the specified source countries are excluded from the rule.
        // A false value denotes that the rule is applied to the source countries if there is a match.
        ExcludeSrcCountries bool `json:"excludeSrcCountries,omitempty"`

        // User-defined network service applications on which the rule is applied. If not set, the rule is not restricted to a specific network service application.
        NwApplications []string `json:"nwApplications,omitempty"`

        // If set to true, the default rule is applied
        DefaultRule bool `json:"defaultRule"`

        // If set to true, a predefined rule is applied
        Predefined bool `json:"predefined"`

        // The locations to which the Firewall Filtering policy rule applies
        Locations []common.IDNameExtensions `json:"locations,omitempty"`

        // The location groups to which the Firewall Filtering policy rule applies
        LocationsGroups []common.IDNameExtensions `json:"locationGroups,omitempty"`

        // The departments to which the Firewall Filtering policy rule applies
        Departments []common.IDNameExtensions `json:"departments,omitempty"`

        // The groups to which the Firewall Filtering policy rule applies
        Groups []common.IDNameExtensions `json:"groups,omitempty"`

        // The users to which the Firewall Filtering policy rule applies
        Users []common.IDNameExtensions `json:"users,omitempty"`

        // The time interval in which the Firewall Filtering policy rule applies
        TimeWindows []common.IDNameExtensions `json:"timeWindows,omitempty"`

        // User-defined network service application group on which the rule is applied. If not set, the rule is not restricted to a specific network service application group.
        NwApplicationGroups []common.IDNameExtensions `json:"nwApplicationGroups,omitempty"`

        // Application services on which this rule is applied
        AppServices []common.IDNameExtensions `json:"appServices,omitempty"`

        // Application service groups on which this rule is applied
        AppServiceGroups []common.IDNameExtensions `json:"appServiceGroups,omitempty"`

        // Labels that are applicable to the rule.
        Labels []common.IDNameExtensions `json:"labels,omitempty"`

        // User-defined destination IP address groups on which the rule is applied. If not set, the rule is not restricted to a specific destination IP address group.
        // Note: For organizations that have enabled IPv6, the destIpv6Groups field lists the IPv6 source address groups for which the rule is applicable.
        DestIpGroups []common.IDNameExtensions `json:"destIpGroups,omitempty"`

        // User-defined network services on which the rule is applied. If not set, the rule is not restricted to a specific network service.
        NwServices []common.IDNameExtensions `json:"nwServices,omitempty"`

        // User-defined network service applications on which the rule is applied. If not set, the rule is not restricted to a specific network service application.
        NwServiceGroups []common.IDNameExtensions `json:"nwServiceGroups,omitempty"`

        // Source IP address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address group.
        SrcIpGroups []common.IDNameExtensions `json:"srcIpGroups,omitempty"`

        // List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
        DeviceTrustLevels []string `json:"deviceTrustLevels,omitempty"`

        // This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
        DeviceGroups []common.IDNameExtensions `json:"deviceGroups"`

        // Name-ID pairs of devices for which rule must be applied. Specifies devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
        Devices []common.IDNameExtensions `json:"devices"`

        // The list of preconfigured workload groups to which the policy must be applied.
        WorkloadGroups []common.IDName `json:"workloadGroups,omitempty"`

        // The list of ZPA Application Segments for which this rule is applicable. This field is applicable only for the ZPA Gateway forwarding method.
        ZPAAppSegments []common.ZPAAppSegments `json:"zpaAppSegments"`
}

func Get(service *services.Service, ruleID int) (*FirewallFilteringRules, error) <span class="cov9" title="5">{
        var rule FirewallFilteringRules
        err := service.Client.Read(fmt.Sprintf("%s/%d", firewallRulesEndpoint, ruleID), &amp;rule)
        if err != nil </span><span class="cov4" title="2">{
                return nil, err
        }</span>

        <span class="cov6" title="3">service.Client.Logger.Printf("[DEBUG]Returning firewall rule from Get: %d", rule.ID)
        return &amp;rule, nil</span>
}

func GetByName(service *services.Service, ruleName string) (*FirewallFilteringRules, error) <span class="cov4" title="2">{
        var rules []FirewallFilteringRules
        err := common.ReadAllPages(service.Client, firewallRulesEndpoint, &amp;rules)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="2">for _, rule := range rules </span><span class="cov10" title="6">{
                if strings.EqualFold(rule.Name, ruleName) </span><span class="cov1" title="1">{
                        return &amp;rule, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("no firewall rule found with name: %s", ruleName)</span>
}

func Create(service *services.Service, rule *FirewallFilteringRules) (*FirewallFilteringRules, error) <span class="cov1" title="1">{
        resp, err := service.Client.Create(firewallRulesEndpoint, *rule)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">createdRules, ok := resp.(*FirewallFilteringRules)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("object returned from api was not a rule Pointer")
        }</span>

        <span class="cov1" title="1">service.Client.Logger.Printf("[DEBUG]returning rule from create: %d", createdRules.ID)
        return createdRules, nil</span>
}

func Update(service *services.Service, ruleID int, rules *FirewallFilteringRules) (*FirewallFilteringRules, error) <span class="cov4" title="2">{
        resp, err := service.Client.UpdateWithPut(fmt.Sprintf("%s/%d", firewallRulesEndpoint, ruleID), *rules)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">updatedRules, _ := resp.(*FirewallFilteringRules)
        service.Client.Logger.Printf("[DEBUG]returning firewall rule from update: %d", updatedRules.ID)
        return updatedRules, nil</span>
}

func Delete(service *services.Service, ruleID int) (*http.Response, error) <span class="cov4" title="2">{
        err := service.Client.Delete(fmt.Sprintf("%s/%d", firewallRulesEndpoint, ruleID))
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return nil, nil</span>
}

func GetAll(service *services.Service) ([]FirewallFilteringRules, error) <span class="cov1" title="1">{
        var rules []FirewallFilteringRules
        err := common.ReadAllPages(service.Client, firewallRulesEndpoint, &amp;rules)
        return rules, err
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package ipdestinationgroups

import (
        "errors"
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        ipDestinationGroupsEndpoint = "/ipDestinationGroups"
)

type IPDestinationGroups struct {
        // Unique identifer for the destination IP group
        ID int `json:"id"`

        // Destination IP group name
        Name string `json:"name,omitempty"`

        // Additional information about the destination IP group
        Description string `json:"description,omitempty"`

        // Destination IP group type (i.e., the group can contain destination IP addresses or FQDNs)
        Type string `json:"type,omitempty"`

        // Destination IP addresses, FQDNs, or wildcard FQDNs added to the group.
        Addresses []string `json:"addresses,omitempty"`

        // Destination IP address URL categories. You can identify destinations based on the URL category of the domain.
        IPCategories []string `json:"ipCategories,omitempty"`

        // Destination IP address countries. You can identify destinations based on the location of a server.
        Countries []string `json:"countries,omitempty"`

        // If set to true, the destination IP address group is non-editable. This field is applicable only to predefined IP address groups, which cannot be modified.
        IsNonEditable bool `json:"isNonEditable,omitempty"`
}

func Get(service *services.Service, ipGroupID int) (*IPDestinationGroups, error) <span class="cov10" title="4">{
        var ipDestinationGroups IPDestinationGroups
        err := service.Client.Read(fmt.Sprintf("%s/%d", ipDestinationGroupsEndpoint, ipGroupID), &amp;ipDestinationGroups)
        if err != nil </span><span class="cov5" title="2">{
                return nil, err
        }</span>

        <span class="cov5" title="2">service.Client.Logger.Printf("[DEBUG]Returning ip destination group from Get: %d", ipDestinationGroups.ID)
        return &amp;ipDestinationGroups, nil</span>
}

func GetByName(service *services.Service, ipDestinationGroupsName string) (*IPDestinationGroups, error) <span class="cov5" title="2">{
        var ipDestinationGroups []IPDestinationGroups
        err := common.ReadAllPages(service.Client, ipDestinationGroupsEndpoint, &amp;ipDestinationGroups)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="2">for _, ipDestinationGroup := range ipDestinationGroups </span><span class="cov1" title="1">{
                if strings.EqualFold(ipDestinationGroup.Name, ipDestinationGroupsName) </span><span class="cov1" title="1">{
                        return &amp;ipDestinationGroup, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("no ip destination group found with name: %s", ipDestinationGroupsName)</span>
}

func Create(service *services.Service, ipGroupID *IPDestinationGroups) (*IPDestinationGroups, error) <span class="cov1" title="1">{
        resp, err := service.Client.Create(ipDestinationGroupsEndpoint, *ipGroupID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">createdIPDestinationGroups, ok := resp.(*IPDestinationGroups)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("object returned from api was not an ip destination group pointer")
        }</span>

        <span class="cov1" title="1">service.Client.Logger.Printf("[DEBUG]returning ip destination group from create: %d", createdIPDestinationGroups.ID)
        return createdIPDestinationGroups, nil</span>
}

func Update(service *services.Service, ipGroupID int, ipGroup *IPDestinationGroups) (*IPDestinationGroups, *http.Response, error) <span class="cov5" title="2">{
        resp, err := service.Client.UpdateWithPut(fmt.Sprintf("%s/%d", ipDestinationGroupsEndpoint, ipGroupID), *ipGroup)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">updatedIPDestinationGroups, _ := resp.(*IPDestinationGroups)

        service.Client.Logger.Printf("[DEBUG]returning ip destination group from update: %d", updatedIPDestinationGroups.ID)
        return updatedIPDestinationGroups, nil, nil</span>
}

func Delete(service *services.Service, ipGroupID int) (*http.Response, error) <span class="cov5" title="2">{
        err := service.Client.Delete(fmt.Sprintf("%s/%d", ipDestinationGroupsEndpoint, ipGroupID))
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return nil, nil</span>
}

func GetAll(service *services.Service) ([]IPDestinationGroups, error) <span class="cov1" title="1">{
        var ipDestinationGroups []IPDestinationGroups
        err := common.ReadAllPages(service.Client, ipDestinationGroupsEndpoint, &amp;ipDestinationGroups)
        return ipDestinationGroups, err
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package ipsourcegroups

import (
        "errors"
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        ipSourceGroupsEndpoint = "/ipSourceGroups"
)

type IPSourceGroups struct {
        // A unique identifier of the source IP address group.
        ID int `json:"id"`

        // The name of the source IP address group.
        Name string `json:"name,omitempty"`

        // The description of the source IP address group.
        Description string `json:"description,omitempty"`

        // Source IP addresses added to the group.
        IPAddresses []string `json:"ipAddresses,omitempty"`

        // If set to true, the destination IP address group is non-editable. This field is applicable only to predefined IP address groups, which cannot be modified.
        IsNonEditable bool `json:"isNonEditable,omitempty"`
}

func Get(service *services.Service, ipGroupID int) (*IPSourceGroups, error) <span class="cov10" title="4">{
        var ipSourceGroups IPSourceGroups
        err := service.Client.Read(fmt.Sprintf("%s/%d", ipSourceGroupsEndpoint, ipGroupID), &amp;ipSourceGroups)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="3">service.Client.Logger.Printf("[DEBUG]Returning ip source groupfrom Get: %d", ipSourceGroups.ID)
        return &amp;ipSourceGroups, nil</span>
}

func GetByName(service *services.Service, ipSourceGroupsName string) (*IPSourceGroups, error) <span class="cov5" title="2">{
        var ipSourceGroups []IPSourceGroups
        err := common.ReadAllPages(service.Client, ipSourceGroupsEndpoint, &amp;ipSourceGroups)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="2">for _, ipSourceGroup := range ipSourceGroups </span><span class="cov1" title="1">{
                if strings.EqualFold(ipSourceGroup.Name, ipSourceGroupsName) </span><span class="cov1" title="1">{
                        return &amp;ipSourceGroup, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("no ip source group found with name: %s", ipSourceGroupsName)</span>
}

func Create(service *services.Service, ipGroupID *IPSourceGroups) (*IPSourceGroups, error) <span class="cov1" title="1">{
        resp, err := service.Client.Create(ipSourceGroupsEndpoint, *ipGroupID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">createdIPSourceGroups, ok := resp.(*IPSourceGroups)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("object returned from api was not an ip source group pointer")
        }</span>

        <span class="cov1" title="1">service.Client.Logger.Printf("[DEBUG]returning ip source group from create: %d", createdIPSourceGroups.ID)
        return createdIPSourceGroups, nil</span>
}

func Update(service *services.Service, ipGroupID int, ipGroup *IPSourceGroups) (*IPSourceGroups, error) <span class="cov5" title="2">{
        resp, err := service.Client.UpdateWithPut(fmt.Sprintf("%s/%d", ipSourceGroupsEndpoint, ipGroupID), *ipGroup)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">updatedIPSourceGroups, _ := resp.(*IPSourceGroups)

        service.Client.Logger.Printf("[DEBUG]returning ip source group from update: %d", updatedIPSourceGroups.ID)
        return updatedIPSourceGroups, nil</span>
}

func Delete(service *services.Service, ipGroupID int) (*http.Response, error) <span class="cov5" title="2">{
        err := service.Client.Delete(fmt.Sprintf("%s/%d", ipSourceGroupsEndpoint, ipGroupID))
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return nil, nil</span>
}

func GetAll(service *services.Service) ([]IPSourceGroups, error) <span class="cov1" title="1">{
        var ipSourceGroups []IPSourceGroups
        err := common.ReadAllPages(service.Client, ipSourceGroupsEndpoint, &amp;ipSourceGroups)
        return ipSourceGroups, err
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package networkapplicationgroups

import (
        "errors"
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        networkAppGroupsEndpoint = "/networkApplicationGroups"
)

type NetworkApplicationGroups struct {
        ID                  int      `json:"id"`
        Name                string   `json:"name,omitempty"`
        NetworkApplications []string `json:"networkApplications,omitempty"`
        Description         string   `json:"description,omitempty"`
}

func GetNetworkApplicationGroups(service *services.Service, groupID int) (*NetworkApplicationGroups, error) <span class="cov6" title="4">{
        var networkApplicationGroups NetworkApplicationGroups
        err := service.Client.Read(fmt.Sprintf("%s/%d", networkAppGroupsEndpoint, groupID), &amp;networkApplicationGroups)
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>

        <span class="cov3" title="2">service.Client.Logger.Printf("[DEBUG]Returning network application groups from Get: %d", networkApplicationGroups.ID)
        return &amp;networkApplicationGroups, nil</span>
}

func GetNetworkApplicationGroupsByName(service *services.Service, appGroupsName string) (*NetworkApplicationGroups, error) <span class="cov3" title="2">{
        var networkApplicationGroups []NetworkApplicationGroups
        err := common.ReadAllPages(service.Client, networkAppGroupsEndpoint, &amp;networkApplicationGroups)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="2">for _, networkAppGroup := range networkApplicationGroups </span><span class="cov10" title="9">{
                if strings.EqualFold(networkAppGroup.Name, appGroupsName) </span><span class="cov1" title="1">{
                        return &amp;networkAppGroup, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("no network application groups found with name: %s", appGroupsName)</span>
}

func Create(service *services.Service, applicationGroup *NetworkApplicationGroups) (*NetworkApplicationGroups, error) <span class="cov1" title="1">{
        resp, err := service.Client.Create(networkAppGroupsEndpoint, *applicationGroup)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">createdApplicationGroups, ok := resp.(*NetworkApplicationGroups)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("object returned from api was not a network application groups pointer")
        }</span>

        <span class="cov1" title="1">service.Client.Logger.Printf("[DEBUG]returning network application groups from create: %d", createdApplicationGroups.ID)
        return createdApplicationGroups, nil</span>
}

func Update(service *services.Service, groupID int, applicationGroup *NetworkApplicationGroups) (*NetworkApplicationGroups, *http.Response, error) <span class="cov3" title="2">{
        resp, err := service.Client.UpdateWithPut(fmt.Sprintf("%s/%d", networkAppGroupsEndpoint, groupID), *applicationGroup)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">updatedApplicationGroups, _ := resp.(*NetworkApplicationGroups)

        service.Client.Logger.Printf("[DEBUG]returning network application groups from Update: %d", updatedApplicationGroups.ID)
        return updatedApplicationGroups, nil, nil</span>
}

func Delete(service *services.Service, groupID int) (*http.Response, error) <span class="cov3" title="2">{
        err := service.Client.Delete(fmt.Sprintf("%s/%d", networkAppGroupsEndpoint, groupID))
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return nil, nil</span>
}

func GetAllNetworkApplicationGroups(service *services.Service) ([]NetworkApplicationGroups, error) <span class="cov1" title="1">{
        var networkApplicationGroups []NetworkApplicationGroups
        err := common.ReadAllPages(service.Client, networkAppGroupsEndpoint, &amp;networkApplicationGroups)
        return networkApplicationGroups, err
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package networkapplications

import (
        "fmt"
        "net/url"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        networkApplicationsEndpoint = "/networkApplications"
)

type NetworkApplications struct {
        ID             string `json:"id"`
        ParentCategory string `json:"parentCategory,omitempty"`
        Description    string `json:"description,omitempty"`
        Deprecated     bool   `json:"deprecated"`
}

func GetNetworkApplication(service *services.Service, id, locale string) (*NetworkApplications, error) <span class="cov10" title="2">{
        var networkApplications NetworkApplications
        url := fmt.Sprintf("%s/%s", networkApplicationsEndpoint, id)
        if locale != "" </span><span class="cov10" title="2">{
                url = fmt.Sprintf("%s?locale=%s", url, locale)
        }</span>
        <span class="cov10" title="2">err := service.Client.Read(url, &amp;networkApplications)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return &amp;networkApplications, nil</span>
}

func GetByName(service *services.Service, nwApplicationName, locale string) (*NetworkApplications, error) <span class="cov1" title="1">{
        var networkApplications []NetworkApplications

        // Construct the URL with search and locale query parameters
        url := fmt.Sprintf("%s?search=%s&amp;locale=%s", networkApplicationsEndpoint, url.QueryEscape(nwApplicationName), url.QueryEscape(locale))

        err := service.Client.Read(url, &amp;networkApplications)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // It's assumed that the API will return filtered results based on the search parameter.
        // Therefore, we should check if at least one result is returned.
        <span class="cov1" title="1">if len(networkApplications) &gt; 0 </span><span class="cov1" title="1">{
                return &amp;networkApplications[0], nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("no network application found with name: %s", nwApplicationName)</span>
}

func GetAll(service *services.Service, locale string) ([]NetworkApplications, error) <span class="cov0" title="0">{
        var networkApplications []NetworkApplications
        endpoint := networkApplicationsEndpoint
        if locale != "" </span><span class="cov0" title="0">{
                // Properly escape the locale string and append it as a query parameter
                endpoint = fmt.Sprintf("%s?locale=%s", networkApplicationsEndpoint, url.QueryEscape(locale))
        }</span>
        <span class="cov0" title="0">err := common.ReadAllPages(service.Client, endpoint, &amp;networkApplications)
        return networkApplications, err</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package networkservicegroups

import (
        "errors"
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/firewallpolicies/networkservices"
)

const (
        networkServiceGroupsEndpoint = "/networkServiceGroups"
)

type NetworkServiceGroups struct {
        ID          int        `json:"id"`
        Name        string     `json:"name,omitempty"`
        Services    []Services `json:"services,omitempty"`
        Description string     `json:"description,omitempty"`
}

type Services struct {
        ID            int                            `json:"id"`
        Name          string                         `json:"name,omitempty"`
        Tag           string                         `json:"tag,omitempty"`
        SrcTCPPorts   []networkservices.NetworkPorts `json:"srcTcpPorts,omitempty"`
        DestTCPPorts  []networkservices.NetworkPorts `json:"destTcpPorts,omitempty"`
        SrcUDPPorts   []networkservices.NetworkPorts `json:"srcUdpPorts,omitempty"`
        DestUDPPorts  []networkservices.NetworkPorts `json:"destUdpPorts,omitempty"`
        Type          string                         `json:"type,omitempty"`
        Description   string                         `json:"description,omitempty"`
        IsNameL10nTag bool                           `json:"isNameL10nTag,omitempty"`
}

func GetNetworkServiceGroups(service *services.Service, serviceGroupID int) (*NetworkServiceGroups, error) <span class="cov10" title="4">{
        var networkServiceGroups NetworkServiceGroups
        err := service.Client.Read(fmt.Sprintf("%s/%d", networkServiceGroupsEndpoint, serviceGroupID), &amp;networkServiceGroups)
        if err != nil </span><span class="cov5" title="2">{
                return nil, err
        }</span>

        <span class="cov5" title="2">service.Client.Logger.Printf("[DEBUG]Returning network service groups from Get: %d", networkServiceGroups.ID)
        return &amp;networkServiceGroups, nil</span>
}

func GetNetworkServiceGroupsByName(service *services.Service, serviceGroupsName string) (*NetworkServiceGroups, error) <span class="cov5" title="2">{
        var networkServiceGroups []NetworkServiceGroups
        err := common.ReadAllPages(service.Client, networkServiceGroupsEndpoint, &amp;networkServiceGroups)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="2">for _, networkServiceGroup := range networkServiceGroups </span><span class="cov8" title="3">{
                if strings.EqualFold(networkServiceGroup.Name, serviceGroupsName) </span><span class="cov1" title="1">{
                        return &amp;networkServiceGroup, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("no network service groups found with name: %s", serviceGroupsName)</span>
}

func CreateNetworkServiceGroups(service *services.Service, networkServiceGroups *NetworkServiceGroups) (*NetworkServiceGroups, error) <span class="cov1" title="1">{
        resp, err := service.Client.Create(networkServiceGroupsEndpoint, *networkServiceGroups)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">createdNetworkServiceGroups, ok := resp.(*NetworkServiceGroups)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("object returned from api was not a network service groups pointer")
        }</span>

        <span class="cov1" title="1">service.Client.Logger.Printf("[DEBUG]returning network service groups from create: %d", createdNetworkServiceGroups.ID)
        return createdNetworkServiceGroups, nil</span>
}

func UpdateNetworkServiceGroups(service *services.Service, serviceGroupID int, networkServiceGroups *NetworkServiceGroups) (*NetworkServiceGroups, *http.Response, error) <span class="cov5" title="2">{
        resp, err := service.Client.UpdateWithPut(fmt.Sprintf("%s/%d", networkServiceGroupsEndpoint, serviceGroupID), *networkServiceGroups)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">updatedNetworkServiceGroups, _ := resp.(*NetworkServiceGroups)

        service.Client.Logger.Printf("[DEBUG]returning network service groups from Update: %d", updatedNetworkServiceGroups.ID)
        return updatedNetworkServiceGroups, nil, nil</span>
}

func DeleteNetworkServiceGroups(service *services.Service, serviceGroupID int) (*http.Response, error) <span class="cov5" title="2">{
        err := service.Client.Delete(fmt.Sprintf("%s/%d", networkServiceGroupsEndpoint, serviceGroupID))
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return nil, nil</span>
}

func GetAllNetworkServiceGroups(service *services.Service) ([]NetworkServiceGroups, error) <span class="cov1" title="1">{
        var networkServiceGroups []NetworkServiceGroups
        err := common.ReadAllPages(service.Client, networkServiceGroupsEndpoint, &amp;networkServiceGroups)
        return networkServiceGroups, err
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package networkservices

import (
        "errors"
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        networkServicesEndpoint = "/networkServices"
)

type NetworkServices struct {
        ID            int            `json:"id"`
        Name          string         `json:"name,omitempty"`
        Tag           string         `json:"tag,omitempty"`
        SrcTCPPorts   []NetworkPorts `json:"srcTcpPorts,omitempty"`
        DestTCPPorts  []NetworkPorts `json:"destTcpPorts,omitempty"`
        SrcUDPPorts   []NetworkPorts `json:"srcUdpPorts,omitempty"`
        DestUDPPorts  []NetworkPorts `json:"destUdpPorts,omitempty"`
        Type          string         `json:"type,omitempty"`
        Description   string         `json:"description,omitempty"`
        Protocol      string         `json:"protocol,omitempty"`
        IsNameL10nTag bool           `json:"isNameL10nTag,omitempty"`
}

type NetworkPorts struct {
        Start int `json:"start,omitempty"`
        End   int `json:"end,omitempty"`
}

func Get(service *services.Service, serviceID int) (*NetworkServices, error) <span class="cov3" title="4">{
        var networkServices NetworkServices
        err := service.Client.Read(fmt.Sprintf("%s/%d", networkServicesEndpoint, serviceID), &amp;networkServices)
        if err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>

        <span class="cov2" title="2">service.Client.Logger.Printf("[DEBUG]Returning network services from Get: %d", networkServices.ID)
        return &amp;networkServices, nil</span>
}

func GetByName(service *services.Service, networkServiceName string) (*NetworkServices, error) <span class="cov2" title="2">{
        var networkServices []NetworkServices
        err := common.ReadAllPages(service.Client, networkServicesEndpoint, &amp;networkServices)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov2" title="2">for _, networkService := range networkServices </span><span class="cov10" title="125">{
                if strings.EqualFold(networkService.Name, networkServiceName) </span><span class="cov1" title="1">{
                        return &amp;networkService, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("no network services found with name: %s", networkServiceName)</span>
}

func Create(service *services.Service, networkService *NetworkServices) (*NetworkServices, error) <span class="cov1" title="1">{
        resp, err := service.Client.Create(networkServicesEndpoint, *networkService)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">createdNetworkServices, ok := resp.(*NetworkServices)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("object returned from api was not a network service pointer")
        }</span>

        <span class="cov1" title="1">service.Client.Logger.Printf("[DEBUG]returning network service from create: %d", createdNetworkServices.ID)
        return createdNetworkServices, nil</span>
}

func Update(service *services.Service, serviceID int, networkService *NetworkServices) (*NetworkServices, *http.Response, error) <span class="cov2" title="2">{
        resp, err := service.Client.UpdateWithPut(fmt.Sprintf("%s/%d", networkServicesEndpoint, serviceID), *networkService)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">updatedNetworkServices, _ := resp.(*NetworkServices)

        service.Client.Logger.Printf("[DEBUG]returning network service from Update: %d", updatedNetworkServices.ID)
        return updatedNetworkServices, nil, nil</span>
}

func Delete(service *services.Service, serviceID int) (*http.Response, error) <span class="cov2" title="2">{
        err := service.Client.Delete(fmt.Sprintf("%s/%d", networkServicesEndpoint, serviceID))
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return nil, nil</span>
}

func GetAllNetworkServices(service *services.Service) ([]NetworkServices, error) <span class="cov1" title="1">{
        var networkServices []NetworkServices
        err := common.ReadAllPages(service.Client, networkServicesEndpoint, &amp;networkServices)
        return networkServices, err
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package timewindow

import (
        "fmt"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        timeWindowEndpoint = "/timeWindows"
)

type TimeWindow struct {
        ID        int      `json:"id"`
        Name      string   `json:"name,omitempty"`
        StartTime int32    `json:"startTime,omitempty"`
        EndTime   int32    `json:"endTime,omitempty"`
        DayOfWeek []string `json:"dayOfWeek,omitempty"`
}

func GetTimeWindowByName(service *services.Service, timeWindowName string) (*TimeWindow, error) <span class="cov7" title="5">{
        var timeWindow []TimeWindow
        err := common.ReadAllPages(service.Client, timeWindowEndpoint, &amp;timeWindow)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov7" title="5">for _, timeWindow := range timeWindow </span><span class="cov10" title="10">{
                if strings.EqualFold(timeWindow.Name, timeWindowName) </span><span class="cov6" title="4">{
                        return &amp;timeWindow, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("no time window found with name: %s", timeWindowName)</span>
}

func GetAll(service *services.Service) ([]TimeWindow, error) <span class="cov3" title="2">{
        var timeWindow []TimeWindow
        err := common.ReadAllPages(service.Client, timeWindowEndpoint, &amp;timeWindow)
        return timeWindow, err
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package forwarding_rules

import (
        "errors"
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        forwardingRulesEndpoint = "/forwardingRules"
)

type ForwardingRules struct {
        // A unique identifier assigned to the forwarding rule
        ID int `json:"id,omitempty"`

        // The name of the forwarding rule
        Name string `json:"name,omitempty"`

        // Additional information about the forwarding rule
        Description string `json:"description,omitempty"`

        // The rule type selected from the available options
        // Supported Values: "FIREWALL", "DNS", "DNAT", "SNAT", "FORWARDING", "INTRUSION_PREVENTION", "EC_DNS", "EC_RDR", "EC_SELF", "DNS_RESPONSE"
        Type string `json:"type,omitempty"`

        // The order of execution for the forwarding rule order
        Order int `json:"order"`

        // Admin rank assigned to the forwarding rule
        Rank int `json:"rank"`

        // Name-ID pairs of the locations to which the forwarding rule applies. If not set, the rule is applied to all locations.
        Locations []common.IDNameExtensions `json:"locations,omitempty"`

        // Name-ID pairs of the location groups to which the forwarding rule applies
        LocationsGroups []common.IDNameExtensions `json:"locationGroups,omitempty"`

        // Name-ID pairs of the Zscaler Cloud Connector groups to which the forwarding rule applies
        ECGroups []common.IDNameExtensions `json:"ecGroups,omitempty"`

        // Name-ID pairs of the departments to which the forwarding rule applies. If not set, the rule applies to all departments.
        Departments []common.IDNameExtensions `json:"departments,omitempty"`

        // Name-ID pairs of the user groups to which the forwarding rule applies. If not set, the rule applies to all groups.
        Groups []common.IDNameExtensions `json:"groups,omitempty"`

        // Name-ID pairs of the users to which the forwarding rule applies. If not set, user criteria is ignored during policy enforcement.
        Users []common.IDNameExtensions `json:"users,omitempty"`

        // The type of traffic forwarding method selected from the available options
        // Supported Values: "INVALID", "DIRECT", "PROXYCHAIN", "ZIA", "ZPA", "ECZPA", "ECSELF", "DROP"
        ForwardMethod string `json:"forwardMethod,omitempty"`

        // Indicates whether the forwarding rule is enabled or disabled
        // Supported Values: DISABLED and ENABLED
        State string `json:"state,omitempty"`

        // Timestamp when the rule was last modified. This field is not applicable for POST or PUT request.
        LastModifiedTime int `json:"lastModifiedTime,omitempty"`

        // Admin user that last modified the rule. This field is not applicable for POST or PUT request.
        LastModifiedBy *common.IDNameExtensions `json:"lastModifiedBy,omitempty"`

        // User-defined source IP addresses for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address.
        SrcIps []string `json:"srcIps,omitempty"`

        // Source IP address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address group.
        // Note: For organizations that have enabled IPv6, the srcIpv6Groups field lists the IPv6 source address groups for which the rule is applicable.
        SrcIpGroups []common.IDNameExtensions `json:"srcIpGroups,omitempty"`

        // Source IP address groups for which the rule is applicable. If not set, the rule is not restricted to a specific source IP address group.
        // Note: For organizations that have enabled IPv6, the srcIpv6Groups field lists the IPv6 source address groups for which the rule is applicable.
        SrcIpv6Groups []common.IDNameExtensions `json:"srcIpv6Groups,omitempty"`

        // List of destination IP addresses or FQDNs for which the rule is applicable. CIDR notation can be used for destination IP addresses.
        //  If not set, the rule is not restricted to a specific destination addresses unless specified by destCountries, destIpGroups, or destIpCategories.
        DestAddresses []string `json:"destAddresses,omitempty"`

        // List of destination IP categories to which the rule applies. If not set, the rule is not restricted to specific destination IP categories.
        DestIpCategories []string `json:"destIpCategories,omitempty"`

        // List of destination IP categories to which the rule applies. If not set, the rule is not restricted to specific destination IP categories.
        ResCategories []string `json:"resCategories,omitempty"`

        // Destination countries for which the rule is applicable. If not set, the rule is not restricted to specific destination countries.
        DestCountries []string `json:"destCountries,omitempty"`

        // User-defined destination IP address groups to which the rule is applied.
        // If not set, the rule is not restricted to a specific destination IP address group.
        DestIpGroups []common.IDNameExtensions `json:"destIpGroups,omitempty"`

        // Destination IPv6 address groups for which the rule is applicable.
        // If not set, the rule is not restricted to a specific source IPv6 address group.
        DestIpv6Groups []common.IDNameExtensions `json:"destIpv6Groups,omitempty"`

        // User-defined network services to which the rule applies. If not set, the rule is not restricted to a specific network service.
        // Note: When the forwarding method is Proxy Chaining, only TCP-based network services are considered for policy match .
        NwServices []common.IDNameExtensions `json:"nwServices,omitempty"`

        // User-defined network service group to which the rule applies.
        // If not set, the rule is not restricted to a specific network service group.
        NwServiceGroups []common.IDNameExtensions `json:"nwServiceGroups,omitempty"`

        // Labels that are applicable to the rule.
        Labels []common.IDNameExtensions `json:"labels,omitempty"`

        // User-defined network service application groups to which the rule applied.
        // If not set, the rule is not restricted to a specific network service application group.
        NwApplicationGroups []common.IDNameExtensions `json:"nwApplicationGroups,omitempty"`

        AppServiceGroups []common.IDNameExtensions `json:"appServiceGroups,omitempty"`

        // The proxy gateway for which the rule is applicable. This field is applicable only for the Proxy Chaining forwarding method.
        ProxyGateway *common.IDName `json:"proxyGateway,omitempty"`

        // The ZPA Server Group for which this rule is applicable.
        // Only the Server Groups that are associated with the selected Application Segments are allowed.
        // This field is applicable only for the ZPA forwarding method.
        ZPAGateway *common.IDName `json:"zpaGateway,omitempty"`

        // The list of ZPA Application Segments for which this rule is applicable. This field is applicable only for the ZPA Gateway forwarding method.
        ZPAAppSegments []common.ZPAAppSegments `json:"zpaAppSegments"`

        // List of ZPA Application Segments for which this rule is applicable.
        // This field is applicable only for the ECZPA forwarding method (used for Zscaler Cloud Connector).
        ZPAApplicationSegments []ZPAApplicationSegments `json:"zpaApplicationSegments,omitempty"`

        // List of ZPA Application Segment Groups for which this rule is applicable.
        // This field is applicable only for the ECZPA forwarding method (used for Zscaler Cloud Connector).
        ZPAApplicationSegmentGroups []ZPAApplicationSegmentGroups `json:"zpaApplicationSegmentGroups,omitempty"`

        // The predefined ZPA Broker Rule generated by Zscaler (readonly: true)
        ZPABrokerRule bool `json:"zpaBrokerRule,omitempty"`
}

type ZPAApplicationSegments struct {
        // A unique identifier assigned to the Application Segment
        ID int `json:"id,omitempty"`

        // The name of the Application Segment
        Name string `json:"name,omitempty"`

        // Additional information about the Application Segment
        Description string `json:"description,omitempty"`

        // ID of the ZPA tenant where the Application Segment is configured
        ZPAID int `json:"zpaId,omitempty"`

        // Indicates whether the ZPA Application Segment has been deleted
        Deleted bool `json:"deleted,omitempty"`
}

type ZPAApplicationSegmentGroups struct {
        // A unique identifier assigned to the Application Segment Group
        ID int `json:"id,omitempty"`

        // The name of the Application Segment Group
        Name string `json:"name,omitempty"`

        // ID of the ZPA tenant where the Application Segment is configured
        ZPAID int `json:"zpaId,omitempty"`

        // Indicates whether the ZPA Application Segment has been deleted
        Deleted bool `json:"deleted,omitempty"`

        // The number of ZPA Application Segments in the group
        ZPAAppSegmentsCount int `json:"zpaAppSegmentsCount,omitempty"`
}

func Get(service *services.Service, ruleID int) (*ForwardingRules, error) <span class="cov5" title="5">{
        var rule ForwardingRules
        err := service.Client.Read(fmt.Sprintf("%s/%d", forwardingRulesEndpoint, ruleID), &amp;rule)
        if err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>

        <span class="cov4" title="3">service.Client.Logger.Printf("[DEBUG]Returning forwarding rule from Get: %d", rule.ID)
        return &amp;rule, nil</span>
}

func GetByName(service *services.Service, ruleName string) (*ForwardingRules, error) <span class="cov2" title="2">{
        var rules []ForwardingRules
        err := common.ReadAllPages(service.Client, forwardingRulesEndpoint, &amp;rules)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov2" title="2">for _, rule := range rules </span><span class="cov10" title="25">{
                if strings.EqualFold(rule.Name, ruleName) </span><span class="cov1" title="1">{
                        return &amp;rule, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("no forwarding rule found with name: %s", ruleName)</span>
}

func Create(service *services.Service, rule *ForwardingRules) (*ForwardingRules, error) <span class="cov1" title="1">{
        resp, err := service.Client.Create(forwardingRulesEndpoint, *rule)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">createdRules, ok := resp.(*ForwardingRules)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("object returned from api was not a rule Pointer")
        }</span>

        <span class="cov1" title="1">service.Client.Logger.Printf("[DEBUG]returning rule from create: %d", createdRules.ID)
        return createdRules, nil</span>
}

func Update(service *services.Service, ruleID int, rules *ForwardingRules) (*ForwardingRules, error) <span class="cov2" title="2">{
        resp, err := service.Client.UpdateWithPut(fmt.Sprintf("%s/%d", forwardingRulesEndpoint, ruleID), *rules)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">updatedRules, _ := resp.(*ForwardingRules)
        service.Client.Logger.Printf("[DEBUG]returning forwarding rule from update: %d", updatedRules.ID)
        return updatedRules, nil</span>
}

func Delete(service *services.Service, ruleID int) (*http.Response, error) <span class="cov4" title="3">{
        err := service.Client.Delete(fmt.Sprintf("%s/%d", forwardingRulesEndpoint, ruleID))
        if err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return nil, nil</span>
}

func GetAll(service *services.Service) ([]ForwardingRules, error) <span class="cov1" title="1">{
        var rules []ForwardingRules
        err := common.ReadAllPages(service.Client, forwardingRulesEndpoint, &amp;rules)
        return rules, err
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package zpa_gateways

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zia"
)

type Service struct {
        Client *zia.Client
}

func New(c *zia.Client) *Service <span class="cov10" title="5">{
        return &amp;Service{Client: c}
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package zpa_gateways

import (
        "errors"
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        zpaGatewaysEndpoint = "/zpaGateways"
)

type ZPAGateways struct {
        // A unique identifier assigned to the ZPA gateway
        ID int `json:"id"`

        // The name of the ZPA gateway
        Name string `json:"name,omitempty"`

        // Additional details about the ZPA gateway
        Description string `json:"description,omitempty"`

        // The ZPA Server Group that is configured for Source IP Anchoring
        ZPAServerGroup ZPAServerGroup `json:"zpaServerGroup,omitempty"`

        // All the Application Segments that are associated with the selected ZPA Server Group for which Source IP Anchoring is enabled
        ZPAAppSegments []ZPAAppSegments `json:"zpaAppSegments,omitempty"`

        // The ID of the ZPA tenant where Source IP Anchoring is configured
        ZPATenantId int `json:"zpaTenantId,omitempty"`

        // Information about the admin user that last modified the ZPA gateway
        LastModifiedBy *common.IDNameExtensions `json:"lastModifiedBy,omitempty"`

        // Timestamp when the ZPA gateway was last modified
        LastModifiedTime int `json:"lastModifiedTime,omitempty"`

        // Indicates whether the ZPA gateway is configured for Zscaler Internet Access (using option ZPA) or Zscaler Cloud Connector (using option ECZPA)
        // Supported Values: "ZPA", "ECZPA"
        Type string `json:"type"`
}

// The ZPA Server Group that is configured for Source IP Anchoring
type ZPAServerGroup struct {
        // Identifier that uniquely identifies an entity
        ID int `json:"id,omitempty"`

        // The name of the Application Segment
        Name string `json:"name,omitempty"`

        // An external identifier used for an entity that is managed outside of ZIA.
        // Examples include zpaServerGroup and zpaAppSegments.
        // This field is not applicable to ZIA-managed entities.
        ExternalID string `json:"externalId,omitempty"`

        Extensions map[string]interface{} `json:"extensions,omitempty"`
}

// All the Application Segments that are associated with the selected ZPA Server Group for which Source IP Anchoring is enabled
type ZPAAppSegments struct {
        // Identifier that uniquely identifies an entity
        ID int `json:"id,omitempty"`

        // The name of the Application Segment
        Name string `json:"name,omitempty"`

        // An external identifier used for an entity that is managed outside of ZIA.
        // Examples include zpaServerGroup and zpaAppSegments.
        // This field is not applicable to ZIA-managed entities.
        ExternalID string `json:"externalId,omitempty"`

        Extensions map[string]interface{} `json:"extensions,omitempty"`
}

func (service *Service) Get(ruleID int) (*ZPAGateways, error) <span class="cov10" title="3">{
        var rule ZPAGateways
        err := service.Client.Read(fmt.Sprintf("%s/%d", zpaGatewaysEndpoint, ruleID), &amp;rule)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov6" title="2">service.Client.Logger.Printf("[DEBUG]Returning zpa gateway from Get: %d", rule.ID)
        return &amp;rule, nil</span>
}

func (service *Service) GetByName(ruleName string) (*ZPAGateways, error) <span class="cov6" title="2">{
        var rules []ZPAGateways
        err := common.ReadAllPages(service.Client, zpaGatewaysEndpoint, &amp;rules)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="2">for _, rule := range rules </span><span class="cov10" title="3">{
                if strings.EqualFold(rule.Name, ruleName) </span><span class="cov1" title="1">{
                        return &amp;rule, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("no zpa gateway found with name: %s", ruleName)</span>
}

func (service *Service) Create(rule *ZPAGateways) (*ZPAGateways, error) <span class="cov1" title="1">{
        resp, err := service.Client.Create(zpaGatewaysEndpoint, *rule)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">createdRules, ok := resp.(*ZPAGateways)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("object returned from api was not a rule Pointer")
        }</span>

        <span class="cov1" title="1">service.Client.Logger.Printf("[DEBUG]returning zpa gateway from create: %d", createdRules.ID)
        return createdRules, nil</span>
}

func (service *Service) Update(ruleID int, rules *ZPAGateways) (*ZPAGateways, error) <span class="cov6" title="2">{
        resp, err := service.Client.UpdateWithPut(fmt.Sprintf("%s/%d", zpaGatewaysEndpoint, ruleID), *rules)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">updatedRules, _ := resp.(*ZPAGateways)
        service.Client.Logger.Printf("[DEBUG]returning zpa gateway from update: %d", updatedRules.ID)
        return updatedRules, nil</span>
}

func (service *Service) Delete(ruleID int) (*http.Response, error) <span class="cov10" title="3">{
        err := service.Client.Delete(fmt.Sprintf("%s/%d", zpaGatewaysEndpoint, ruleID))
        if err != nil </span><span class="cov6" title="2">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return nil, nil</span>
}

func (service *Service) GetAll() ([]ZPAGateways, error) <span class="cov1" title="1">{
        var rules []ZPAGateways
        err := common.ReadAllPages(service.Client, zpaGatewaysEndpoint, &amp;rules)
        return rules, err
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package intermediatecacertificates

import (
        "errors"
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        intermediateCaCertificatesEndpoint = "/intermediateCaCertificate"
        intCADownloadAttestationEndpoint   = "/intermediateCaCertificate/downloadAttestation"
        intCADownloadCSREndpoint           = "/intermediateCaCertificate/downloadCsr"
        intCADownloadPublicKeyEndpoint     = "/intermediateCaCertificate/downloadPublicKey"
        intCAGenerateCSREndpoint           = "/intermediateCaCertificate/generateCsr"
        intCAFinalizeCSREndpoint           = "/intermediateCaCertificate/finalizeCert"
        intCAKeyPairEndpoint               = "/intermediateCaCertificate/keyPair"
        intCACertMakeDefaultEndpoint       = "/intermediateCaCertificate/makeDefault"
        intCAReadyToUseEndpoint            = "/intermediateCaCertificate/readyToUse"
        intCAShowCertEndpoint              = "/intermediateCaCertificate/showCert"
        intCAShowCSREndpoint               = "/intermediateCaCertificate/showCsr"
        intCAUploadCert                    = "/intermediateCaCertificate/uploadCert"
        intCAUploadCertChain               = "/intermediateCaCertificate/uploadCertChain"
        intCAVerifyKeyAttestation          = "/intermediateCaCertificate/verifyKeyAttestation"
)

type IntermediateCACertificate struct {
        // Unique identifier for the intermediate CA certificat
        ID int `json:"id"`

        // Name of the intermediate CA certificate
        Name string `json:"name,omitempty"`

        // Description for the intermediate CA certificate
        Description string `json:"description,omitempty"`

        // Type of the intermediate CA certificate. Available types: Zscalers intermediate CA certificate (provided by Zscaler), custom intermediate certificate with software protection, and custom intermediate certificate with cloud HSM protection.
        Type string `json:"type,omitempty"`

        // Location of the HSM resources. Required for custom intermediate CA certificates with cloud HSM protection
        Region string `json:"region,omitempty"`

        // Determines whether the intermediate CA certificate is enabled or disabled for SSL inspection. Subscription to cloud HSM protection allows a maximum of four active certificates for SSL inspection at a time, whereas software protection subscription allows only one active certificate
        Status string `json:"status,omitempty"`

        // If set to true, the intermediate CA certificate is the default intermediate certificate. Only one certificate can be marked as the default intermediate certificate at a time
        DefaultCertificate bool `json:"defaultCertificate,omitempty"`

        // Start date of the intermediate CA certificates validity period
        CertStartDate int `json:"certStartDate,omitempty"`

        // Expiration date of the intermediate CA certificates validity period
        CertExpDate int `json:"certExpDate,omitempty"`

        // Tracks the progress of the intermediate CA certificate in the configuration workflow
        CurrentState string `json:"currentState,omitempty"`

        // Public key in the HSM key pair generated for the intermediate CA certificate
        PublicKey string `json:"publicKey,omitempty"`

        // Timestamp when the HSM key was generated
        KeyGenerationTime int `json:"keyGenerationTime,omitempty"`

        // Timestamp when the attestation for the HSM key was verified
        HSMAttestationVerifiedTime int `json:"hsmAttestationVerifiedTime,omitempty"`

        // Certificate Signing Request (CSR) file name
        CSRFileName string `json:"csrFileName,omitempty"`

        // Timestamp when the Certificate Signing Request (CSR) was generated
        CSRGenerationTime int `json:"csrGenerationTime,omitempty"`
}

type CertSigningRequest struct {
        // Unique identifier for the intermediate CA certificate
        CertID int `json:"certId"`

        // Name of the CSR file
        CSRFileName string `json:"csrFileName,omitempty"`

        // Common Name (CN) of your organizations domain, such as zscaler.com
        CommName string `json:"commName,omitempty"`

        // Name of your organization or company
        ORGName string `json:"orgName,omitempty"`

        // Name of your department or division
        DeptName string `json:"deptName,omitempty"`

        // Name of the city or town where your organization is located
        City string `json:"city,omitempty"`

        // State, province, region, or county where your organization is located
        State string `json:"state,omitempty"`

        // Country where your organization is located
        Country string `json:"country,omitempty"`

        // Key size to be used in the encryption algorithm in bits. Default size: 2048 bits
        KeySize int `json:"keySize,omitempty"`

        // Signature algorithm to be used for generating intermediate CA certificate. Default value: SHA256
        SignatureAlgorithm string `json:"signatureAlgorithm,omitempty"`

        // The path length constraint for the intermediate CA certificate. Default values: 0 for cloud HSM, 1 for software protection
        PathLengthConstraint int `json:"pathLengthConstraint,omitempty"`
}

func GetCertificate(service *services.Service, certID int) (*IntermediateCACertificate, error) <span class="cov1" title="1">{
        var intermediateCACertificate IntermediateCACertificate
        err := service.Client.Read(fmt.Sprintf("%s/%d", intermediateCaCertificatesEndpoint, certID), &amp;intermediateCACertificate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">service.Client.Logger.Printf("[DEBUG]Returning intermediate ca certificate from Get: %d", intermediateCACertificate.ID)
        return &amp;intermediateCACertificate, nil</span>
}

func GetByName(service *services.Service, certName string) (*IntermediateCACertificate, error) <span class="cov10" title="4">{
        var intermediateCACertificate []IntermediateCACertificate
        err := common.ReadAllPages(service.Client, intermediateCaCertificatesEndpoint, &amp;intermediateCACertificate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="4">for _, certificate := range intermediateCACertificate </span><span class="cov10" title="4">{
                if strings.EqualFold(certificate.Name, certName) </span><span class="cov10" title="4">{
                        return &amp;certificate, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("no intermediate ca certificate found with name: %s", certName)</span>
}

func GetDownloadAttestation(service *services.Service, certID int) (*IntermediateCACertificate, error) <span class="cov0" title="0">{
        var downloadAttestation IntermediateCACertificate
        err := service.Client.Read(fmt.Sprintf("%s/%d", intCADownloadAttestationEndpoint, certID), &amp;downloadAttestation)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">service.Client.Logger.Printf("[DEBUG]Returning downloaded attestation from Get: %d", downloadAttestation.ID)
        return &amp;downloadAttestation, nil</span>
}

func GetDownloadCSR(service *services.Service, certID int) (*IntermediateCACertificate, error) <span class="cov0" title="0">{
        var downloadCSR IntermediateCACertificate
        err := service.Client.Read(fmt.Sprintf("%s/%d", intCADownloadCSREndpoint, certID), &amp;downloadCSR)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">service.Client.Logger.Printf("[DEBUG]Returning downloaded csr from Get: %d", downloadCSR.ID)
        return &amp;downloadCSR, nil</span>
}

func GetDownloadPublicKey(service *services.Service, certID int) (*IntermediateCACertificate, error) <span class="cov0" title="0">{
        var downloadPublicKey IntermediateCACertificate
        err := service.Client.Read(fmt.Sprintf("%s/%d", intCADownloadPublicKeyEndpoint, certID), &amp;downloadPublicKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">service.Client.Logger.Printf("[DEBUG]Returning downloaded public key from Get: %d", downloadPublicKey.ID)
        return &amp;downloadPublicKey, nil</span>
}

func GetIntCAReadyToUse(service *services.Service) ([]IntermediateCACertificate, error) <span class="cov1" title="1">{
        var readyToUse []IntermediateCACertificate
        err := service.Client.Read(intCAReadyToUseEndpoint, &amp;readyToUse)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">service.Client.Logger.Printf("[DEBUG]Returning downloaded public key from Get: %v", readyToUse)
        return readyToUse, nil</span>
}

func GetShowCert(service *services.Service, certID int) (*CertSigningRequest, error) <span class="cov0" title="0">{
        var showCert CertSigningRequest
        err := service.Client.Read(fmt.Sprintf("%s/%d", intCAShowCertEndpoint, certID), &amp;showCert)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">service.Client.Logger.Printf("[DEBUG]Returning info about signed intrermediate CA certificates from Get: %d", showCert.CertID)
        return &amp;showCert, nil</span>
}

func GetShowCSR(service *services.Service, certID int) (*CertSigningRequest, error) <span class="cov0" title="0">{
        var showCSR CertSigningRequest
        err := service.Client.Read(fmt.Sprintf("%s/%d", intCAShowCSREndpoint, certID), &amp;showCSR)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">service.Client.Logger.Printf("[DEBUG]Returning info about signed intermediate CA certificates from Get: %d", showCSR.CertID)
        return &amp;showCSR, nil</span>
}

func GetAll(service *services.Service) ([]IntermediateCACertificate, error) <span class="cov1" title="1">{
        var intermediateCACertificate []IntermediateCACertificate
        err := common.ReadAllPages(service.Client, intermediateCaCertificatesEndpoint, &amp;intermediateCACertificate)
        return intermediateCACertificate, err
}</span>

func CreateIntCACertificate(service *services.Service, cert *IntermediateCACertificate) (*IntermediateCACertificate, error) <span class="cov0" title="0">{
        resp, err := service.Client.Create(intermediateCaCertificatesEndpoint, *cert)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">createdIntermediateCACert, ok := resp.(*IntermediateCACertificate)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("object returned from api was not an intermediate ca certificate Pointer")
        }</span>

        <span class="cov0" title="0">service.Client.Logger.Printf("[DEBUG]returning intermediate ca certificate from create: %d", createdIntermediateCACert.ID)
        return createdIntermediateCACert, nil</span>
}

func CreateIntCAGenerateCSR(service *services.Service, cert *IntermediateCACertificate) (*IntermediateCACertificate, error) <span class="cov0" title="0">{
        resp, err := service.Client.Create(intCAGenerateCSREndpoint, *cert)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">createdIntCAGenerateCSR, ok := resp.(*IntermediateCACertificate)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("object returned from api was not an intermediate ca certificate Pointer")
        }</span>

        <span class="cov0" title="0">service.Client.Logger.Printf("[DEBUG]returning intermediate ca certificate from create: %d", createdIntCAGenerateCSR.ID)
        return createdIntCAGenerateCSR, nil</span>
}

func CreateIntCAFinalizeCert(service *services.Service, cert *IntermediateCACertificate) (*IntermediateCACertificate, error) <span class="cov0" title="0">{
        resp, err := service.Client.Create(intCAFinalizeCSREndpoint, *cert)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">createdIntCAFinalizeCSR, ok := resp.(*IntermediateCACertificate)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("object returned from api was not an intermediate ca certificate Pointer")
        }</span>

        <span class="cov0" title="0">service.Client.Logger.Printf("[DEBUG]returning intermediate ca certificate from create: %d", createdIntCAFinalizeCSR.ID)
        return createdIntCAFinalizeCSR, nil</span>
}

func CreateIntCAKeyPair(service *services.Service, keyPair *IntermediateCACertificate) (*IntermediateCACertificate, error) <span class="cov0" title="0">{
        resp, err := service.Client.Create(intCAKeyPairEndpoint, *keyPair)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">createdIntCAKeyPair, ok := resp.(*IntermediateCACertificate)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("object returned from api was not an intermediate ca certificate Pointer")
        }</span>

        <span class="cov0" title="0">service.Client.Logger.Printf("[DEBUG]returning intermediate ca certificate from create: %d", createdIntCAKeyPair.ID)
        return createdIntCAKeyPair, nil</span>
}

func CreateUploadCert(service *services.Service, certID *IntermediateCACertificate) (*IntermediateCACertificate, error) <span class="cov0" title="0">{
        resp, err := service.Client.Create(intCAUploadCert, *certID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">createdIntCAUploadCert, ok := resp.(*IntermediateCACertificate)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("object returned from api was not an intermediate ca certificate Pointer")
        }</span>

        <span class="cov0" title="0">service.Client.Logger.Printf("[DEBUG]returning uploaded customer intermediate ca certificate from create: %d", createdIntCAUploadCert.ID)
        return createdIntCAUploadCert, nil</span>
}

func CreateUploadCertChain(service *services.Service, certID *IntermediateCACertificate) (*IntermediateCACertificate, error) <span class="cov0" title="0">{
        resp, err := service.Client.Create(intCAUploadCertChain, *certID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">createdIntCAUploadChain, ok := resp.(*IntermediateCACertificate)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("object returned from api was not an intermediate ca certificate Pointer")
        }</span>

        <span class="cov0" title="0">service.Client.Logger.Printf("[DEBUG]returning uploaded certificate chain from create: %d", createdIntCAUploadChain.ID)
        return createdIntCAUploadChain, nil</span>
}

func CreateVerifyKeyAttestation(service *services.Service, certID *IntermediateCACertificate) (*IntermediateCACertificate, error) <span class="cov0" title="0">{
        resp, err := service.Client.Create(intCAVerifyKeyAttestation, *certID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">createdVerifyKeyAttestation, ok := resp.(*IntermediateCACertificate)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("object returned from api was not an intermediate ca certificate Pointer")
        }</span>

        <span class="cov0" title="0">service.Client.Logger.Printf("[DEBUG]returning key attestation from create: %d", createdVerifyKeyAttestation.ID)
        return createdVerifyKeyAttestation, nil</span>
}

func Update(service *services.Service, certID int, certificates *IntermediateCACertificate) (*IntermediateCACertificate, error) <span class="cov0" title="0">{
        resp, err := service.Client.UpdateWithPut(fmt.Sprintf("%s/%d", intermediateCaCertificatesEndpoint, certID), *certificates)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">updatedIntermediateCaCert, _ := resp.(*IntermediateCACertificate)
        service.Client.Logger.Printf("[DEBUG]returning intermediate ca certificate from update: %d", updatedIntermediateCaCert.ID)
        return updatedIntermediateCaCert, nil</span>
}

func UpdateMakeDefault(service *services.Service, certID int, certificates *IntermediateCACertificate) (*IntermediateCACertificate, error) <span class="cov0" title="0">{
        resp, err := service.Client.UpdateWithPut(fmt.Sprintf("%s/%d", intCACertMakeDefaultEndpoint, certID), *certificates)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">updatedIntermediateCaCert, _ := resp.(*IntermediateCACertificate)
        service.Client.Logger.Printf("[DEBUG]returning default certificate from update: %d", updatedIntermediateCaCert.ID)
        return updatedIntermediateCaCert, nil</span>
}

func Delete(service *services.Service, certID int) (*http.Response, error) <span class="cov0" title="0">{
        err := service.Client.Delete(fmt.Sprintf("%s/%d", intermediateCaCertificatesEndpoint, certID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package locationgroups

import (
        "fmt"
        "net/url"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        locationGroupEndpoint = "/locations/groups"
)

type LocationGroup struct {
        // Unique identifier for the location group
        ID int `json:"id,omitempty"`

        // Location group name
        Name string `json:"name,omitempty"`

        // Indicates the location group was deleted
        Deleted bool `json:"deleted,omitempty"`

        // The location group's type (i.e., Static or Dynamic)
        GroupType string `json:"groupType,omitempty"`

        // A dynamic location group's criteria. This is ignored if the groupType is Static.
        DynamicLocationGroupCriteria *DynamicLocationGroupCriteria `json:"dynamicLocationGroupCriteria,omitempty"`

        // Additional information about the location group
        Comments string `json:"comments"`

        // The Name-ID pairs of the locations that are assigned to the static location group. This is ignored if the groupType is Dynamic.
        Locations []common.IDNameExtensions `json:"locations"`

        // Automatically populated with the current ZIA admin user, after a successful POST or PUT request.
        LastModUser *LastModUser `json:"lastModUser"`

        // Automatically populated with the current time, after a successful POST or PUT request.
        LastModTime int  `json:"lastModTime"`
        Predefined  bool `json:"predefined"`
}

type DynamicLocationGroupCriteria struct {
        // A sub-string to match location name. Valid operators are contains, starts with, and ends with",
        Name *Name `json:"name,omitempty"`

        // One or more countries from a predefined set
        Countries []string `json:"countries,omitempty"`

        // A sub-string to match city. Valid operators are starts with, ends with, contains, and exact match operators.
        City *City `json:"city,omitempty"`

        // One or more values from a predefined set of SD-WAN partner list to display partner names.
        ManagedBy []ManagedBy `json:"managedBy,omitempty"`

        // Enforce Authentication. Required when ports are enabled, IP Surrogate is enabled, or Kerberos Authentication is enabled.
        EnforceAuthentication bool `json:"enforceAuthentication"`

        // Enable AUP. When set to true, AUP is enabled for the location.
        EnforceAup bool `json:"enforceAup"`

        // Enable Firewall. When set to true, Firewall is enabled for the location.
        EnforceFirewallControl bool `json:"enforceFirewallControl"`

        // Enable XFF Forwarding. When set to true, traffic is passed to Zscaler Cloud via the X-Forwarded-For (XFF) header.
        EnableXffForwarding bool `json:"enableXffForwarding"`

        // Enable Caution. When set to true, a caution notifcation is enabled for the location.
        EnableCaution bool `json:"enableCaution"`

        // Enable Bandwidth Control. When set to true, Bandwidth Control is enabled for the location.
        EnableBandwidthControl bool `json:"enableBandwidthControl"`

        // One or more location profiles from a predefined set
        Profiles []string `json:"profiles"`
}

type Name struct {
        // String value to be matched or partially matched
        MatchString string `json:"matchString,omitempty"`

        // Operator that performs match action
        MatchType string `json:"matchType,omitempty"`
}

type City struct {
        // String value to be matched or partially matched
        MatchString string `json:"matchString,omitempty"`

        // Operator that performs match action
        MatchType string `json:"matchType,omitempty"`
}

type LastModUser struct {
        // Identifier that uniquely identifies an entity
        ID int `json:"id,omitempty"`

        // The configured name of the entity
        Name       string                 `json:"name,omitempty"`
        Extensions map[string]interface{} `json:"extensions,omitempty"`
}

type ManagedBy struct {
        ID         int                    `json:"id,omitempty"`
        Name       string                 `json:"name,omitempty"`
        Extensions map[string]interface{} `json:"extensions,omitempty"`
}

func GetLocationGroup(service *services.Service, groupID int) (*LocationGroup, error) <span class="cov10" title="3">{
        var locationGroup LocationGroup
        err := service.Client.Read(fmt.Sprintf("%s/%d", locationGroupEndpoint, groupID), &amp;locationGroup)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="3">service.Client.Logger.Printf("[DEBUG]returning location group from Get: %d", locationGroup.ID)
        return &amp;locationGroup, nil</span>
}

func GetLocationGroupByName(service *services.Service, locationGroupName string) (*LocationGroup, error) <span class="cov1" title="1">{
        var locationGroups []LocationGroup
        err := common.ReadAllPages(service.Client, fmt.Sprintf("%s?name=%s", locationGroupEndpoint, url.QueryEscape(locationGroupName)), &amp;locationGroups)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">for _, locationGroup := range locationGroups </span><span class="cov1" title="1">{
                if strings.EqualFold(locationGroup.Name, locationGroupName) </span><span class="cov1" title="1">{
                        return &amp;locationGroup, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("no location group found with name: %s", locationGroupName)</span>
}

// GetGroupType queries the location group by its type
func GetGroupType(service *services.Service, gType string) (*LocationGroup, error) <span class="cov6" title="2">{
        var groupTypes []LocationGroup
        err := service.Client.Read(fmt.Sprintf("%s?groupType=%s", locationGroupEndpoint, url.QueryEscape(gType)), &amp;groupTypes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="2">for _, locationGroup := range groupTypes </span><span class="cov6" title="2">{
                if strings.EqualFold(locationGroup.GroupType, gType) </span><span class="cov6" title="2">{
                        return &amp;locationGroup, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("no group type found with name: %s", gType)</span>
}

func GetAll(service *services.Service) ([]LocationGroup, error) <span class="cov1" title="1">{
        var locationGroups []LocationGroup
        err := common.ReadAllPages(service.Client, locationGroupEndpoint, &amp;locationGroups)
        return locationGroups, err
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package locationlite

import (
        "fmt"
        "net/url"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        locationLiteEndpoint = "/locations/lite"
)

type LocationLite struct {
        // Unique identifier for the location group
        ID int `json:"id"`

        // Location name
        Name string `json:"name,omitempty"`

        // Parent Location ID. If this ID does not exist or is 0, it is implied that it is a parent location. Otherwise, it is a sub-location whose parent has this ID. x-applicableTo: SUB
        ParentID int `json:"parentId,omitempty"`

        // Indicates the location group was deleted
        TZ string `json:"tz,omitempty"`

        // Enable XFF Forwarding for a location. When set to true, traffic is passed to Zscaler Cloud via the X-Forwarded-For (XFF) header.
        // Note: For sub-locations, this attribute is a read-only field as the value is inherited from the parent location.
        XFFForwardEnabled bool `json:"xffForwardEnabled,omitempty"`

        // Enable AUP. When set to true, AUP is enabled for the location. To learn more, see About End User Notifications
        AUPEnabled bool `json:"aupEnabled"`

        // Enable Caution. When set to true, a caution notifcation is enabled for the location
        CautionEnabled bool `json:"cautionEnabled"`

        // For First Time AUP Behavior, Block Internet Access. When set, all internet access (including non-HTTP traffic) is disabled until the user accepts the AUP.
        AUPBlockInternetUntilAccepted bool `json:"aupBlockInternetUntilAccepted"`

        // For First Time AUP Behavior, Force SSL Inspection. When set, Zscaler forces SSL Inspection in order to enforce AUP for HTTPS traffic.
        AUPForceSSLInspection bool `json:"aupForceSslInspection"`

        // Enable Surrogate IP. When set to true, users are mapped to internal device IP addresses
        SurrogateIP bool `json:"surrogateIP"`

        // Enforce Surrogate IP for Known Browsers. When set to true, IP Surrogate is enforced for all known browsers
        SurrogateIPEnforcedForKnownBrowsers bool `json:"surrogateIPEnforcedForKnownBrowsers"`

        // If set to true, indicates that this is a default sub-location created by the Zscaler service to accommodate IPv4 addresses that are not part of any user-defined sub-locations. The default sub-location is created with the name Other and it can be renamed, if required.
        OtherSubLocation bool `json:"otherSubLocation,omitempty"`

        // If set to true, indicates that this is a default sub-location created by the Zscaler service to accommodate IPv6 addresses that are not part of any user-defined sub-locations. The default sub-location is created with the name Other6 and it can be renamed, if required. This field is applicable only if ipv6Enabled is set is true.
        Other6SubLocation bool `json:"other6SubLocation,omitempty"`

        // Enable Firewall. When set to true, Firewall is enabled for the location.
        OFWEnabled bool `json:"ofwEnabled"`

        // Enable IPS Control. When set to true, IPS Control is enabled for the location if Firewall is enabled.
        IPSControl bool `json:"ipsControl"`

        // This parameter was deprecated and no longer has an effect on SSL policy. It remains supported in the API payload in order to maintain backwards compatibility with existing scripts, but it will be removed in future.
        // Enable Zscaler App SSL Setting. When set to true, the Zscaler App SSL Scan Setting takes effect, irrespective of the SSL policy that is configured for the location.
        ZappSSLScanEnabled bool `json:"zappSSLScanEnabled"`

        // If set to true, IPv6 is enabled for the location and IPv6 traffic from the location can be forwarded to the Zscaler service to enforce security policies.
        IPv6Enabled bool `json:"ipv6Enabled,omitempty"`

        // If set to true, IPv6 is enabled for the location and IPv6 traffic from the location can be forwarded to the Zscaler service to enforce security policies.
        ECLocation bool `json:"ecLocation,omitempty"`

        // If set to true, IPv6 is enabled for the location and IPv6 traffic from the location can be forwarded to the Zscaler service to enforce security policies.
        KerberosAuth bool `json:"kerberosAuth,omitempty"`

        // If set to true, IPv6 is enabled for the location and IPv6 traffic from the location can be forwarded to the Zscaler service to enforce security policies.
        DigestAuthEnabled bool `json:"digestAuthEnabled,omitempty"`
}

func GetLocationLiteID(service *services.Service, locationID int) (*LocationLite, error) <span class="cov1" title="1">{
        var locationLite LocationLite
        err := service.Client.Read(fmt.Sprintf("%s/%d", locationLiteEndpoint, locationID), &amp;locationLite)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">service.Client.Logger.Printf("[DEBUG]returning location group from Get: %d", locationLite.ID)
        return &amp;locationLite, nil</span>
}

func GetLocationLiteByName(service *services.Service, locationLiteName string) (*LocationLite, error) <span class="cov9" title="5">{
        var locationsLite []LocationLite
        err := common.ReadAllPages(service.Client, fmt.Sprintf("%s?name=%s", locationLiteEndpoint, url.QueryEscape(locationLiteName)), &amp;locationsLite)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov9" title="5">for _, locationLite := range locationsLite </span><span class="cov10" title="6">{
                if strings.EqualFold(locationLite.Name, locationLiteName) </span><span class="cov7" title="4">{
                        return &amp;locationLite, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("no location found with name: %s", locationLiteName)</span>
}

func GetAll(service *services.Service) ([]LocationLite, error) <span class="cov6" title="3">{
        var locations []LocationLite
        err := common.ReadAllPages(service.Client, locationLiteEndpoint, &amp;locations)
        return locations, err
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package locationmanagement

import (
        "errors"
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        locationsEndpoint   = "/locations"
        subLocationEndpoint = "/sublocations"
)

// Gets locations only, not sub-locations. When a location matches the given search parameter criteria only its parent location is included in the result set, not its sub-locations.
type Locations struct {
        // Location ID
        ID int `json:"id,omitempty"`

        // Location Name
        Name string `json:"name,omitempty"`

        // Parent Location ID. If this ID does not exist or is 0, it is implied that it is a parent location. Otherwise, it is a sub-location whose parent has this ID. x-applicableTo: SUB
        ParentID int `json:"parentId,omitempty"`

        // Upload bandwidth in kbps. The value 0 implies no Bandwidth Control enforcement
        UpBandwidth int `json:"upBandwidth,omitempty"`

        // Download bandwidth in kbps. The value 0 implies no Bandwidth Control enforcement
        DnBandwidth int `json:"dnBandwidth,omitempty"`

        // Country
        Country string `json:"country,omitempty"`

        // Language
        Language string `json:"language,omitempty"`

        // Timezone of the location. If not specified, it defaults to GMT.
        TZ string `json:"tz,omitempty"`

        //
        GeoOverride bool `json:"geoOverride,omitempty"`

        // For locations: IP addresses of the egress points that are provisioned in the Zscaler Cloud. Each entry is a single IP address (e.g., 238.10.33.9).
        // For sub-locations: Egress, internal, or GRE tunnel IP addresses. Each entry is either a single IP address, CIDR (e.g., 10.10.33.0/24), or range (e.g., 10.10.33.1-10.10.33.10)).
        IPAddresses []string `json:"ipAddresses,omitempty"`

        // IP ports that are associated with the location
        Ports string `json:"ports,omitempty"`

        // VPN User Credentials that are associated with the location.
        VPNCredentials []VPNCredentials `json:"vpnCredentials,omitempty"`

        // Enforce Authentication. Required when ports are enabled, IP Surrogate is enabled, or Kerberos Authentication is enabled.
        AuthRequired bool `json:"authRequired"`

        // Enable Basic Authentication at the location
        BasicAuthEnabled bool `json:"basicAuthEnabled"`

        // Enable Digest Authentication at the location
        DigestAuthEnabled bool `json:"digestAuthEnabled"`

        // Enable Kerberos Authentication at the location
        KerberosAuth bool `json:"kerberosAuth"`

        // Enable IOT Discovery at the location
        IOTDiscoveryEnabled bool `json:"iotDiscoveryEnabled"`

        // This parameter was deprecated and no longer has an effect on SSL policy. It remains supported in the API payload in order to maintain backwards compatibility with existing scripts, but it will be removed in future.
        // Enable SSL Inspection. Set to true in order to apply your SSL Inspection policy to HTTPS traffic in the location and inspect HTTPS transactions for data leakage, malicious content, and viruses.
        SSLScanEnabled bool `json:"sslScanEnabled"`

        // This parameter was deprecated and no longer has an effect on SSL policy. It remains supported in the API payload in order to maintain backwards compatibility with existing scripts, but it will be removed in future.
        // Enable Zscaler App SSL Setting. When set to true, the Zscaler App SSL Scan Setting takes effect, irrespective of the SSL policy that is configured for the location.
        ZappSSLScanEnabled bool `json:"zappSSLScanEnabled"`

        // Enable XFF Forwarding for a location. When set to true, traffic is passed to Zscaler Cloud via the X-Forwarded-For (XFF) header.
        // Note: For sub-locations, this attribute is a read-only field as the value is inherited from the parent location.
        XFFForwardEnabled bool `json:"xffForwardEnabled"`

        // Enable Surrogate IP. When set to true, users are mapped to internal device IP addresses
        SurrogateIP bool `json:"surrogateIP"`

        // Idle Time to Disassociation. The user mapping idle time (in minutes) is required if a Surrogate IP is enabled
        IdleTimeInMinutes int `json:"idleTimeInMinutes,omitempty"`

        // Display Time Unit. The time unit to display for IP Surrogate idle time to disassociation
        DisplayTimeUnit string `json:"displayTimeUnit,omitempty"`

        // Enforce Surrogate IP for Known Browsers. When set to true, IP Surrogate is enforced for all known browsers
        SurrogateIPEnforcedForKnownBrowsers bool `json:"surrogateIPEnforcedForKnownBrowsers"`

        // Refresh Time for re-validation of Surrogacy. The surrogate refresh time (in minutes) to re-validate the IP surrogates
        SurrogateRefreshTimeInMinutes int `json:"surrogateRefreshTimeInMinutes,omitempty"`

        // Display Refresh Time Unit. The time unit to display for refresh time for re-validation of surrogacy
        SurrogateRefreshTimeUnit string `json:"surrogateRefreshTimeUnit,omitempty"`

        // Enable Firewall. When set to true, Firewall is enabled for the location.
        OFWEnabled bool `json:"ofwEnabled"`

        // Enable IPS Control. When set to true, IPS Control is enabled for the location if Firewall is enabled.
        IPSControl bool `json:"ipsControl"`

        // Enable AUP. When set to true, AUP is enabled for the location
        AUPEnabled bool `json:"aupEnabled"`

        // Enable Caution. When set to true, a caution notifcation is enabled for the location
        CautionEnabled bool `json:"cautionEnabled"`

        // For First Time AUP Behavior, Block Internet Access. When set, all internet access (including non-HTTP traffic) is disabled until the user accepts the AUP.
        AUPBlockInternetUntilAccepted bool `json:"aupBlockInternetUntilAccepted"`

        // For First Time AUP Behavior, Force SSL Inspection. When set, Zscaler forces SSL Inspection in order to enforce AUP for HTTPS traffic.
        AUPForceSSLInspection bool `json:"aupForceSslInspection"`

        // Custom AUP Frequency. Refresh time (in days) to re-validate the AUP.
        AUPTimeoutInDays int `json:"aupTimeoutInDays,omitempty"`

        // Profile tag that specifies the location traffic type. If not specified, this tag defaults to "Unassigned".
        Profile string `json:"profile,omitempty"`

        // Additional notes or information regarding the location or sub-location. The description cannot exceed 1024 characters.
        Description string `json:"description,omitempty"`

        // If set to true, indicates that this is a default sub-location created by the Zscaler service to accommodate IPv4 addresses that are not part of any user-defined sub-locations. The default sub-location is created with the name Other and it can be renamed, if required.
        OtherSubLocation bool `json:"otherSubLocation,omitempty"`

        // If set to true, indicates that this is a default sub-location created by the Zscaler service to accommodate IPv6 addresses that are not part of any user-defined sub-locations. The default sub-location is created with the name Other6 and it can be renamed, if required. This field is applicable only if ipv6Enabled is set is true.
        Other6SubLocation bool `json:"other6SubLocation,omitempty"`

        // If set to true, IPv6 is enabled for the location and IPv6 traffic from the location can be forwarded to the Zscaler service to enforce security policies.
        IPv6Enabled bool `json:"ipv6Enabled,omitempty"`

        // (Optional) Name-ID pair of the NAT64 prefix configured as the DNS64 prefix for the location. If specified, the DNS64 prefix is used for the IP addresses that reside in this location. If not specified, a prefix is selected from the set of supported prefixes. This field is applicable only if ipv6Enabled is set is true.
        // Before you can configure a DNS64 prefix, you must send a GET request to /ipv6config/nat64prefix to retrieve the IDs of NAT64 prefixes, which can be configured as the DNS64 prefix.
        IPv6Dns64Prefix bool `json:"ipv6Dns64Prefix,omitempty"`
}

type Location struct {
        // Identifier that uniquely identifies an entity
        ID int `json:"id,omitempty"`

        // The configured name of the entity
        Name       string                 `json:"name,omitempty"`
        Extensions map[string]interface{} `json:"extensions,omitempty"`
}

type ManagedBy struct {
        // Identifier that uniquely identifies an entity
        ID int `json:"id,omitempty"`

        // The configured name of the entity
        Name       string                 `json:"name,omitempty"`
        Extensions map[string]interface{} `json:"extensions,omitempty"`
}

type VPNCredentials struct {
        // VPN credential id
        ID int `json:"id,omitempty"`

        // VPN authentication type (i.e., how the VPN credential is sent to the server). It is not modifiable after VpnCredential is created.
        // Note: Zscaler no longer supports adding a new XAUTH VPN credential, but existing entries can be edited or deleted using the respective endpoints.
        Type string `json:"type,omitempty"`

        // Fully Qualified Domain Name. Applicable only to UFQDN or XAUTH (or HOSTED_MOBILE_USERS) auth type.
        FQDN string `json:"fqdn,omitempty"`

        // Static IP address for VPN that is self-provisioned or provisioned by Zscaler. This is a required field for IP auth type and is not applicable to other auth types.
        // Note: If you want Zscaler to provision static IP addresses for your organization, contact Zscaler Support.
        IPAddress string `json:"ipAddress"`

        // Pre-shared key. This is a required field for UFQDN and IP auth type.
        PreSharedKey string `json:"preSharedKey,omitempty"`

        // Additional information about this VPN credential.
        Comments string `json:"comments,omitempty"`

        // Location that is associated to this VPN credential. Non-existence means not associated to any location.
        Location []Location `json:"location,omitempty"`

        // SD-WAN Partner that manages the location. If a partner does not manage the location, this is set to Self.
        ManagedBy []ManagedBy `json:"managedBy,omitempty"`
}

// Gets locations only, not sub-locations. When a location matches the given search parameter criteria only its parent location is included in the result set, not its sub-locations.
func GetLocation(service *services.Service, locationID int) (*Locations, error) <span class="cov10" title="5">{
        var location Locations
        err := service.Client.Read(fmt.Sprintf("%s/%d", locationsEndpoint, locationID), &amp;location)
        if err != nil </span><span class="cov4" title="2">{
                return nil, err
        }</span>

        <span class="cov7" title="3">service.Client.Logger.Printf("[DEBUG]Returning Location from Get: %d", location.ID)
        return &amp;location, nil</span>
}

// GetSubLocationBySubID gets a sub-location by its ID (fetches all locations's sub-location to find a match).
func GetSubLocationBySubID(service *services.Service, subLocationID int) (*Locations, error) <span class="cov1" title="1">{
        locations, err := GetAll(service)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">for _, location := range locations </span><span class="cov1" title="1">{
                subLoc, err := GetSubLocation(service, location.ID, subLocationID)
                if err == nil &amp;&amp; subLoc != nil </span><span class="cov1" title="1">{
                        return subLoc, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("sublocation not found: %d", subLocationID)</span>
}

// GetSublocations gets all sub-locations for a given location ID.
func GetSublocations(service *services.Service, locationID int) ([]Locations, error) <span class="cov10" title="5">{
        var locations []Locations
        err := common.ReadAllPages(service.Client, fmt.Sprintf("%s/%d%s", locationsEndpoint, locationID, subLocationEndpoint), &amp;locations)
        return locations, err
}</span>

// GetSubLocation gets a sub-location by its ID and parent ID.
func GetSubLocation(service *services.Service, locationID, subLocationID int) (*Locations, error) <span class="cov4" title="2">{
        locations, err := GetSublocations(service, locationID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="2">for _, location := range locations </span><span class="cov8" title="4">{
                if location.ID == subLocationID </span><span class="cov4" title="2">{
                        return &amp;location, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("sublocation not found: %d", subLocationID)</span>
}

// GetLocationByName gets a location by its name.
func GetLocationByName(service *services.Service, locationName string) (*Locations, error) <span class="cov8" title="4">{
        var locations []Locations
        // We are assuming this location name will be in the firsy 1000 obejcts
        err := common.ReadAllPages(service.Client, locationsEndpoint, &amp;locations)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="4">for _, location := range locations </span><span class="cov7" title="3">{
                if strings.EqualFold(location.Name, locationName) </span><span class="cov4" title="2">{
                        return &amp;location, nil
                }</span>
        }
        <span class="cov4" title="2">return nil, fmt.Errorf("no location found with name: %s", locationName)</span>
}

// GetSubLocationByNames gets a sub-location by its name and parent location name
func GetSubLocationByNames(service *services.Service, locationName, subLocatioName string) (*Locations, error) <span class="cov1" title="1">{
        location, err := GetLocationByName(service, locationName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">subLocations, err := GetSublocations(service, location.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">for _, subLocation := range subLocations </span><span class="cov4" title="2">{
                if strings.EqualFold(subLocation.Name, subLocatioName) </span><span class="cov1" title="1">{
                        return &amp;subLocation, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("no sublocation found with name: %s in location:%s", locationName, locationName)</span>
}

// GetSubLocationByName gets a sub-location by its name (fetches all locations's sub-location to find a match).
func GetSubLocationByName(service *services.Service, subLocatioName string) (*Locations, error) <span class="cov4" title="2">{
        locations, err := GetAll(service)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="2">for _, location := range locations </span><span class="cov4" title="2">{
                subLocs, _ := GetSublocations(service, location.ID)
                for _, subLoc := range subLocs </span><span class="cov8" title="4">{
                        if strings.EqualFold(subLoc.Name, subLocatioName) </span><span class="cov4" title="2">{
                                return &amp;subLoc, nil
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("no sublocation found with name: %s", subLocatioName)</span>
}

func Create(service *services.Service, locations *Locations) (*Locations, error) <span class="cov4" title="2">{
        resp, err := service.Client.Create(locationsEndpoint, *locations)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">createdLocations, ok := resp.(*Locations)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("object returned from api was not a location pointer")
        }</span>

        <span class="cov4" title="2">service.Client.Logger.Printf("[DEBUG]returning locations from create: %d", createdLocations.ID)
        return createdLocations, nil</span>
}

func Update(service *services.Service, locationID int, locations *Locations) (*Locations, *http.Response, error) <span class="cov4" title="2">{
        resp, err := service.Client.UpdateWithPut(fmt.Sprintf("%s/%d", locationsEndpoint, locationID), *locations)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">updatedLocations, _ := resp.(*Locations)

        service.Client.Logger.Printf("[DEBUG]returning locations from Update: %d", updatedLocations.ID)
        return updatedLocations, nil, nil</span>
}

func Delete(service *services.Service, locationID int) (*http.Response, error) <span class="cov4" title="2">{
        err := service.Client.Delete(fmt.Sprintf("%s/%d", locationsEndpoint, locationID))
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return nil, nil</span>
}

func GetAll(service *services.Service) ([]Locations, error) <span class="cov10" title="5">{
        var locations []Locations
        // We are assuming this location name will be in the firsy 1000 obejcts
        err := common.ReadAllPages(service.Client, locationsEndpoint, &amp;locations)
        return locations, err
}</span>

func GetAllSublocations(service *services.Service) ([]Locations, error) <span class="cov1" title="1">{
        // Step 1: Fetch all parent locations.
        parentLocations, err := GetAll(service)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">var allSublocations []Locations

        // Step 2: For each parent location, fetch its sub-locations.
        for _, parent := range parentLocations </span><span class="cov1" title="1">{
                var sublocations []Locations
                // Create the sub-location endpoint for the current parent location.
                subEndpoint := fmt.Sprintf("%s/%d%s", locationsEndpoint, parent.ID, subLocationEndpoint)

                err := common.ReadAllPages(service.Client, subEndpoint, &amp;sublocations)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">allSublocations = append(allSublocations, sublocations...)</span>
        }

        <span class="cov1" title="1">return allSublocations, nil</span>
}

// GetLocationOrSublocationByID gets a location or sub-location by its ID.
func GetLocationOrSublocationByID(service *services.Service, id int) (*Locations, error) <span class="cov4" title="2">{
        location, err := GetLocation(service, id)
        if err == nil &amp;&amp; location != nil </span><span class="cov4" title="2">{
                return location, nil
        }</span>
        <span class="cov0" title="0">return GetSubLocationBySubID(service, id)</span>
}

// GetLocationOrSublocationByName gets a location or sub-location by its name.
func GetLocationOrSublocationByName(service *services.Service, name string) (*Locations, error) <span class="cov1" title="1">{
        location, err := GetLocationByName(service, name)
        if err == nil &amp;&amp; location != nil </span><span class="cov0" title="0">{
                return location, nil
        }</span>
        <span class="cov1" title="1">return GetSubLocationByName(service, name)</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package rule_labels

import (
        "errors"
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        ruleLabelsEndpoint = "/ruleLabels"
)

type RuleLabels struct {
        // The unique identifier for the rule label.
        ID int `json:"id"`

        // The rule label name.
        Name string `json:"name,omitempty"`

        // The rule label description.
        Description string `json:"description,omitempty"`

        // Timestamp when the rule lable was last modified. This is a read-only field. Ignored by PUT and DELETE requests.
        LastModifiedTime int `json:"lastModifiedTime,omitempty"`

        // The admin that modified the rule label last. This is a read-only field. Ignored by PUT requests.
        LastModifiedBy *common.IDNameExtensions `json:"lastModifiedBy,omitempty"`

        // The admin that created the rule label. This is a read-only field. Ignored by PUT requests.
        CreatedBy *common.IDNameExtensions `json:"createdBy,omitempty"`

        // The number of rules that reference the label.
        ReferencedRuleCount int `json:"referencedRuleCount,omitempty"`
}

func Get(service *services.Service, ruleLabelID int) (*RuleLabels, error) <span class="cov10" title="4">{
        var ruleLabel RuleLabels
        err := service.Client.Read(fmt.Sprintf("%s/%d", ruleLabelsEndpoint, ruleLabelID), &amp;ruleLabel)
        if err != nil </span><span class="cov5" title="2">{
                return nil, err
        }</span>

        <span class="cov5" title="2">service.Client.Logger.Printf("[DEBUG]Returning rule label from Get: %d", ruleLabel.ID)
        return &amp;ruleLabel, nil</span>
}

func GetRuleLabelByName(service *services.Service, labelName string) (*RuleLabels, error) <span class="cov5" title="2">{
        var ruleLabels []RuleLabels
        err := common.ReadAllPages(service.Client, ruleLabelsEndpoint, &amp;ruleLabels)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="2">for _, ruleLabel := range ruleLabels </span><span class="cov1" title="1">{
                if strings.EqualFold(ruleLabel.Name, labelName) </span><span class="cov1" title="1">{
                        return &amp;ruleLabel, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("no rule label found with name: %s", labelName)</span>
}

func Create(service *services.Service, ruleLabelID *RuleLabels) (*RuleLabels, *http.Response, error) <span class="cov1" title="1">{
        resp, err := service.Client.Create(ruleLabelsEndpoint, *ruleLabelID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">createdRuleLabel, ok := resp.(*RuleLabels)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, errors.New("object returned from api was not a rule label pointer")
        }</span>

        <span class="cov1" title="1">service.Client.Logger.Printf("[DEBUG]returning new rule label from create: %d", createdRuleLabel.ID)
        return createdRuleLabel, nil, nil</span>
}

func Update(service *services.Service, ruleLabelID int, ruleLabels *RuleLabels) (*RuleLabels, *http.Response, error) <span class="cov5" title="2">{
        resp, err := service.Client.UpdateWithPut(fmt.Sprintf("%s/%d", ruleLabelsEndpoint, ruleLabelID), *ruleLabels)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">updatedRuleLabel, _ := resp.(*RuleLabels)

        service.Client.Logger.Printf("[DEBUG]returning updates rule label from update: %d", updatedRuleLabel.ID)
        return updatedRuleLabel, nil, nil</span>
}

func Delete(service *services.Service, ruleLabelID int) (*http.Response, error) <span class="cov5" title="2">{
        err := service.Client.Delete(fmt.Sprintf("%s/%d", ruleLabelsEndpoint, ruleLabelID))
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return nil, nil</span>
}

func GetAll(service *services.Service) ([]RuleLabels, error) <span class="cov1" title="1">{
        var ruleLabels []RuleLabels
        err := common.ReadAllPages(service.Client, ruleLabelsEndpoint, &amp;ruleLabels)
        return ruleLabels, err
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package sandbox_report

import (
        "encoding/json"
        "errors"
        "fmt"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        reportQuotaEndpoint = "/sandbox/report/quota"
        reportMD5Endpoint   = "/sandbox/report/"
)

type RatingQuota struct {
        StartTime int    `json:"startTime,omitempty"`
        Used      int    `json:"used,omitempty"`
        Allowed   int    `json:"allowed,omitempty"`
        Scale     string `json:"scale,omitempty"`
        Unused    int    `json:"unused,omitempty"`
}

type ReportMD5Hash struct {
        Details *FullDetails `json:"details,omitempty"`
}

type Summary struct {
        Detail         *SummaryDetail  `json:"Summary,omitempty"`
        Classification *Classification `json:"Classification,omitempty"`
        FileProperties *FileProperties `json:"FileProperties,omitempty"`
}

type SummaryDetail struct {
        Status    string `json:"Status,omitempty"`
        Category  string `json:"Category,omitempty"`
        FileType  string `json:"FileType,omitempty"`
        StartTime int    `json:"StartTime,omitempty"`
        Duration  int    `json:"Duration,omitempty"`
}

type Classification struct {
        Type            string `json:"Type,omitempty"`
        Category        string `json:"Category,omitempty"`
        Score           int    `json:"Score,omitempty"`
        DetectedMalware string `json:"DetectedMalware,omitempty"`
}

type FileProperties struct {
        FileType          string `json:"FileType,omitempty"`
        FileSize          int    `json:"FileSize,omitempty"`
        MD5               string `json:"MD5,omitempty"`
        SHA1              string `json:"SHA1,omitempty"`
        SHA256            string `json:"Sha256,omitempty"`
        Issuer            string `json:"Issuer,omitempty"`
        DigitalCerificate string `json:"DigitalCerificate,omitempty"`
        SSDeep            string `json:"SSDeep,omitempty"`
        RootCA            string `json:"RootCA,omitempty"`
}

type FullDetails struct {
        Summary        SummaryDetail         `json:"Summary,omitempty"`
        Classification Classification        `json:"Classification,omitempty"`
        FileProperties FileProperties        `json:"FileProperties,omitempty"`
        Origin         *Origin               `json:"Origin,omitempty"`
        SystemSummary  []SystemSummaryDetail `json:"SystemSummary,omitempty"`
        Spyware        []*common.SandboxRSS  `json:"Spyware,omitempty"`
        Networking     []*common.SandboxRSS  `json:"Networking,omitempty"`
        SecurityBypass []*common.SandboxRSS  `json:"SecurityBypass,omitempty"`
        Exploit        []*common.SandboxRSS  `json:"Exploit,omitempty"`
        Stealth        []*common.SandboxRSS  `json:"Stealth,omitempty"`
        Persistence    []*common.SandboxRSS  `json:"Persistence,omitempty"`
}

type Origin struct {
        Risk     string `json:"Risk,omitempty"`
        Language string `json:"Language,omitempty"`
        Country  string `json:"Country,omitempty"`
}

type SystemSummaryDetail struct {
        Risk             string   `json:"Risk,omitempty"`
        Signature        string   `json:"Signature,omitempty"`
        SignatureSources []string `json:"SignatureSources,omitempty"`
}

func GetRatingQuota(service *services.Service) ([]RatingQuota, error) <span class="cov1" title="1">{
        var quotas []RatingQuota
        err := service.Client.Read(reportQuotaEndpoint, &amp;quotas)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">service.Client.Logger.Printf("[DEBUG] Returning quota for retrieving Sandbox Detail Reports from Get: %v", quotas)
        return quotas, nil</span>
}

// GetReportMD5Hash retrieves the sandbox report for a specific MD5 hash with either full or summary details.
func GetReportMD5Hash(service *services.Service, md5Hash, details string) (*ReportMD5Hash, error) <span class="cov10" title="2">{
        // Validate the 'details' parameter to ensure it is either "full" or "summary".
        if details != "full" &amp;&amp; details != "summary" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("details parameter must be 'full' or 'summary'")
        }</span>

        // Construct the endpoint URL with the md5Hash and details query parameters.
        <span class="cov10" title="2">endpoint := fmt.Sprintf("%s%s?details=%s", reportMD5Endpoint, md5Hash, details)

        var resp map[string]interface{}
        err := service.Client.Read(endpoint, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="2">var data interface{}
        var report ReportMD5Hash
        if details == "full" </span><span class="cov1" title="1">{
                data = resp["Full Details"]
        }</span> else<span class="cov1" title="1"> {
                data = resp["Summary"]
        }</span>
        <span class="cov10" title="2">if data == nil </span><span class="cov0" title="0">{
                return nil, errors.New("got empty response")
        }</span>

        <span class="cov10" title="2">if msg, ok := data.(string); ok </span><span class="cov0" title="0">{
                return nil, errors.New(msg)
        }</span>

        <span class="cov10" title="2">dataBytes, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="2">if err := json.Unmarshal(dataBytes, &amp;report.Details); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="2">service.Client.Logger.Printf("[DEBUG] Returning report for MD5 hash '%s' with details '%s': %+v", md5Hash, details, report)
        return &amp;report, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package sandbox_settings

import "github.com/zscaler/zscaler-sdk-go/v2/zia/services"

const (
        advancedSettingsEndpoint = "/behavioralAnalysisAdvancedSettings"
        fileHashCountEndpoint    = "/fileHashCount"
)

type BaAdvancedSettings struct {
        FileHashesToBeBlocked []string `json:"fileHashesToBeBlocked,omitempty"`
}

type FileHashCount struct {
        BlockedFileHashesCount int `json:"blockedFileHashesCount,omitempty"`
        RemainingFileHashes    int `json:"remainingFileHashes,omitempty"`
}

func Get(service *services.Service) (*BaAdvancedSettings, error) <span class="cov1" title="1">{
        var hashes BaAdvancedSettings
        err := service.Client.Read(advancedSettingsEndpoint, &amp;hashes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">service.Client.Logger.Printf("[DEBUG] Returning custom list of MD5 hashes from Get: %v", hashes)
        return &amp;hashes, nil</span>
}

func Update(service *services.Service, hashes BaAdvancedSettings) (*BaAdvancedSettings, error) <span class="cov10" title="2">{
        _, err := service.Client.UpdateWithPut(advancedSettingsEndpoint, hashes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="2">service.Client.Logger.Printf("[DEBUG] Returning updated custom list of MD5 hashes from Get: %v", hashes)
        return &amp;hashes, nil</span>
}

func GetFileHashCount(service *services.Service) (*FileHashCount, error) <span class="cov1" title="1">{
        var hashes FileHashCount
        err := service.Client.Read(advancedSettingsEndpoint+fileHashCountEndpoint, &amp;hashes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">service.Client.Logger.Printf("[DEBUG] Returning used andd unused quota for blocking MD5 file hashes from Get: %v", hashes)
        return &amp;hashes, nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package sandbox_submission

import (
        "bytes"
        "compress/gzip"
        "encoding/json"
        "io"
        "mime"
        "net/url"
        "path/filepath"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
)

const (
        submitEndpoint = "/zscsb/submit"
        discanEndpoint = "/zscsb/discan"
)

// Information about the file inspection results
type ScanResult struct {
        Code              int    `json:"code,omitempty"`
        Message           string `json:"message,omitempty"`
        FileType          string `json:"fileType,omitempty"`
        Md5               string `json:"md5,omitempty"`
        SandboxSubmission string `json:"sandboxSubmission,omitempty"`
        VirusName         string `json:"virusName,omitempty"`
        VirusType         string `json:"virusType,omitempty"`
}

// Submit: Submits raw or archive files (e.g., ZIP) to Sandbox for analysis. You can submit up to 100 files per day and it supports all file types that are currently supported by Sandbox. To learn more, see About Sandbox. By default, files are scanned by Zscaler antivirus (AV) and submitted directly to the sandbox in order to obtain a verdict. However, if a verdict already exists for the file, you can use the 'force' parameter to make the sandbox to reanalyze it.
// You must have a Sandbox policy rule configured within the ZIA Admin Portal in order to analyze files that aren't present in the default policy rule. Ensure that you have explicitly added Sandbox policy rules that include the appropriate file types within your request. If not, an 'Unknown' message is shown in the response.
// To learn more, see Configuring the Sandbox Policy and Configuring the Default Sandbox Rule.
// After files are sent for analysis, you must use GET /sandbox/report/{md5Hash} in order to retrieve the verdict. You can get the Sandbox report 10 minutes after a file is sent for analysis.
// SubmitFile submits a file for scanning and returns the result of the scan.
func SubmitFile(service *services.Service, filename string, file io.Reader, force string) (*ScanResult, error) <span class="cov7" title="7">{
        return scanFile(service, filename, file, force, submitEndpoint)
}</span>

// Discan Submits raw or archive files (e.g., ZIP) to the Zscaler service for out-of-band file inspection to generate real-time verdicts for known and unknown files. It leverages capabilities such as Malware Prevention, Advanced Threat Prevention, Sandbox cloud effect, AI/ML-driven file analysis, and integrated third-party threat intelligence feeds to inspect files and classify them as benign or malicious instantaneously.
// All file types that are currently supported by the Malware Protection policy and Advanced Threat Protection policy are supported for inspection, and each file is limited to a size of 400 MB.
// Note: Dynamic file analysis is not included in out-of-band file inspection.
func Discan(service *services.Service, filename string, file io.Reader) (*ScanResult, error) <span class="cov7" title="7">{
        return scanFile(service, filename, file, "", discanEndpoint)
}</span>

func scanFile(service *services.Service, filename string, file io.Reader, force, endpoint string) (*ScanResult, error) <span class="cov10" title="14">{
        // Add the API token and force parameter to the request URL query
        urlParams := url.Values{}
        urlParams.Set("api_token", service.Client.GetSandboxToken())
        if force != "" </span><span class="cov0" title="0">{
                urlParams.Set("force", force)
        }</span>
        // Determine the Content-Type based on the file extension
        <span class="cov10" title="14">contentType := mime.TypeByExtension(filepath.Ext(filename))
        if contentType == "" </span><span class="cov0" title="0">{
                // If the content type cannot be determined, set it to a default value
                contentType = "application/octet-stream"
        }</span>
        // Create a buffer to store the gzipped file
        <span class="cov10" title="14">var gzippedFile bytes.Buffer
        gz := gzip.NewWriter(&amp;gzippedFile)

        // Copy the file content to the gzip writer
        _, err := io.Copy(gz, file)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="14">data, err := service.Client.GenericRequest(service.Client.GetSandboxURL(), endpoint, "POST", &amp;gzippedFile, urlParams, contentType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="14">var result ScanResult
        err = json.Unmarshal(data, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="14">return &amp;result, nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package security_policy_settings

import "github.com/zscaler/zscaler-sdk-go/v2/zia/services"

const (
        securityEndpoint         = "/security"
        securityAdvancedEndpoint = "/security/advanced"
)

// TODO: because there isn't an endpoint to get all Urls, we need to have all action types here.
var AddRemoveURLFromList []string = []string{
        "ADD_TO_LIST",
        "REMOVE_FROM_LIST",
}

type ListUrls struct {
        // Allowlist URLs whose contents will not be scanned. Allows up to 255 URLs. There may be trusted websites the content of which might be blocked due to anti-virus, anti-spyware, or anti-malware policies. Enter the URLs of sites you do not want scanned. The service allows users to download content from these URLs without inspecting the traffic. The allowlist applies to the Malware Protection, Advanced Threats Protection, and Sandbox policies.
        White []string `json:"whitelistUrls,omitempty"`

        // URLs on the denylist for your organization. Allow up to 25000 URLs.
        Black []string `json:"blacklistUrls,omitempty"`
}

func GetListUrls(service *services.Service) (*ListUrls, error) <span class="cov10" title="3">{
        whitelist, err := GetWhiteListUrls(service)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="3">blacklist, err := GetBlackListUrls(service)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="3">return &amp;ListUrls{
                White: whitelist.White,
                Black: blacklist.Black,
        }, nil</span>
}

func UpdateListUrls(service *services.Service, listUrls ListUrls) (*ListUrls, error) <span class="cov6" title="2">{
        whitelist, err := UpdateWhiteListUrls(service, ListUrls{White: listUrls.White})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="2">blacklist, err := UpdateBlackListUrls(service, ListUrls{Black: listUrls.Black})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="2">return &amp;ListUrls{
                White: whitelist.White,
                Black: blacklist.Black,
        }, nil</span>
}

func UpdateWhiteListUrls(service *services.Service, list ListUrls) (*ListUrls, error) <span class="cov6" title="2">{
        _, err := service.Client.UpdateWithPut(securityEndpoint, list)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="2">return &amp;list, nil</span>
}

func UpdateBlackListUrls(service *services.Service, list ListUrls) (*ListUrls, error) <span class="cov6" title="2">{
        _, err := service.Client.UpdateWithPut(securityAdvancedEndpoint, list)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="2">return &amp;list, nil</span>
}

func GetWhiteListUrls(service *services.Service) (*ListUrls, error) <span class="cov10" title="3">{
        var whitelist ListUrls
        err := service.Client.Read(securityEndpoint, &amp;whitelist)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="3">return &amp;whitelist, nil</span>
}

func GetBlackListUrls(service *services.Service) (*ListUrls, error) <span class="cov10" title="3">{
        var blacklist ListUrls
        err := service.Client.Read(securityAdvancedEndpoint, &amp;blacklist)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="3">return &amp;blacklist, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package services

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zia"
)

type Service struct {
        Client *zia.Client
}

func New(c *zia.Client) *Service <span class="cov10" title="175">{
        return &amp;Service{Client: c}
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package greinternalipranges

import (
        "fmt"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
)

const (
        greTunnelIPRangeEndpoint = "/greTunnels/availableInternalIpRanges"
)

type GREInternalIPRange struct {
        // Starting IP address in the range
        StartIPAddress string `json:"startIPAddress,omitempty"`

        // Ending IP address in the range
        EndIPAddress string `json:"endIPAddress,omitempty"`
}

func GetGREInternalIPRange(service *services.Service, count int) (*[]GREInternalIPRange, error) <span class="cov8" title="1">{
        var greInternalIPRanges []GREInternalIPRange
        err := service.Client.Read(fmt.Sprintf("%s?limit=%d", greTunnelIPRangeEndpoint, count), &amp;greInternalIPRanges)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(greInternalIPRanges) &lt; count </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not enough internal IP range available, got %d internal IP range, required: %d", len(greInternalIPRanges), count)
        }</span>
        <span class="cov8" title="1">service.Client.Logger.Printf("[DEBUG]Returning internal IP range: %s", greInternalIPRanges)
        return &amp;greInternalIPRanges, nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package gretunnelinfo

import (
        "fmt"
        "net/url"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
)

const (
        ipGreTunnelInfoEndpoint = "/orgProvisioning/ipGreTunnelInfo"
)

type GRETunnelInfo struct {
        TunID             int    `json:"tunID,omitempty"`
        IPaddress         string `json:"ipAddress,omitempty"`
        GREEnabled        bool   `json:"greEnabled,omitempty"`
        GREtunnelIP       string `json:"greTunnelIP,omitempty"`
        PrimaryGW         string `json:"primaryGW,omitempty"`
        SecondaryGW       string `json:"secondaryGW,omitempty"`
        GRERangePrimary   string `json:"greRangePrimary,omitempty"`
        GRERangeSecondary string `json:"greRangeSecondary,omitempty"`
}

// Gets a list of IP addresses with GRE tunnel details.
func GetGRETunnelInfo(service *services.Service, ipAddress string) (*GRETunnelInfo, error) <span class="cov10" title="2">{
        var greTunnelInfo []GRETunnelInfo
        err := service.Client.Read(fmt.Sprintf("%s?ipAddress=%s", ipGreTunnelInfoEndpoint, url.QueryEscape(ipAddress)), &amp;greTunnelInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="2">for _, greIP := range greTunnelInfo </span><span class="cov10" title="2">{
                if strings.EqualFold(greIP.IPaddress, ipAddress) </span><span class="cov1" title="1">{
                        return &amp;greIP, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("no information for gre tunnel ip address: %s", ipAddress)</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package gretunnels

import (
        "errors"
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        greTunnelsEndpoint = "/greTunnels"
        // IpGreTunnelInfoEndpoint = "/orgProvisioning/ipGreTunnelInfo".
)

type GreTunnels struct {
        // Unique identifier of the static IP address that is associated to a GRE tunnel
        ID int `json:"id,omitempty"`

        // The source IP address of the GRE tunnel. This is typically a static IP address in the organization or SD-WAN. This IP address must be provisioned within the Zscaler service using the /staticIP endpoint.
        SourceIP string `json:"sourceIp,omitempty"`

        // The start of the internal IP address in /29 CIDR range
        InternalIpRange string `json:"internalIpRange,omitempty"`

        // When the GRE tunnel information was last modified
        LastModificationTime int `json:"lastModificationTime,omitempty"`

        // Restrict the data center virtual IP addresses (VIPs) only to those within the same country as the source IP address
        WithinCountry *bool `json:"withinCountry"`

        // Additional information about this GRE tunnel
        Comment string `json:"comment,omitempty"`

        // This is required to support the automated SD-WAN provisioning of GRE tunnels, when set to true gre_tun_ip and gre_tun_id are set to null
        IPUnnumbered bool `json:"ipUnnumbered"`

        // Restrict the data center virtual IP addresses (VIPs) only to those part of the subcloud
        SubCloud string `json:"subcloud,omitempty"`

        // SD-WAN Partner that manages the location. If a partner does not manage the location, this is set to Self.
        ManagedBy *ManagedBy `json:"managedBy,omitempty"` // Should probably move this to a common package. Used by multiple resources

        // Who modified the GRE tunnel information last
        LastModifiedBy *LastModifiedBy `json:"lastModifiedBy,omitempty"` // Should probably move this to a common package. Used by multiple resources

        // The primary destination data center and virtual IP address (VIP) of the GRE tunnel
        PrimaryDestVip *PrimaryDestVip `json:"primaryDestVip,omitempty"`

        // The secondary destination data center and virtual IP address (VIP) of the GRE tunnel
        SecondaryDestVip *SecondaryDestVip `json:"secondaryDestVip,omitempty"`
}

type PrimaryDestVip struct {
        // Unique identifer of the GRE virtual IP address (VIP)
        ID int `json:"id,omitempty"`

        // GRE cluster virtual IP address (VIP)
        VirtualIP string `json:"virtualIp,omitempty"`

        // Set to true if the virtual IP address (VIP) is a ZIA Private Service Edge
        PrivateServiceEdge bool `json:"privateServiceEdge"`

        // Data center information
        Datacenter string `json:"datacenter,omitempty"`

        // Latitude with 7 digit precision after decimal point, ranges between -90 and 90 degrees.
        Latitude float64 `json:"latitude,omitempty"`

        // Longitude with 7 digit precision after decimal point, ranges between -180 and 180 degrees.
        Longitude float64 `json:"longitude,omitempty"`

        // City information
        City string `json:"city,omitempty"`

        // Country Code information
        CountryCode string `json:"countryCode,omitempty"`

        // Region information
        Region string `json:"region,omitempty"`
}

type SecondaryDestVip struct {
        // Unique identifer of the GRE virtual IP address (VIP)
        ID int `json:"id,omitempty"`

        // GRE cluster virtual IP address (VIP)
        VirtualIP string `json:"virtualIp,omitempty"`

        // Set to true if the virtual IP address (VIP) is a ZIA Private Service Edge
        PrivateServiceEdge bool `json:"privateServiceEdge"`

        // Data center information
        Datacenter string `json:"datacenter,omitempty"`

        // Latitude with 7 digit precision after decimal point, ranges between -90 and 90 degrees.
        Latitude float64 `json:"latitude,omitempty"`

        // Longitude with 7 digit precision after decimal point, ranges between -180 and 180 degrees.
        Longitude float64 `json:"longitude,omitempty"`

        // City information
        City string `json:"city,omitempty"`

        // Country Code information
        CountryCode string `json:"countryCode,omitempty"`

        // Region information
        Region string `json:"region,omitempty"`
}

type ManagedBy struct {
        // Identifier that uniquely identifies an entity
        ID int `json:"id,omitempty"`

        // The configured name of the entity
        Name       string                 `json:"name,omitempty"`
        Extensions map[string]interface{} `json:"extensions"`
}

type LastModifiedBy struct {
        // Identifier that uniquely identifies an entity
        ID int `json:"id,omitempty"`

        // The configured name of the entity
        Name       string                 `json:"name,omitempty"`
        Extensions map[string]interface{} `json:"extensions"`
}

// Gets specific provisioned GRE tunnel information.
func GetGreTunnels(service *services.Service, greTunnelID int) (*GreTunnels, error) <span class="cov10" title="3">{
        var greTunnels GreTunnels
        err := service.Client.Read(fmt.Sprintf("%s/%d", greTunnelsEndpoint, greTunnelID), &amp;greTunnels)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov6" title="2">service.Client.Logger.Printf("[DEBUG]returning gre tunnel from get: %d", greTunnels.ID)
        return &amp;greTunnels, nil</span>
}

// Gets specific provisioned GRE tunnel information by source IP address
func GetByIPAddress(service *services.Service, sourceIP string) (*GreTunnels, error) <span class="cov6" title="2">{
        var sourceIPs []GreTunnels
        err := common.ReadAllPages(service.Client, greTunnelsEndpoint, &amp;sourceIPs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="2">for _, source := range sourceIPs </span><span class="cov1" title="1">{
                if strings.EqualFold(source.SourceIP, sourceIP) </span><span class="cov1" title="1">{
                        return &amp;source, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("no device group found with name: %s", sourceIP)</span>
}

// Adds a GRE tunnel configuration.
func CreateGreTunnels(service *services.Service, greTunnelID *GreTunnels) (*GreTunnels, *http.Response, error) <span class="cov1" title="1">{
        resp, err := service.Client.Create(greTunnelsEndpoint, *greTunnelID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">createdGreTunnels, ok := resp.(*GreTunnels)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, errors.New("object returned from api was not a gre tunnel pointer")
        }</span>

        <span class="cov1" title="1">service.Client.Logger.Printf("[DEBUG]returning gre tunnels from create: %d", createdGreTunnels.ID)
        return createdGreTunnels, nil, nil</span>
}

func UpdateGreTunnels(service *services.Service, greTunnelID int, greTunnels *GreTunnels) (*GreTunnels, *http.Response, error) <span class="cov6" title="2">{
        resp, err := service.Client.UpdateWithPut(fmt.Sprintf("%s/%d", greTunnelsEndpoint, greTunnelID), *greTunnels)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">updatedGreTunnels, _ := resp.(*GreTunnels)

        service.Client.Logger.Printf("[DEBUG]returning gre tunnels from update: %d", updatedGreTunnels.ID)
        return updatedGreTunnels, nil, nil</span>
}

func DeleteGreTunnels(service *services.Service, greTunnelID int) (*http.Response, error) <span class="cov10" title="3">{
        err := service.Client.Delete(fmt.Sprintf("%s/%d", greTunnelsEndpoint, greTunnelID))
        if err != nil </span><span class="cov6" title="2">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return nil, nil</span>
}

func GetAll(service *services.Service) ([]GreTunnels, error) <span class="cov1" title="1">{
        var greTunnels []GreTunnels
        err := common.ReadAllPages(service.Client, greTunnelsEndpoint, &amp;greTunnels)
        return greTunnels, err
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package datacenter

import (
        "net/url"
        "strconv"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        vipGroupByDatacenterEndpoint = "/vips/groupByDatacenter"
)

type DatacenterVIPS struct {
        Datacenter struct {
                Name        string  `json:"datacenter"`
                Latitude    float64 `json:"latitude"`
                Longitude   float64 `json:"longitude"`
                City        string  `json:"city"`
                CountryCode string  `json:"countryCode"`
                Region      string  `json:"region"`
        } `json:"datacenter"`
        GreVIP []GreVIP `json:"greVips"`
}

type GreVIP struct {
        ID                 int    `json:"id,omitempty"`
        VirtualIp          string `json:"virtualIp,omitempty"`
        PrivateServiceEdge bool   `json:"privateServiceEdge,omitempty"`
        Datacenter         string `json:"datacenter,omitempty"`
}

func SearchByDatacenters(service *services.Service, params common.DatacenterSearchParameters) ([]DatacenterVIPS, error) <span class="cov10" title="7">{
        var zscalerVips []DatacenterVIPS
        var queryParams []string

        if params.RoutableIP </span><span class="cov8" title="5">{
                queryParams = append(queryParams, "routableIP=true")
        }</span>
        <span class="cov10" title="7">if params.WithinCountryOnly </span><span class="cov7" title="4">{
                queryParams = append(queryParams, "withinCountryOnly=true")
        }</span>
        <span class="cov10" title="7">if params.IncludePrivateServiceEdge </span><span class="cov6" title="3">{
                queryParams = append(queryParams, "includePrivateServiceEdge=true")
        }</span>
        <span class="cov10" title="7">if params.IncludeCurrentVips </span><span class="cov4" title="2">{
                queryParams = append(queryParams, "includeCurrentVips=true")
        }</span>
        <span class="cov10" title="7">if params.SourceIp != "" </span><span class="cov10" title="7">{
                queryParams = append(queryParams, "sourceIp="+url.QueryEscape(params.SourceIp))
        }</span>
        <span class="cov10" title="7">if params.Latitude != 0 </span><span class="cov4" title="2">{
                latitudeStr := strconv.FormatFloat(params.Latitude, 'f', -1, 64)
                queryParams = append(queryParams, "latitude="+latitudeStr)
        }</span>
        <span class="cov10" title="7">if params.Longitude != 0 </span><span class="cov4" title="2">{
                longitudeStr := strconv.FormatFloat(params.Longitude, 'f', -1, 64)
                queryParams = append(queryParams, "longitude="+longitudeStr)
        }</span>
        <span class="cov10" title="7">if params.Subcloud != "" </span><span class="cov0" title="0">{
                queryParams = append(queryParams, "subcloud="+url.QueryEscape(params.Subcloud))
        }</span>

        <span class="cov10" title="7">endpoint := vipGroupByDatacenterEndpoint
        if len(queryParams) &gt; 0 </span><span class="cov10" title="7">{
                endpoint += "?" + strings.Join(queryParams, "&amp;")
        }</span>

        <span class="cov10" title="7">err := common.ReadAllPages(service.Client, endpoint, &amp;zscalerVips)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="7">return zscalerVips, nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package geo_coordinates

import (
        "fmt"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
)

const (
        geoCoordinatesEndpoint = "/region/byGeoCoordinates"
)

type GeoCoordinates struct {
        // The geographical ID of the city
        CityGeoId int `json:"cityGeoId"`

        // The geographical ID of the state
        StateGeoId int `json:"stateGeoId"`

        // The latitude coordinate of the city
        Latitude float64 `json:"latitude"`

        // The longitude coordinate of the city
        Longitude float64 `json:"longitude"`

        // The name of the city
        CityName string `json:"cityName"`

        // The name of the state, province, or territory of a country
        StateName string `json:"stateName"`

        // The name of the country
        CountryName string `json:"countryName"`

        // The ISO standard two-letter country code
        CountryCode string `json:"countryCode"`

        // The postal code
        PostalCode string `json:"postalCode"`

        // The ISO standard two-letter continent code
        ContinentCode string `json:"continentCode"`
}

func GetByGeoCoordinates(service *services.Service, latitude, longitude float64) (*GeoCoordinates, error) <span class="cov8" title="1">{
        var region GeoCoordinates
        queryParams := fmt.Sprintf("latitude=%f&amp;longitude=%f", latitude, longitude)
        fullEndpoint := fmt.Sprintf("%s?%s", geoCoordinatesEndpoint, queryParams)

        err := service.Client.Read(fullEndpoint, &amp;region)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;region, nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package ip_address

import (
        "fmt"
        "net/url"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
)

const (
        byIPAdddressEndpoint = "/region/byIPAddress"
)

type ByIPAddress struct {
        // The geographical ID of the city
        CityGeoId int `json:"cityGeoId"`

        // The geographical ID of the state
        StateGeoId int `json:"stateGeoId"`

        // The latitude coordinate of the city
        Latitude float64 `json:"latitude"`

        // The longitude coordinate of the city
        Longitude float64 `json:"longitude"`

        // The name of the city
        CityName string `json:"cityName"`

        // The name of the state, province, or territory of a country
        StateName string `json:"stateName"`

        // The name of the country
        CountryName string `json:"countryName"`

        // The ISO standard two-letter country code
        CountryCode string `json:"countryCode"`

        // The postal code
        PostalCode string `json:"postalCode"`

        // The ISO standard two-letter continent code
        ContinentCode string `json:"continentCode"`
}

func GetByIPAddress(service *services.Service, ipAddress string) (*ByIPAddress, error) <span class="cov8" title="1">{
        var ip ByIPAddress
        err := service.Client.Read(fmt.Sprintf("%s/%s", byIPAdddressEndpoint, url.QueryEscape(ipAddress)), &amp;ip)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;ip, nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package region

import (
        "fmt"
        "net/url"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
)

const (
        regionSearchEndpoint = "/region/search"
)

type Regions struct {
        // The geographical ID of the city
        Datacenter int `json:"cityGeoId"`

        // The geographical ID of the state
        StateGeoId int `json:"stateGeoId"`

        // The latitude coordinate of the city
        Latitude float64 `json:"latitude"`

        // The longitude coordinate of the city
        Longitude float64 `json:"longitude"`

        // The name of the city
        CityName string `json:"cityName"`

        // The name of the state, province, or territory of a country
        StateName string `json:"stateName"`

        // The name of the country
        CountryName string `json:"countryName"`

        // The ISO standard two-letter country code
        CountryCode string `json:"countryCode"`

        // The postal code
        PostalCode string `json:"postalCode"`

        // The ISO standard two-letter continent code
        ContinentCode string `json:"continentCode"`
}

func GetDatacenterRegion(service *services.Service, regionPrefix string) ([]Regions, error) <span class="cov10" title="4">{
        var regions []Regions
        err := service.Client.Read(fmt.Sprintf("%s?prefix=%s", regionSearchEndpoint, url.QueryEscape(regionPrefix)), &amp;regions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="4">return regions, nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package staticips

import (
        "errors"
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        staticIPEndpoint = "/staticIP"
)

// Gets all provisioned static IP addresses.
type StaticIP struct {
        // The unique identifier for the static IP address
        ID int `json:"id,omitempty"`

        // The static IP address
        IpAddress string `json:"ipAddress"`

        // If not set, geographic coordinates and city are automatically determined from the IP address. Otherwise, the latitude and longitude coordinates must be provided.
        GeoOverride bool `json:"geoOverride"`

        // Required only if the geoOverride attribute is set. Latitude with 7 digit precision after decimal point, ranges between -90 and 90 degrees.
        Latitude float64 `json:"latitude,omitempty"`

        // Required only if the geoOverride attribute is set. Longitude with 7 digit precision after decimal point, ranges between -180 and 180 degrees.
        Longitude float64 `json:"longitude,omitempty"`

        // Indicates whether a non-RFC 1918 IP address is publicly routable. This attribute is ignored if there is no ZIA Private Service Edge associated to the organization.
        RoutableIP bool `json:"routableIP,omitempty"`

        City *City `json:"city,omitempty"`

        // When the static IP address was last modified
        LastModificationTime int `json:"lastModificationTime"`

        // Additional information about this static IP address
        Comment string `json:"comment,omitempty"`

        // SD-WAN Partner that manages the location. If a partner does not manage the location, this is set to Self.
        ManagedBy *ManagedBy `json:"managedBy,omitempty"` // Should probably move this to a common package. Used by multiple resources

        // Who modified the static IP address last
        LastModifiedBy *LastModifiedBy `json:"lastModifiedBy,omitempty"` // Should probably move this to a common package. Used by multiple resources
}

type ManagedBy struct {
        // Identifier that uniquely identifies an entity
        ID int `json:"id,omitempty"`

        // The configured name of the entity
        Name       string                 `json:"name,omitempty"`
        Extensions map[string]interface{} `json:"extensions,omitempty"`
}

type LastModifiedBy struct {
        // Identifier that uniquely identifies an entity
        ID int `json:"id,omitempty"`

        // The configured name of the entity
        Name       string                 `json:"name,omitempty"`
        Extensions map[string]interface{} `json:"extensions,omitempty"`
}

type City struct {
        // Identifier that uniquely identifies an entity
        ID int `json:"id,omitempty"`

        // The configured name of the entity
        Name string `json:"name,omitempty"`
}

func Get(service *services.Service, staticIpID int) (*StaticIP, error) <span class="cov10" title="4">{
        var staticIP StaticIP
        err := service.Client.Read(fmt.Sprintf("%s/%d", staticIPEndpoint, staticIpID), &amp;staticIP)
        if err != nil </span><span class="cov5" title="2">{
                return nil, err
        }</span>

        <span class="cov5" title="2">service.Client.Logger.Printf("[DEBUG]Returning static ip from Get: %d", staticIP.ID)
        return &amp;staticIP, nil</span>
}

func GetByIPAddress(service *services.Service, address string) (*StaticIP, error) <span class="cov5" title="2">{
        var staticIPs []StaticIP
        err := common.ReadAllPages(service.Client, staticIPEndpoint, &amp;staticIPs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="2">for _, static := range staticIPs </span><span class="cov10" title="4">{
                if strings.EqualFold(static.IpAddress, address) </span><span class="cov1" title="1">{
                        return &amp;static, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("no device group found with name: %s", address)</span>
}

func Create(service *services.Service, staticIpID *StaticIP) (*StaticIP, *http.Response, error) <span class="cov1" title="1">{
        resp, err := service.Client.Create(staticIPEndpoint, *staticIpID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">createdStaticIP, ok := resp.(*StaticIP)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, errors.New("object returned from api was not a static ip pointer")
        }</span>

        <span class="cov1" title="1">service.Client.Logger.Printf("[DEBUG]returning static ip from create: %d", createdStaticIP.ID)
        return createdStaticIP, nil, nil</span>
}

func Update(service *services.Service, staticIpID int, staticIP *StaticIP) (*StaticIP, *http.Response, error) <span class="cov5" title="2">{
        resp, err := service.Client.UpdateWithPut(fmt.Sprintf("%s/%d", staticIPEndpoint, staticIpID), *staticIP)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">updatedStaticIP, _ := resp.(*StaticIP)

        service.Client.Logger.Printf("[DEBUG]returning static ip from update: %d", updatedStaticIP.ID)
        return updatedStaticIP, nil, nil</span>
}

func Delete(service *services.Service, staticIpID int) (*http.Response, error) <span class="cov5" title="2">{
        err := service.Client.Delete(fmt.Sprintf("%s/%d", staticIPEndpoint, staticIpID))
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return nil, nil</span>
}

func GetAll(service *services.Service) ([]StaticIP, error) <span class="cov1" title="1">{
        var staticIPs []StaticIP
        err := common.ReadAllPages(service.Client, staticIPEndpoint, &amp;staticIPs)
        return staticIPs, err
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package virtualipaddress

import (
        "fmt"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/trafficforwarding/staticips"
)

const (
        vipsEndpoint               = "/vips"
        vipRecommendedListEndpoint = "/vips/recommendedList"
)

type ZscalerVIPs struct {
        CloudName     string   `json:"cloudName"`
        Region        string   `json:"region"`
        City          string   `json:"city"`
        DataCenter    string   `json:"dataCenter"`
        Location      string   `json:"location"`
        VPNIPs        []string `json:"vpnIps"`
        VPNDomainName string   `json:"vpnDomainName"`
        GREIPs        []string `json:"greIps"`
        GREDomainName string   `json:"greDomainName"`
        PACIPs        []string `json:"pacIps"`
        PACDomainName string   `json:"pacDomainName"`
}

type GREVirtualIPList struct {
        // Unique identifer of the GRE virtual IP address (VIP)
        ID int `json:"id"`

        // GRE cluster virtual IP address (VIP)
        VirtualIp string `json:"virtualIp,omitempty"`

        // Set to true if the virtual IP address (VIP) is a ZIA Private Service Edge
        PrivateServiceEdge bool `json:"privateServiceEdge,omitempty"`

        // Data center information
        DataCenter string `json:"dataCenter,omitempty"`

        // Country code information
        CountryCode string `json:"countryCode,omitempty"`

        City      string  `json:"city,omitempty"`
        Region    string  `json:"region,omitempty"`
        Latitude  float64 `json:"latitude"`
        Longitude float64 `json:"longitude"`
}

// Gets a paginated list of the virtual IP addresses (VIPs) available in the Zscaler cloud, including region and data center information. By default, the request gets all public VIPs in the cloud, but you can also include private or all VIPs in the request, if necessary.
func GetZscalerVIPs(service *services.Service, datacenter string) (*ZscalerVIPs, error) <span class="cov1" title="1">{
        var zscalerVips []ZscalerVIPs

        err := common.ReadAllPages(service.Client, vipsEndpoint, &amp;zscalerVips)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">for _, vips := range zscalerVips </span><span class="cov9" title="14">{
                if strings.EqualFold(vips.DataCenter, datacenter) </span><span class="cov1" title="1">{
                        return &amp;vips, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("no datacenter found with name: %s", datacenter)</span>
}

// Gets a paginated list of the virtual IP addresses (VIPs) available in the Zscaler cloud by sourceIP.
func GetZSGREVirtualIPList(service *services.Service, sourceIP string, count int) (*[]GREVirtualIPList, error) <span class="cov1" title="1">{
        var zscalerVips []GREVirtualIPList
        err := common.ReadAllPages(service.Client, fmt.Sprintf("%s?sourceIp=%s", vipRecommendedListEndpoint, sourceIP), &amp;zscalerVips)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">if len(zscalerVips) &lt; count </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not enough vips, got %d vips, required: %d", len(zscalerVips), count)
        }</span>
        <span class="cov1" title="1">return &amp;zscalerVips, nil</span>
}

// Gets a paginated list of the virtual IP addresses (VIPs) available in the Zscaler cloud by sourceIP within country.
func GetPairZSGREVirtualIPsWithinCountry(service *services.Service, sourceIP, countryCode string) (*[]GREVirtualIPList, error) <span class="cov1" title="1">{
        var zscalerVips []GREVirtualIPList
        err := common.ReadAllPages(service.Client, fmt.Sprintf("%s?sourceIp=%s&amp;withinCountryOnly=true", vipRecommendedListEndpoint, sourceIP), &amp;zscalerVips)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">var pairVips []GREVirtualIPList
        for _, vip := range zscalerVips </span><span class="cov10" title="15">{
                if strings.EqualFold(vip.CountryCode, countryCode) </span><span class="cov10" title="15">{
                        pairVips = append(pairVips, vip)
                }</span>
        }
        // If not enough VIPs in the specified country, add any VIPs until there are at least two.
        <span class="cov1" title="1">if len(pairVips) &lt; 2 </span><span class="cov0" title="0">{
                for _, vip := range zscalerVips </span><span class="cov0" title="0">{
                        if len(pairVips) &gt;= 2 </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">if !containsVIP(pairVips, vip) </span><span class="cov0" title="0">{
                                pairVips = append(pairVips, vip)
                        }</span>
                }
        }
        <span class="cov1" title="1">if len(pairVips) &lt; 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not enough vips, got %d vips, required: %d", len(pairVips), 2)
        }</span>
        <span class="cov1" title="1">return &amp;pairVips, nil</span>
}

// Helper function to check if a VIP is already in the list
func containsVIP(vips []GREVirtualIPList, vip GREVirtualIPList) bool <span class="cov0" title="0">{
        for _, v := range vips </span><span class="cov0" title="0">{
                if v.ID == vip.ID </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func GetAll(service *services.Service, sourceIP string) ([]GREVirtualIPList, error) <span class="cov4" title="3">{
        var zscalerVips []GREVirtualIPList
        err := common.ReadAllPages(service.Client, vipRecommendedListEndpoint+"?sourceIp="+sourceIP, &amp;zscalerVips)
        return zscalerVips, err
}</span>

func getAllStaticIPs(service *services.Service) ([]staticips.StaticIP, error) <span class="cov3" title="2">{
        var staticIPs []staticips.StaticIP
        err := common.ReadAllPages(service.Client, "/staticIP", &amp;staticIPs)
        return staticIPs, err
}</span>

// GetAllSourceIPs  gets all vips for all static ips
func GetAllSourceIPs(service *services.Service) ([]GREVirtualIPList, error) <span class="cov1" title="1">{
        var zscalerVips []GREVirtualIPList
        ips, err := getAllStaticIPs(service)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">for _, ip := range ips </span><span class="cov3" title="2">{
                list, err := GetAll(service, ip.IpAddress)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov3" title="2">zscalerVips = append(zscalerVips, list...)</span>
        }
        <span class="cov1" title="1">return zscalerVips, nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package vpncredentials

import (
        "errors"
        "fmt"
        "net/http"
        "net/url"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        vpnCredentialsEndpoint = "/vpnCredentials"
)

type VPNCredentials struct {
        // VPN credential id
        ID int `json:"id"`

        // VPN authentication type (i.e., how the VPN credential is sent to the server). It is not modifiable after VpnCredential is created.
        // Note: Zscaler no longer supports adding a new XAUTH VPN credential, but existing entries can be edited or deleted using the respective endpoints.
        Type string `json:"type,omitempty"`

        // Fully Qualified Domain Name. Applicable only to UFQDN or XAUTH (or HOSTED_MOBILE_USERS) auth type.
        FQDN string `json:"fqdn,omitempty"`

        // Static IP address for VPN that is self-provisioned or provisioned by Zscaler. This is a required field for IP auth type and is not applicable to other auth types.
        // Note: If you want Zscaler to provision static IP addresses for your organization, contact Zscaler Support.
        IPAddress string `json:"ipAddress,omitempty"`

        // Pre-shared key. This is a required field for UFQDN and IP auth type.
        PreSharedKey string `json:"preSharedKey,omitempty"`

        // Additional information about this VPN credential.
        Comments string `json:"comments,omitempty"`

        // Location that is associated to this VPN credential. Non-existence means not associated to any location.
        Location *Location `json:"location,omitempty"`

        // SD-WAN Partner that manages the location. If a partner does not manage the location, this is set to Self.
        ManagedBy *ManagedBy `json:"managedBy,omitempty"`
}

type Location struct {
        ID         int                    `json:"id"`
        Name       string                 `json:"name"`
        Extensions map[string]interface{} `json:"extensions,omitempty"`
}

type ManagedBy struct {
        ID         int                    `json:"id"`
        Name       string                 `json:"name"`
        Extensions map[string]interface{} `json:"extensions,omitempty"`
}

func Get(service *services.Service, vpnCredentialID int) (*VPNCredentials, error) <span class="cov10" title="4">{
        var vpnCredentials VPNCredentials
        err := service.Client.Read(fmt.Sprintf("%s/%d", vpnCredentialsEndpoint, vpnCredentialID), &amp;vpnCredentials)
        if err != nil </span><span class="cov5" title="2">{
                return nil, err
        }</span>

        <span class="cov5" title="2">service.Client.Logger.Printf("[DEBUG]Returning VPN Credentials from Get: %d", vpnCredentials.ID)
        return &amp;vpnCredentials, nil</span>
}

func GetVPNByType(service *services.Service, vpnType string) (*VPNCredentials, error) <span class="cov1" title="1">{
        var vpnTypes []VPNCredentials
        err := common.ReadAllPages(service.Client, fmt.Sprintf("%s?type=%s", vpnCredentialsEndpoint, url.QueryEscape(vpnType)), &amp;vpnTypes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">for _, vpn := range vpnTypes </span><span class="cov1" title="1">{
                if strings.EqualFold(vpn.Type, vpnType) </span><span class="cov1" title="1">{
                        return &amp;vpn, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("no VPN found with type: %s", vpnType)</span>
}

func GetByFQDN(service *services.Service, vpnCredentialName string) (*VPNCredentials, error) <span class="cov1" title="1">{
        var vpnCredentials []VPNCredentials

        err := common.ReadAllPages(service.Client, vpnCredentialsEndpoint, &amp;vpnCredentials)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">for _, vpnCredential := range vpnCredentials </span><span class="cov5" title="2">{
                if strings.EqualFold(vpnCredential.FQDN, vpnCredentialName) </span><span class="cov0" title="0">{
                        return &amp;vpnCredential, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("no vpn credentials found with fqdn: %s", vpnCredentialName)</span>
}

func GetByIP(service *services.Service, vpnCredentialIP string) (*VPNCredentials, error) <span class="cov0" title="0">{
        var vpnCredentials []VPNCredentials

        err := common.ReadAllPages(service.Client, vpnCredentialsEndpoint, &amp;vpnCredentials)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for _, vpnCredential := range vpnCredentials </span><span class="cov0" title="0">{
                if strings.EqualFold(vpnCredential.IPAddress, vpnCredentialIP) </span><span class="cov0" title="0">{
                        return &amp;vpnCredential, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("no vpn credentials found with ip: %s", vpnCredentialIP)</span>
}

func Create(service *services.Service, vpnCredentials *VPNCredentials) (*VPNCredentials, *http.Response, error) <span class="cov1" title="1">{
        resp, err := service.Client.Create(vpnCredentialsEndpoint, *vpnCredentials)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">createdVpnCredentials, ok := resp.(*VPNCredentials)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, errors.New("object returned from api was not a vpn credential pointer")
        }</span>

        <span class="cov1" title="1">service.Client.Logger.Printf("[DEBUG]returning vpn credential from create: %d", createdVpnCredentials.ID)
        return createdVpnCredentials, nil, nil</span>
}

func Update(service *services.Service, vpnCredentialID int, vpnCredentials *VPNCredentials) (*VPNCredentials, *http.Response, error) <span class="cov5" title="2">{
        resp, err := service.Client.UpdateWithPut(fmt.Sprintf("%s/%d", vpnCredentialsEndpoint, vpnCredentialID), *vpnCredentials)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">updatedVpnCredentials, _ := resp.(*VPNCredentials)

        service.Client.Logger.Printf("[DEBUG]returning vpn credential from Update: %d", updatedVpnCredentials.ID)
        return updatedVpnCredentials, nil, nil</span>
}

func Delete(service *services.Service, vpnCredentialID int) error <span class="cov5" title="2">{
        err := service.Client.Delete(fmt.Sprintf("%s/%d", vpnCredentialsEndpoint, vpnCredentialID))
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func GetAll(service *services.Service) ([]VPNCredentials, error) <span class="cov1" title="1">{
        var vpnTypes []VPNCredentials
        err := common.ReadAllPages(service.Client, vpnCredentialsEndpoint, &amp;vpnTypes)
        return vpnTypes, err
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package urlcategories

import (
        "errors"
        "fmt"
        "net/http"
        "net/url"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        urlCategoriesEndpoint = "/urlCategories"
)

type URLCategory struct {
        // URL category
        ID string `json:"id,omitempty"`

        // Name of the URL category. This is only required for custom URL categories.
        ConfiguredName string `json:"configuredName,omitempty"`

        // Custom keywords associated to a URL category. Up to 2048 custom keywords can be added per organization across all categories (including bandwidth classes).
        Keywords []string `json:"keywords"`

        // Retained custom keywords from the parent URL category that is associated to a URL category. Up to 2048 retained parent keywords can be added per organization across all categories (including bandwidth classes).
        KeywordsRetainingParentCategory []string `json:"keywordsRetainingParentCategory"`

        // Custom URLs to add to a URL category. Up to 25,000 custom URLs can be added per organization across all categories (including bandwidth classes).
        Urls []string `json:"urls"`

        // URLs added to a custom URL category are also retained under the original parent URL category (i.e., the predefined category the URL previously belonged to). The URLs entered are covered by policies that reference the original parent URL category as well as those that reference the custom URL category. For example, if you add www.amazon.com, this URL is covered by policies that reference the custom URL category as well as policies that reference its parent URL category of "Online Shopping".
        DBCategorizedUrls []string `json:"dbCategorizedUrls"`

        //
        CustomCategory bool `json:"customCategory"`

        // Scope of the custom categories.
        Scopes []Scopes `json:"scopes,omitempty"`

        // Value is set to false for custom URL category when due to scope user does not have edit permission
        Editable bool `json:"editable"`

        // Description of the URL category. Contains tag name and needs to be localized on client side in case of predefined category (customCategory=null or =false), else it contains the user-entered description which does not have localization support.
        Description string `json:"description,omitempty"`

        // Type of the custom categories.
        Type string `json:"type,omitempty"`

        // URL and keyword counts for the URL category.
        URLKeywordCounts *URLKeywordCounts `json:"urlKeywordCounts,omitempty"`
        Val              int               `json:"val,omitempty"`

        // The number of custom URLs associated to the URL category.
        CustomUrlsCount int `json:"customUrlsCount,omitempty"`

        // Super Category of the URL category. This field is required when creating custom URL categories.
        SuperCategory string `json:"superCategory,omitempty"`

        // The number of custom URLs associated to the URL category, that also need to be retained under the original parent category.
        UrlsRetainingParentCategoryCount int `json:"urlsRetainingParentCategoryCount"`

        // Custom IP address ranges associated to a URL category. Up to 2000 custom IP address ranges and retaining parent custom IP address ranges can be added, per organization, across all categories.
        IPRanges []string `json:"ipRanges"`

        // The retaining parent custom IP address ranges associated to a URL category. Up to 2000 custom IP ranges and retaining parent custom IP address ranges can be added, per organization, across all categories.
        IPRangesRetainingParentCategory []string `json:"ipRangesRetainingParentCategory"`

        // The number of custom IP address ranges associated to the URL category.
        CustomIpRangesCount int `json:"customIpRangesCount"`

        // The number of custom IP address ranges associated to the URL category, that also need to be retained under the original parent category.
        IPRangesRetainingParentCategoryCount int `json:"ipRangesRetainingParentCategoryCount"`
}

type Scopes struct {
        // Only applicable for the LOCATION_GROUP admin scope type, in which case this attribute gives the list of ID/name pairs of locations within the location group. The attribute name is subject to change.
        ScopeGroupMemberEntities []common.IDNameExtensions `json:"scopeGroupMemberEntities,omitempty"`

        // The admin scope type. The attribute name is subject to change.
        Type string `json:"Type,omitempty"`

        // Based on the admin scope type, the entities can be the ID/name pair of departments, locations, or location groups. The attribute name is subject to change.
        ScopeEntities []common.IDNameExtensions `json:"ScopeEntities,omitempty"`
}

type URLKeywordCounts struct {
        // Custom URL count for the category.
        TotalURLCount int `json:"totalUrlCount,omitempty"`

        // Count of URLs with retain parent category.
        RetainParentURLCount int `json:"retainParentUrlCount,omitempty"`

        // Total keyword count for the category.
        TotalKeywordCount int `json:"totalKeywordCount,omitempty"`

        // Count of total keywords with retain parent category.
        RetainParentKeywordCount int `json:"retainParentKeywordCount,omitempty"`
}

func Get(service *services.Service, categoryID string) (*URLCategory, error) <span class="cov10" title="3">{
        var urlCategory URLCategory
        err := service.Client.Read(fmt.Sprintf("%s/%s", urlCategoriesEndpoint, categoryID), &amp;urlCategory)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov6" title="2">service.Client.Logger.Printf("[DEBUG]Returning custom url category from Get: %s", urlCategory.ID)
        return &amp;urlCategory, nil</span>
}

func GetCustomURLCategories(service *services.Service, customName string, includeOnlyUrlKeywordCounts, customOnly bool) (*URLCategory, error) <span class="cov1" title="1">{
        var urlCategory []URLCategory
        queryParams := url.Values{}

        if includeOnlyUrlKeywordCounts </span><span class="cov1" title="1">{
                queryParams.Set("includeOnlyUrlKeywordCounts", "false")
        }</span>
        <span class="cov1" title="1">if customOnly </span><span class="cov1" title="1">{
                queryParams.Set("customOnly", "true")
        }</span>

        <span class="cov1" title="1">err := service.Client.Read(fmt.Sprintf("%s?%s", urlCategoriesEndpoint, queryParams.Encode()), &amp;urlCategory)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">for _, custom := range urlCategory </span><span class="cov6" title="2">{
                if strings.EqualFold(custom.ConfiguredName, customName) </span><span class="cov1" title="1">{
                        return &amp;custom, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("no custom url category found with name: %s", customName)</span>
}

func CreateURLCategories(service *services.Service, category *URLCategory) (*URLCategory, error) <span class="cov1" title="1">{
        resp, err := service.Client.Create(urlCategoriesEndpoint, *category)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">createdUrlCategory, ok := resp.(*URLCategory)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("object returned from API was not a url category Pointer")
        }</span>

        <span class="cov1" title="1">service.Client.Logger.Printf("[DEBUG]Returning url category from Create: %v", createdUrlCategory.ID)
        return createdUrlCategory, nil</span>
}

func UpdateURLCategories(service *services.Service, categoryID string, category *URLCategory) (*URLCategory, *http.Response, error) <span class="cov1" title="1">{
        resp, err := service.Client.UpdateWithPut(fmt.Sprintf("%s/%s", urlCategoriesEndpoint, categoryID), *category)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">updatedUrlCategory, _ := resp.(*URLCategory)
        service.Client.Logger.Printf("[DEBUG]Returning url category from Update: %s", updatedUrlCategory.ID)
        return updatedUrlCategory, nil, nil</span>
}

func DeleteURLCategories(service *services.Service, categoryID string) (*http.Response, error) <span class="cov1" title="1">{
        err := service.Client.Delete(fmt.Sprintf("%s/%s", urlCategoriesEndpoint, categoryID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return nil, nil</span>
}

func GetAll(service *services.Service) ([]URLCategory, error) <span class="cov1" title="1">{
        var urlCategories []URLCategory
        err := common.ReadAllPages(service.Client, urlCategoriesEndpoint, &amp;urlCategories)
        return urlCategories, err
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package urlfilteringpolicies

import (
        "errors"
        "fmt"
        "net/http"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        urlFilteringPoliciesEndpoint = "/urlFilteringRules"
)

type URLFilteringRule struct {
        // URL Filtering Rule ID
        ID int `json:"id,omitempty"`

        // Rule Name
        Name string `json:"name,omitempty"`

        // Order of execution of rule with respect to other URL Filtering rules
        Order int `json:"order,omitempty"`

        // Protocol criteria
        Protocols []string `json:"protocols,omitempty"`

        // List of URL categories for which rule must be applied
        URLCategories []string `json:"urlCategories"`

        UserRiskScoreLevels []string `json:"userRiskScoreLevels,omitempty"`

        // Rule State
        State string `json:"state,omitempty"`

        UserAgentTypes []string `json:"userAgentTypes,omitempty"`

        // Admin rank of the admin who creates this rule
        Rank int `json:"rank,omitempty"`

        // Request method for which the rule must be applied. If not set, rule is applied to all methods
        RequestMethods []string `json:"requestMethods,omitempty"`

        // URL of end user notification page to be displayed when the rule is matched. Not applicable if either 'overrideUsers' or 'overrideGroups' is specified.
        EndUserNotificationURL string `json:"endUserNotificationUrl,omitempty"`

        // When set to true, a 'BLOCK' action triggered by the rule could be overridden. If true and both overrideGroup and overrideUsers are not set, the BLOCK triggered by this rule could be overridden for any users. If blockOverride is not set, 'BLOCK' action cannot be overridden.
        BlockOverride bool `json:"blockOverride,omitempty"`

        // Time quota in minutes, after which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule action is set to 'BLOCK', this field is not applicable.
        TimeQuota int `json:"timeQuota,omitempty"`

        // Size quota in KB beyond which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule action is set to 'BLOCK', this field is not applicable.
        SizeQuota int `json:"sizeQuota,omitempty"`

        // Additional information about the URL Filtering rule
        Description string `json:"description,omitempty"`

        // If enforceTimeValidity is set to true, the URL Filtering rule is valid starting on this date and time.
        ValidityStartTime int `json:"validityStartTime,omitempty"`

        // If enforceTimeValidity is set to true, the URL Filtering rule ceases to be valid on this end date and time.
        ValidityEndTime int `json:"validityEndTime,omitempty"`

        // If enforceTimeValidity is set to true, the URL Filtering rule date and time is valid based on this time zone ID.
        ValidityTimeZoneID string `json:"validityTimeZoneId,omitempty"`

        // When the rule was last modified
        LastModifiedTime int `json:"lastModifiedTime,omitempty"`

        // Enforce a set a validity time period for the URL Filtering rule. To learn more, see Configuring the URL Filtering Policy.
        EnforceTimeValidity bool `json:"enforceTimeValidity,omitempty"`

        // Action taken when traffic matches rule criteria
        Action string `json:"action,omitempty"`

        // If set to true, the CIPA Compliance rule is enabled
        Ciparule bool `json:"ciparule,omitempty"`

        // List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation.
        DeviceTrustLevels []string `json:"deviceTrustLevels,omitempty"`

        // This field is applicable for devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
        DeviceGroups []common.IDNameExtensions `json:"deviceGroups"`

        // Name-ID pairs of devices for which rule must be applied. Specifies devices that are managed using Zscaler Client Connector. If no value is set, this field is ignored during the policy evaluation.
        Devices []common.IDNameExtensions `json:"devices"`

        // Who modified the rule last
        LastModifiedBy *common.IDNameExtensions `json:"lastModifiedBy,omitempty"`

        // Name-ID pairs of users for which this rule can be overridden. Applicable only if blockOverride is set to 'true', action is 'BLOCK' and overrideGroups is not set.If this overrideUsers is not set, 'BLOCK' action can be overridden for any user.
        OverrideUsers []common.IDNameExtensions `json:"overrideUsers,omitempty"`

        // Name-ID pairs of groups for which this rule can be overridden. Applicable only if blockOverride is set to 'true' and action is 'BLOCK'. If this overrideGroups is not set, 'BLOCK' action can be overridden for any group.
        OverrideGroups []common.IDNameExtensions `json:"overrideGroups,omitempty"`

        // Name-ID pairs of the location groups to which the rule must be applied.
        LocationGroups []common.IDNameExtensions `json:"locationGroups,omitempty"`

        // The URL Filtering rule's label. Rule labels allow you to logically group your organization's policy rules. Policy rules that are not associated with a rule label are grouped under the Untagged label.
        Labels []common.IDNameExtensions `json:"labels,omitempty"`

        // Name-ID pairs of locations for which rule must be applied
        Locations []common.IDNameExtensions `json:"locations,omitempty"`

        // Name-ID pairs of groups for which rule must be applied
        Groups []common.IDNameExtensions `json:"groups,omitempty"`

        // Name-ID pairs of departments for which rule must be applied
        Departments []common.IDNameExtensions `json:"departments,omitempty"`

        // Name-ID pairs of users for which rule must be applied
        Users []common.IDNameExtensions `json:"users,omitempty"`

        // Source IP address groups for which the rule is applicable.
        // If not set, the rule is not restricted to a specific source IP address group.
        SourceIPGroups []common.IDNameExtensions `json:"sourceIpGroups,omitempty"`

        // Name-ID pairs of time interval during which rule must be enforced.
        TimeWindows []common.IDNameExtensions `json:"timeWindows,omitempty"`

        // The list of preconfigured workload groups to which the policy must be applied.
        WorkloadGroups []common.IDName `json:"workloadGroups,omitempty"`

        // The cloud browser isolation profile to which the ISOLATE action is applied in the URL Filtering Policy rules.
        // Note: This parameter is required for the ISOLATE action and is not applicable to other actions.
        CBIProfile   CBIProfile `json:"cbiProfile"`
        CBIProfileID int        `json:"cbiProfileId"`
}

type CBIProfile struct {
        ProfileSeq int `json:"profileSeq"`
        // The universally unique identifier (UUID) for the browser isolation profile
        ID string `json:"id"`

        // Name of the browser isolation profile
        Name string `json:"name"`

        // The browser isolation profile URL
        URL string `json:"url"`

        // (Optional) Indicates whether this is a default browser isolation profile. Zscaler sets this field.
        DefaultProfile bool `json:"defaultProfile"`
}

func Get(service *services.Service, ruleID int) (*URLFilteringRule, error) <span class="cov10" title="5">{
        var urlFilteringPolicies URLFilteringRule
        err := service.Client.Read(fmt.Sprintf("%s/%d", urlFilteringPoliciesEndpoint, ruleID), &amp;urlFilteringPolicies)
        if err != nil </span><span class="cov4" title="2">{
                return nil, err
        }</span>

        <span class="cov7" title="3">service.Client.Logger.Printf("[DEBUG]Returning url filtering rules from Get: %d", urlFilteringPolicies.ID)
        return &amp;urlFilteringPolicies, nil</span>
}

func GetByName(service *services.Service, urlFilteringPolicyName string) (*URLFilteringRule, error) <span class="cov4" title="2">{
        var urlFilteringPolicies []URLFilteringRule
        err := common.ReadAllPages(service.Client, urlFilteringPoliciesEndpoint, &amp;urlFilteringPolicies)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="2">for _, urlFilteringPolicy := range urlFilteringPolicies </span><span class="cov1" title="1">{
                if strings.EqualFold(urlFilteringPolicy.Name, urlFilteringPolicyName) </span><span class="cov1" title="1">{
                        return &amp;urlFilteringPolicy, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("no url filtering rule found with name: %s", urlFilteringPolicyName)</span>
}

func Create(service *services.Service, ruleID *URLFilteringRule) (*URLFilteringRule, error) <span class="cov1" title="1">{
        resp, err := service.Client.Create(urlFilteringPoliciesEndpoint, *ruleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">createdURLFilteringRule, ok := resp.(*URLFilteringRule)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("object returned from api was not a url filtering rule pointer")
        }</span>

        <span class="cov1" title="1">service.Client.Logger.Printf("[DEBUG]returning url filtering rule from create: %d", createdURLFilteringRule.ID)
        return createdURLFilteringRule, nil</span>
}

func Update(service *services.Service, ruleID int, rule *URLFilteringRule) (*URLFilteringRule, *http.Response, error) <span class="cov4" title="2">{
        // Add debug log to print the rule object
        service.Client.Logger.Printf("[DEBUG] Updating URL Filtering Rule with ID %d: %+v", ruleID, rule)
        if rule.CBIProfile.ID == "" || rule.CBIProfileID == 0 </span><span class="cov4" title="2">{
                // If CBIProfile object is empty, fetch it using GetByName as Get by ID is not currently returnign the full CBIProfile object with the uuid ID
                var urlFilteringPolicies []URLFilteringRule
                err := common.ReadAllPages(service.Client, urlFilteringPoliciesEndpoint, &amp;urlFilteringPolicies)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov4" title="2">for _, urlFilteringPolicy := range urlFilteringPolicies </span><span class="cov1" title="1">{
                        if urlFilteringPolicy.ID == ruleID </span><span class="cov1" title="1">{
                                rule.CBIProfile = urlFilteringPolicy.CBIProfile
                                rule.CBIProfileID = urlFilteringPolicy.CBIProfileID
                        }</span>
                }
        }
        <span class="cov4" title="2">resp, err := service.Client.UpdateWithPut(fmt.Sprintf("%s/%d", urlFilteringPoliciesEndpoint, ruleID), *rule)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">updatedURLFilteringRule, _ := resp.(*URLFilteringRule)

        service.Client.Logger.Printf("[DEBUG] returning URL filtering rule from update: %d", updatedURLFilteringRule.ID)
        return updatedURLFilteringRule, nil, nil</span>
}

func Delete(service *services.Service, ruleID int) (*http.Response, error) <span class="cov4" title="2">{
        err := service.Client.Delete(fmt.Sprintf("%s/%d", urlFilteringPoliciesEndpoint, ruleID))
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return nil, nil</span>
}

// GetAll returns the all rules.
func GetAll(service *services.Service) ([]URLFilteringRule, error) <span class="cov1" title="1">{
        var urlFilteringPolicies []URLFilteringRule
        err := common.ReadAllPages(service.Client, urlFilteringPoliciesEndpoint, &amp;urlFilteringPolicies)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return urlFilteringPolicies, nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package user_authentication_settings

import (
        "fmt"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
)

const (
        exemptedUrlsEndpoint = "/authSettings/exemptedUrls"
)

type ExemptedUrls struct {
        // Domains or URLs which are exempted from SSL Inspection
        URLs []string `json:"urls"`
}

type QueryParameters struct {
        ID string
}

func Get(service *services.Service) (*ExemptedUrls, error) <span class="cov9" title="5">{
        var urls ExemptedUrls
        err := service.Client.Read(exemptedUrlsEndpoint, &amp;urls)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov9" title="5">service.Client.Logger.Printf("[DEBUG]Returning exempted url rules from Get: %v", urls)
        return &amp;urls, nil</span>
}

// return the new items that were added to slice1.
func difference(slice1 []string, slice2 []string) []string <span class="cov7" title="4">{
        var diff []string
        for _, s1 := range slice1 </span><span class="cov10" title="6">{
                found := false
                for _, s2 := range slice2 </span><span class="cov0" title="0">{
                        if s1 == s2 </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov10" title="6">if !found </span><span class="cov10" title="6">{
                        diff = append(diff, s1)
                }</span>
        }
        <span class="cov7" title="4">return diff</span>
}

func Update(service *services.Service, urls ExemptedUrls) (*ExemptedUrls, error) <span class="cov4" title="2">{
        currentUrsl, err := Get(service)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="2">newUrls := difference(urls.URLs, currentUrsl.URLs)
        removedUrls := difference(currentUrsl.URLs, urls.URLs)
        if len(newUrls) &gt; 0 </span><span class="cov1" title="1">{
                _, err := service.Client.Create(fmt.Sprintf("%s?action=ADD_TO_LIST", exemptedUrlsEndpoint), ExemptedUrls{newUrls})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov4" title="2">if len(removedUrls) &gt; 0 </span><span class="cov1" title="1">{
                _, err := service.Client.Create(fmt.Sprintf("%s?action=REMOVE_FROM_LIST", exemptedUrlsEndpoint), ExemptedUrls{removedUrls})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov4" title="2">return &amp;urls, nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package departments

import (
        "fmt"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        departmentEndpoint = "/departments"
)

type Department struct {
        // Department ID
        ID int `json:"id"`

        // Department name
        Name string `json:"name,omitempty"`

        // Identity provider (IdP) ID
        IdpID int `json:"idpId"`

        // Additional information about this department
        Comments string `json:"comments,omitempty"`
        Deleted  bool   `json:"deleted"`
}

func (service *Service) GetDepartments(departmentID int) (*Department, error) <span class="cov1" title="1">{
        var departments Department
        err := service.Client.Read(fmt.Sprintf("%s/%d", departmentEndpoint, departmentID), &amp;departments)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">service.Client.Logger.Printf("[DEBUG]Returning departments from Get: %d", departments.ID)
        return &amp;departments, nil</span>
}

func (service *Service) GetDepartmentsByName(departmentName string) (*Department, error) <span class="cov3" title="5">{
        var departments []Department
        err := common.ReadAllPages(service.Client, departmentEndpoint+"?"+common.GetSortParams(service.sortBy, service.sortOrder), &amp;departments)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="5">for _, department := range departments </span><span class="cov10" title="179">{
                if strings.EqualFold(department.Name, departmentName) </span><span class="cov3" title="4">{
                        return &amp;department, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("no department found with name: %s", departmentName)</span>
}

func (service *Service) GetAll() ([]Department, error) <span class="cov2" title="3">{
        var departments []Department
        err := common.ReadAllPages(service.Client, departmentEndpoint+"?"+common.GetSortParams(service.sortBy, service.sortOrder), &amp;departments)
        return departments, err
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package departments

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zia"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

type Service struct {
        Client    *zia.Client
        sortOrder common.SortOrder
        sortBy    common.SortField
}

func New(c *zia.Client) *Service <span class="cov10" title="4">{
        return &amp;Service{
                Client:    c,
                sortOrder: common.ASCSortOrder,
                sortBy:    common.NameSortField,
        }
}</span>

func (service *Service) WithSort(sortBy common.SortField, sortOrder common.SortOrder) *Service <span class="cov0" title="0">{
        c := Service{
                Client:    service.Client,
                sortOrder: service.sortOrder,
                sortBy:    service.sortBy,
        }
        if sortBy == common.IDSortField || sortBy == common.NameSortField || sortBy == common.CreationTimeSortField || sortBy == common.ModifiedTimeSortField </span><span class="cov0" title="0">{
                c.sortBy = sortBy
        }</span>

        <span class="cov0" title="0">if sortOrder == common.ASCSortOrder || sortOrder == common.DESCSortOrder </span><span class="cov0" title="0">{
                c.sortOrder = sortOrder
        }</span>
        <span class="cov0" title="0">return &amp;c</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package groups

import (
        "fmt"
        "net/url"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        groupsEndpoint = "/groups"
)

type Groups struct {
        // Unique identfier for the group
        ID int `json:"id"`

        // Group name
        Name string `json:"name,omitempty"`

        // Unique identfier for the identity provider (IdP)
        IdpID int `json:"idpId"`

        // Additional information about the group
        Comments string `json:"comments,omitempty"`
}

func (service *Service) GetGroups(groupID int) (*Groups, error) <span class="cov1" title="1">{
        var groups Groups
        err := service.Client.Read(fmt.Sprintf("%s/%d", groupsEndpoint, groupID), &amp;groups)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">service.Client.Logger.Printf("[DEBUG]Returning Groups from Get: %d", groups.ID)
        return &amp;groups, nil</span>
}

func (service *Service) GetGroupByName(targetGroup string) (*Groups, error) <span class="cov10" title="5">{
        var groups []Groups
        page := 1

        // Construct the endpoint with the search parameter
        endpointWithSearch := fmt.Sprintf("%s?search=%s&amp;%s", groupsEndpoint, url.QueryEscape(targetGroup), common.GetSortParams(service.sortBy, service.sortOrder))

        for </span><span class="cov10" title="5">{
                err := common.ReadPage(service.Client, endpointWithSearch, page, &amp;groups)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Iterate over the groups and check if the name matches the targetGroup
                <span class="cov10" title="5">for _, group := range groups </span><span class="cov8" title="4">{
                        if strings.EqualFold(group.Name, targetGroup) </span><span class="cov8" title="4">{
                                return &amp;group, nil
                        }</span>
                }

                // Break the loop if there are no more pages
                <span class="cov1" title="1">if len(groups) &lt; common.GetPageSize() </span><span class="cov1" title="1">{
                        break</span>
                }
                <span class="cov0" title="0">page++</span>
        }

        <span class="cov1" title="1">return nil, fmt.Errorf("no group found with name: %s", targetGroup)</span>
}

func (service *Service) GetAllGroups() ([]Groups, error) <span class="cov7" title="3">{
        var groups []Groups
        err := common.ReadAllPages(service.Client, groupsEndpoint+"?"+common.GetSortParams(service.sortBy, service.sortOrder), &amp;groups)
        return groups, err
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package groups

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zia"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

type Service struct {
        Client    *zia.Client
        sortOrder common.SortOrder
        sortBy    common.SortField
}

func New(c *zia.Client) *Service <span class="cov10" title="4">{
        return &amp;Service{
                Client:    c,
                sortOrder: common.ASCSortOrder,
                sortBy:    common.NameSortField,
        }
}</span>

func (service *Service) WithSort(sortBy common.SortField, sortOrder common.SortOrder) *Service <span class="cov0" title="0">{
        c := Service{
                Client:    service.Client,
                sortOrder: service.sortOrder,
                sortBy:    service.sortBy,
        }
        if sortBy == common.IDSortField || sortBy == common.NameSortField || sortBy == common.CreationTimeSortField || sortBy == common.ModifiedTimeSortField </span><span class="cov0" title="0">{
                c.sortBy = sortBy
        }</span>

        <span class="cov0" title="0">if sortOrder == common.ASCSortOrder || sortOrder == common.DESCSortOrder </span><span class="cov0" title="0">{
                c.sortOrder = sortOrder
        }</span>
        <span class="cov0" title="0">return &amp;c</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package users

import (
        "github.com/zscaler/zscaler-sdk-go/v2/zia"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

type Service struct {
        Client    *zia.Client
        sortOrder common.SortOrder
        sortBy    common.SortField
}

func New(c *zia.Client) *Service <span class="cov10" title="5">{
        return &amp;Service{
                Client:    c,
                sortOrder: common.ASCSortOrder,
                sortBy:    common.NameSortField,
        }
}</span>

func (service *Service) WithSort(sortBy common.SortField, sortOrder common.SortOrder) *Service <span class="cov0" title="0">{
        c := Service{
                Client:    service.Client,
                sortOrder: service.sortOrder,
                sortBy:    service.sortBy,
        }
        if sortBy == common.IDSortField || sortBy == common.NameSortField || sortBy == common.CreationTimeSortField || sortBy == common.ModifiedTimeSortField </span><span class="cov0" title="0">{
                c.sortBy = sortBy
        }</span>

        <span class="cov0" title="0">if sortOrder == common.ASCSortOrder || sortOrder == common.DESCSortOrder </span><span class="cov0" title="0">{
                c.sortOrder = sortOrder
        }</span>
        <span class="cov0" title="0">return &amp;c</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package users

import (
        "errors"
        "fmt"
        "net/http"
        "net/url"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        usersEndpoint  = "/users"
        enrollEndpoint = "/enroll"
)

type Users struct {
        // User ID
        ID int `json:"id"`

        // User name. This appears when choosing users for policies.
        Name string `json:"name,omitempty"`

        // User email consists of a user name and domain name. It does not have to be a valid email address, but it must be unique and its domain must belong to the organization.
        Email string `json:"email,omitempty"`

        // List of Groups a user belongs to. Groups are used in policies.
        Groups []common.IDNameExtensions `json:"groups,omitempty"`

        // Department a user belongs to
        Department *common.UserDepartment `json:"department,omitempty"`

        // Additional information about this user.
        Comments string `json:"comments,omitempty"`

        // Temporary Authentication Email. If you enabled one-time tokens or links, enter the email address to which the Zscaler service sends the tokens or links. If this is empty, the service sends the email to the User email.
        TempAuthEmail string `json:"tempAuthEmail,omitempty"`

        // Accepted Authentication Methods. Support values are "BASIC" and "DIGEST"
        AuthMethods []string `json:"authMethods,omitempty"`

        // User's password. Applicable only when authentication type is Hosted DB. Password strength must follow what is defined in the auth settings.
        Password string `json:"password,omitempty"`

        // True if this user is an Admin user
        AdminUser bool `json:"adminUser"`

        // User type. Provided only if this user is not an end user.
        Type string `json:"type,omitempty"`

        Deleted bool `json:"deleted"`
}

type EnrollResult struct {
        UserID int `json:"userId"`
}

type EnrollUserRequest struct {
        AuthMethods []string `json:"authMethods"`
        Password    string   `json:"password"`
}

func (service *Service) Get(userID int) (*Users, error) <span class="cov10" title="4">{
        var user Users
        err := service.Client.Read(fmt.Sprintf("%s/%d", usersEndpoint, userID), &amp;user)
        if err != nil </span><span class="cov5" title="2">{
                return nil, err
        }</span>

        <span class="cov5" title="2">service.Client.Logger.Printf("[DEBUG]returning user from Get: %d", user.ID)
        return &amp;user, nil</span>
}

func (service *Service) GetUserByName(userName string) (*Users, error) <span class="cov5" title="2">{
        var users []Users
        err := service.Client.Read(fmt.Sprintf("%s?name=%s&amp;%s", usersEndpoint, url.QueryEscape(userName), common.GetSortParams(service.sortBy, service.sortOrder)), &amp;users)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="2">for _, user := range users </span><span class="cov1" title="1">{
                if strings.EqualFold(user.Name, userName) </span><span class="cov1" title="1">{
                        return &amp;user, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("no user found with name: %s", userName)</span>
}

func (service *Service) EnrollUser(userID int, request EnrollUserRequest) (*EnrollResult, error) <span class="cov0" title="0">{
        if len(request.AuthMethods) == 0 </span><span class="cov0" title="0">{
                err := errors.New("authMethods is required")
                service.Client.Logger.Printf("[ERROR] enroll user failed: %v", err)
        }</span>
        <span class="cov0" title="0">for _, method := range request.AuthMethods </span><span class="cov0" title="0">{
                // method most be one of the following: BASIC, DIGEST
                if method != "BASIC" &amp;&amp; method != "DIGEST" </span><span class="cov0" title="0">{
                        err := fmt.Errorf("authMethods must be one of the following: BASIC, DIGEST. Found: %s", method)
                        service.Client.Logger.Printf("[ERROR] enroll user failed: %v", err)
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">_, err := service.Client.Create(fmt.Sprintf("%s/%d%s", usersEndpoint, userID, enrollEndpoint), request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;EnrollResult{UserID: userID}, nil</span>
}

func (service *Service) Create(user *Users) (*Users, error) <span class="cov1" title="1">{
        resp, err := service.Client.Create(usersEndpoint, *user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">createdUsers, ok := resp.(*Users)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("object returned from api was not a user pointer")
        }</span>

        <span class="cov1" title="1">service.Client.Logger.Printf("[DEBUG]returning user from create: %v", createdUsers.ID)
        return createdUsers, nil</span>
}

func (service *Service) Update(userID int, users *Users) (*Users, *http.Response, error) <span class="cov5" title="2">{
        resp, err := service.Client.UpdateWithPut(fmt.Sprintf("%s/%d", usersEndpoint, userID), *users)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov1" title="1">updatedUser, _ := resp.(*Users)
        service.Client.Logger.Printf("[DEBUG]returning user from update: %d", updatedUser.ID)
        return updatedUser, nil, nil</span>
}

func (service *Service) Delete(userID int) (*http.Response, error) <span class="cov5" title="2">{
        err := service.Client.Delete(fmt.Sprintf("%s/%d", usersEndpoint, userID))
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return nil, nil</span>
}

func (service *Service) GetAllUsers() ([]Users, error) <span class="cov1" title="1">{
        var users []Users
        err := common.ReadAllPages(service.Client, usersEndpoint+"?"+common.GetSortParams(service.sortBy, service.sortOrder), &amp;users)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return users, nil</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package workloadgroups

import (
        "fmt"
        "strings"

        "github.com/zscaler/zscaler-sdk-go/v2/zia/services"
        "github.com/zscaler/zscaler-sdk-go/v2/zia/services/common"
)

const (
        workloadGroupsEndpoint = "/workloadGroups"
)

type WorkloadGroup struct {
        // A unique identifier assigned to the workload group
        ID int `json:"id"`

        // The name of the workload group
        Name string `json:"name,omitempty"`

        // The description of the workload group
        Description string `json:"description,omitempty"`

        // The workload group expression containing tag types, tags, and their relationships.
        Expression string `json:"expression,omitempty"`

        // Timestamp when the workload group was last modified
        LastModifiedTime int `json:"lastModifiedTime,omitempty"`

        // Information about the admin that last modified the workload group
        LastModifiedBy *common.IDNameExtensions `json:"lastModifiedBy,omitempty"`

        WorkloadTagExpression WorkloadTagExpression `json:"expressionJson,omitempty"`
}

// The workload group expression containing tag types, tags, and their relationships represented in a JSON format.
type WorkloadTagExpression struct {
        ExpressionContainers []ExpressionContainer `json:"expressionContainers"`
}

type ExpressionContainer struct {
        // The tag type selected from a predefined list
        TagType string `json:"tagType,omitempty"`

        // The operator (either AND or OR) used to create logical relationships among tag types
        Operator string `json:"operator,omitempty"`

        // Contains one or more tags and the logical operator used to combine the tags within a tag type
        TagContainer TagContainer `json:"tagContainer"`
}

type TagContainer struct {
        //One or more tags, each consisting of a key-value pair, selected within a tag type.
        // If multiple tags are present within a tag type, they are combined using a logical operator.
        // Note: A maximum of 8 tags can be added to a workload group, irrespective of the number of tag types present.
        Tags []Tags `json:"tags"`

        // The logical operator (either AND or OR) used to combine the tags within a tag type
        Operator string `json:"operator,omitempty"`
}

// The list of tags (key-value pairs) selected within a tag type
type Tags struct {
        // The key component present in the key-value pair contained in a tag
        Key string `json:"key,omitempty"`
        // The value component present in the key-value pair contained in a tag
        Value string `json:"value,omitempty"`
}

func Get(service *services.Service, workloadID int) (*WorkloadGroup, error) <span class="cov0" title="0">{
        var workloadGroup WorkloadGroup
        err := service.Client.Read(fmt.Sprintf("%s/%d", workloadGroupsEndpoint, workloadID), &amp;workloadGroup)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">service.Client.Logger.Printf("[DEBUG]Returning workload group from Get: %d", workloadGroup.ID)
        return &amp;workloadGroup, nil</span>
}

func GetByName(service *services.Service, workloadName string) (*WorkloadGroup, error) <span class="cov0" title="0">{
        var workloadGroups []WorkloadGroup
        err := common.ReadAllPages(service.Client, workloadGroupsEndpoint, &amp;workloadGroups)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for _, workloadGroup := range workloadGroups </span><span class="cov0" title="0">{
                if strings.EqualFold(workloadGroup.Name, workloadName) </span><span class="cov0" title="0">{
                        return &amp;workloadGroup, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("no workload group found with name: %s", workloadName)</span>
}

func GetAll(service *services.Service) ([]WorkloadGroup, error) <span class="cov0" title="0">{
        var workloadGroups []WorkloadGroup
        err := common.ReadAllPages(service.Client, workloadGroupsEndpoint, &amp;workloadGroups)
        return workloadGroups, err
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
